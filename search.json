[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bilgisayarlı Yöntemler",
    "section": "",
    "text": "Bu site, çeşitli kaynaklardan derlenerek hazırlanan sayısal yöntemler veya bilgisayarlı yöntemler notlarını içerir. Bu notlar, sayısal analiz, diferansiyel denklemler, optimizasyon, istatistik ve benzeri konularda kullanılan algoritmaları ve bu algoritmaların nasıl çalıştığını anlatır.\nEğer bu notlarla ilgili herhangi bir hata veya eksiklik bulursanız, lütfen GitHub Issue sayfasına yazınız. Bu link her sayfanın sağ tarafında bulunmaktadır.\nSol taraftaki menüden konulara ulaşabilirsiniz. Ayrıca, her sayfanın altında bulunan “Next” ve “Previous” butonları ile notları sırasıyla okuyabilirsiniz.\n\n\n\n\n\n\nUyarı\n\n\n\nBuradaki notlar ve kodlar açık kaynak kodudur. Kişisel kullanım ve eğitim amaçlıdır. Ticari amaçlar için kullanılmamalıdır."
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html",
    "href": "icerik/konular/fourier-analizi/giris.html",
    "title": "Giriş",
    "section": "",
    "text": "Basit bir sinüs dalgası oluşturalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# x-y noktaları\nx= np.linspace(0,8*np.pi,1000)\ny= np.sin(x)\n# Çiz\nplt.plot(x,y)\nplt.ylabel('Genlik')\nplt.xlabel('x')\nplt.show()\n\n\n\n\n\n\n\n\nSinüs dalgası hem zamanda hem de uzayda değişebilir. Yukarıda çizilen dalga zaman içerisinde değişmemektedir yani durağan bir dalgadır. Durağan olmayan dalgalara örnek bir kod yazalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nzaman= np.arange(5)\nx= np.linspace(0,8*np.pi,1000)\nn= len(zaman)\n#Çiz\nfor t in zaman:\n    plt.subplot(n,1,t+1)\n    y= np.sin(x+t)\n    plt.plot(x,y, 'b')\n    plt.plot(x[25], y[25], 'ro')\n    plt.ylim(-1.1,1.1)\n    plt.ylabel('y')\n    plt.title(f\"t={t}\")\nplt.xlabel('x')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki grafikte kırmızı nokta durağan olmayan bir dalganın konumunu göstermektedir. Bu davranış, tıpkı bir su dalgası üzerinde bulunan bir odun parçasının yukarı aşağıya gitmesi gibidir. Dalga x doğrultusunda ilerlerken, odun parçası yukarı aşağıya hareket eder.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html#fourier-analizi",
    "href": "icerik/konular/fourier-analizi/giris.html#fourier-analizi",
    "title": "Giriş",
    "section": "",
    "text": "Basit bir sinüs dalgası oluşturalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# x-y noktaları\nx= np.linspace(0,8*np.pi,1000)\ny= np.sin(x)\n# Çiz\nplt.plot(x,y)\nplt.ylabel('Genlik')\nplt.xlabel('x')\nplt.show()\n\n\n\n\n\n\n\n\nSinüs dalgası hem zamanda hem de uzayda değişebilir. Yukarıda çizilen dalga zaman içerisinde değişmemektedir yani durağan bir dalgadır. Durağan olmayan dalgalara örnek bir kod yazalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nzaman= np.arange(5)\nx= np.linspace(0,8*np.pi,1000)\nn= len(zaman)\n#Çiz\nfor t in zaman:\n    plt.subplot(n,1,t+1)\n    y= np.sin(x+t)\n    plt.plot(x,y, 'b')\n    plt.plot(x[25], y[25], 'ro')\n    plt.ylim(-1.1,1.1)\n    plt.ylabel('y')\n    plt.title(f\"t={t}\")\nplt.xlabel('x')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki grafikte kırmızı nokta durağan olmayan bir dalganın konumunu göstermektedir. Bu davranış, tıpkı bir su dalgası üzerinde bulunan bir odun parçasının yukarı aşağıya gitmesi gibidir. Dalga x doğrultusunda ilerlerken, odun parçası yukarı aşağıya hareket eder.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html#dalgaların-karakteristikleri",
    "href": "icerik/konular/fourier-analizi/giris.html#dalgaların-karakteristikleri",
    "title": "Giriş",
    "section": "Dalgaların Karakteristikleri",
    "text": "Dalgaların Karakteristikleri\nDalgaların karakteristik özelliklerini tanımlayan bazı ifadeler aşağıda maddelenmiştir.\n\nFrekans: Dalganın birim zamanda kaç kez tekrarlandığını gösterir. Birimi Hz (Hertz)’dir. 1 Hz = 1 s\\(^{-1}\\)\nPeriyot: Dalganın bir tam periyotu tamamlaması için geçen süredir. Birimi s (saniye)’dir. Periyod ile frekans ters orantılıdır. Yani frekans = 1 / periyot.\nGenlik: Dalganın alabileceği maksimum değeridir.\nDalgaboyu: Dalganın bir tam periyotu boyunca. Birimi uzunlukdur.\n\n\n\n\n\n\n\nNot\n\n\n\nDalgalar/sinyaller sürekli tekrar eder. Analiz yaparken dalgaların belirli bir aralıktaki değerini çizdiririz. Bu aralığa pencere aralığı denir. Örneğin bir ses dalgasının ekolayzorını yapmak isteyelim. Basların ve tizlerin yoğunluğunu belirli bir pencere aralığında gösteririz ve bu bas/tizler şarkının her pencere aralığında farklı değerler olacaktır.\n\n\nBu nicelikleri grafik üzerinde gösteren python kodunu yazalım  [1].\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Dalganın karakteristikleri\nfrekans = 2  # Hz\nperiyot = 1 / frekans  # s\ngenlik = 1\ndalga_uzunlugu = 2  # metre\n# Zaman aralığı\nt = np.linspace(0, 2* periyot, 50)\n# Dalganın formülü\ndalga = genlik * np.sin(2* np.pi* frekans* t)\n# Çiz\nplt.plot(t, dalga, label='Dalga', color='blue')\nplt.plot(t, dalga, 'o', label='Örneklemler', color='magenta')\n# Genlik oku\nplt.annotate('', xy=(0.12, genlik), xytext=(0.12, 0),\n             arrowprops=dict(facecolor='red'))\nplt.text(0.08, genlik / 2.8, 'GENLİK', rotation=90, color='red')\n# Periyot oku\nplt.annotate('', xy=(0.6, 1), xytext=(0.15, 1),\n             arrowprops=dict(facecolor='green'))\nplt.text(0.32, 0.85, 'PERİYOT', rotation=0, color='green')\nplt.title('Dalganın Özellikleri')\nplt.xlabel('Zaman (s)')\nplt.ylabel('Genlik')\nplt.xlim(0, 2*periyot)\nplt.ylim(-1.3, 1.3)\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki şekilde fuşya (galibarda, magenta) noktalar ise örneklemdir (sampling).\nÖrneklem oranı (sampling rate) ise örneklem sıklığını gösterir. Örneklem sıklığını yukarıdaki grafikte noktaların sıklığı olarak düşünebiliriz. Örneklem oranı arttıkça dalga daha iyi bir şekilde temsil edilir.\nDiğer karakteristikleri de anlamak için durağan olmayan bir sinüs dalgası ele alalım.\n\\[\ny(t) = A \\sin(\\omega t + \\phi)\n\\]\nBurada \\(A\\) genlik, \\(\\omega\\) açısal frekans, \\(\\phi\\) ise fazdır.\nAçısal frekans ise \\(\\omega = 2 \\pi f\\) şeklinde hesaplanır. Burada \\(f\\) frekansıdır.\nFaz, \\(\\phi\\) ise dalganın başlangıç noktasını belirler.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nt = np.arange(0,2* np.pi, 0.1)\n# Çiz (farklı frekanslar)\nplt.title(\"Farklı Frekanslar\")\nplt.plot(t, np.cos(2*np.pi*0.2*t), \"b\", label=\"sin(2$\\pi$0.2t)\")\nplt.plot(t, np.cos(2*np.pi*0.4*t), \"r\", label=\"sin(2$\\pi$0.4t)\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi],\n    [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\"])\nplt.legend()\nplt.show()\nplt.close()\n# Çiz (farklı fazlar)\nplt.title(\"Faz Farkı\")\nplt.plot(t, np.cos(2*np.pi*0.2*t), \"g\", label=\"sin(2$\\pi$0.2t)\")\nplt.plot(t, np.cos(2*np.pi*0.2*t+ np.pi/2),\n    \"k\", label=\"sin(2$\\pi$0.2t + $\\pi$/2)\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\n# X label in terms of pi\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi],\n              [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYukarıdaki grafikte farklı frekanslar ve farklı fazlar için dalgalar çizilmiştir. İki veya daha fazla dalganın üst üste binmesiyle oluşan dalgaların analizi için Fourier analizi kullanılır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html#problemler",
    "href": "icerik/konular/fourier-analizi/giris.html#problemler",
    "title": "Giriş",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nFrekansı 2 Hz, genliği 1 ve fazı 0 olan bir cosinüs dalgasını çizdirin.\nBu dalgayı ve yeni bir dalgayı daha kullanarak yapıcı ve yıkıcı girişimleri gösteren bir grafik çizdirin.\n\n\n\nProblem 2\n\\(0\\) ile \\(L\\) arasında sonsuz kuyuda hapsedilmiş parçacığın durağan dalga fonksiyonu aşağıdaki gibi yazılır.\n\\[\n\\psi(x)=\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi x}{L}\\right)\n\\]\nBurada \\(L=2\\) [birimsiz] kuyunun uzunluğu, \\(n\\) ise kuantum numarasıdır. Aşağıdaki soruları cevaplayın.\n\nBu fonksiyonu \\(N=1,2,3\\) için çizdirin. Grafiğin başlığına genliği, frekansı ve fazı yazın.\nOlasılık yoğunluğunu çizdirin. Olasılık yoğunluğu \\(|&lt;\\psi(x)|\\psi(x)&gt;|^{2}\\) olarak hesaplanır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "HFD, Gauss’un yayınlanmamış 1805 yılındaki çalışmalarına dayanır. Temel olarak KFD algoritmasını daha küçük parçalara bölerek hesaplar. Bu küçük parçaları hesaplamak için ise tekrarlanan (rekürsif, recursive) bir algoritma kullanır.\n\n\nKFD denklemini hatırlayalım.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\(k+N\\)’inci frekansın değeri ise aşağıdaki gibidir.\n\\[\nX_{k+N} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi (k+N) n / N}\n\\]\n\\(e^{-i2\\pi n}=1\\) özelliğini kullanalım.\n\\[\n\\begin{align*}\n    X_{k+N} =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N} e^{-i 2 \\pi N n / N}\\\\\n    =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\\\\\n    =& X_{k}\n\\end{align*}\n\\]\nFormülde bir simetri elde ettik \\(X_{k+N}=X_{k}\\).\nBu simetrinin anlamı şudur: \\(X_{k}\\)’nın değeri, \\(X_{k+N}\\) değerine eşit olması demek, aynı değeri veren bazı \\(X_{k}\\) değerleri olduğunu gösterir. Ayrıca gösterilebiliriz ki bu simetri \\(k+N\\), \\(x+2N\\), \\(\\cdots\\) için de geçerlidir. O halde simetriyi \\(X_{k+i\\times N}=X_{k}\\) şeklinde genelleştirebiliriz. Burada \\(i\\) bir tam sayıdır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hfd---hızlı-fourier-dönüşümü-fft---fast-fourier-transform",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hfd---hızlı-fourier-dönüşümü-fft---fast-fourier-transform",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "HFD, Gauss’un yayınlanmamış 1805 yılındaki çalışmalarına dayanır. Temel olarak KFD algoritmasını daha küçük parçalara bölerek hesaplar. Bu küçük parçaları hesaplamak için ise tekrarlanan (rekürsif, recursive) bir algoritma kullanır.\n\n\nKFD denklemini hatırlayalım.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\(k+N\\)’inci frekansın değeri ise aşağıdaki gibidir.\n\\[\nX_{k+N} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi (k+N) n / N}\n\\]\n\\(e^{-i2\\pi n}=1\\) özelliğini kullanalım.\n\\[\n\\begin{align*}\n    X_{k+N} =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N} e^{-i 2 \\pi N n / N}\\\\\n    =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\\\\\n    =& X_{k}\n\\end{align*}\n\\]\nFormülde bir simetri elde ettik \\(X_{k+N}=X_{k}\\).\nBu simetrinin anlamı şudur: \\(X_{k}\\)’nın değeri, \\(X_{k+N}\\) değerine eşit olması demek, aynı değeri veren bazı \\(X_{k}\\) değerleri olduğunu gösterir. Ayrıca gösterilebiliriz ki bu simetri \\(k+N\\), \\(x+2N\\), \\(\\cdots\\) için de geçerlidir. O halde simetriyi \\(X_{k+i\\times N}=X_{k}\\) şeklinde genelleştirebiliriz. Burada \\(i\\) bir tam sayıdır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hızlanmak-için-yapılan-numaralar",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hızlanmak-için-yapılan-numaralar",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Hızlanmak İçin Yapılan Numaralar",
    "text": "Hızlanmak İçin Yapılan Numaralar\nKFD algoritmasının simetri özelliğini kullanarak N sayısını 2’ye bölelim. Böldüğümüz kısımlar \\(n\\)’in tek ve çift olduğu durumlar olsun.\n\\[\n\\begin{align*}\nX_{k} =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\\\\\n      =& \\sum_{m=0}^{N/2-1} x_{2m} e^{-i 2 \\pi k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i 2 \\pi k (2m+1) / N}\\\\\n\\end{align*}\n\\]\nBu toplamdaki ilk terim \\(n\\)’in çift terimlerinden oluşuyor, ikinci terim ise tek terimlerden oluşuyor. Hesaplamaya devam edelim ve \\(2m/N\\) yerine \\(m/(N/2)\\) yazalım.\n\\[\n\\begin{align*}\nX_{k} =& \\sum_{m=0}^{N/2-1} x_{2m} e^{-i 2 \\pi k m / (N/2)} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i 2 \\pi k (2m+1) / N}\\\\\n      =& \\sum_{m=0}^{N/2-1} x_{2m} e^{-i 2 \\pi k m / (N/2)} + e^{-i 2 \\pi k / N} \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i 2 \\pi k m / (N/2)}\\\\\n\\end{align*}\n\\]\nKFT’daki simetri bize şunu söyler. \\(X_{k}\\)’yı hesaplarken \\(N/2\\)’ye kadar olan kısmı hesaplıdır. Yani yukarıdaki toplamın sadece birisini hesapladığımızda diğerini de hesaplamış oluruz. Bu da bilgisayara yaptıracağımız işi yarıya indirir.\nYukarıda yaptığımız yarıya bölme işlemini tekrar tekrar yaparak en küçük parçaya gidilir. HFD algoritmasının tekrarlanan yapısı da buradan gelir. Bunun için algoritmada kendi kendine çağıran bir yapı kullanacağız. Bu yapıya fonksyion tekrarlanması (function recursion) adı verilir  [1].\nHFD algoritması bu şekilde çalışarak hesaplama zamanını oldukça azaltır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kod",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kod",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Kod",
    "text": "Kod\nfourier_hfd fonksiyonu bilYonMod.py dosyasına tanımlıdır. Aşağıdaki kodu inceleyelim.\n\n\n\n\n\n\nNot\n\n\n\nfourier_hfd fonksiyonunu inceleyiniz.\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nfourier_hfd fonksiyonu, sadece \\(N\\) sayısının 2’nin üssü olduğu durumlar için çalışır. Yani fourier_hfd fonksiyonu verdiğiniz her sinyal için çalışmaz.\n\n\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Örnelem sayısı\norneklemOrani = 128\n# Zaman\norneklemAraligi = 1.0/orneklemOrani\nt = np.arange(0, 1, orneklemAraligi)\n# Toplam Örnekleme Sayısı\nN= len(t)\n# Birinci dalgayı olustur\n# Frekans\nfrek = 1.\n# Birinci dalgayı oluştur\nx = 3*np.sin(2* np.pi* frek* t)\n# İkinci dalganın frekansı\nfrek = 4\n# İkinci dalgayı oluştur\nx += np.sin(2* np.pi* frek* t)\n# Üçüncü dalganın frekansı\nfrek = 7\n# Üçüncü dalgayı oluştur\nx += 0.5* np.sin(2* np.pi* frek* t)\n# Sinyali Çiz\nplt.plot(t, x, \"r\", label= \"$3\\\\sin(2\\\\pi 1 t)+ 2\\\\sin(2\\\\pi 4 t)+ 0.5sin(2\\\\pi 7 t)$\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.title(f\"Sinyal, Örnekleme Sayısı: {N}\")\nplt.legend()\nplt.show()\nplt.close()\n# -------------------------\n# Hızlı Fourier Dönüşümü\nX=bym.fourier_hfd(x)\n# Frekans\nif N%2 == 0:\n    maksFrek= N/ 2\n    XPoz= X[:int(N/2)]\n    XNeg= X[int(N/2):]\n    frekCoz=maksFrek/ (N/2)\nelse:\n    maksFrek= (N-1)/ 2\n    XPoz= X[:int((N-1)/2)]\n    XNeg= X[int((N+1)/2):]\n    frekCoz=maksFrek/ ((N-1)/2)\nfrekPoz= np.arange(0, maksFrek, frekCoz)\nfrekNeg= np.arange(-maksFrek, 0, frekCoz)\n# Çiz\nfig, axs = plt.subplots(3, 1)\n# Re(X) Değeri\naxs[0].stem(frekPoz, np.real(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\naxs[0].stem(frekNeg, np.real(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\n# Imag(X) Değeri\naxs[1].stem(frekPoz, np.imag(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\naxs[1].stem(frekNeg, np.imag(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\n# |X| Değeri\naxs[2].stem(frekPoz, np.abs(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\naxs[2].stem(frekNeg, np.abs(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\n# Kozmetik\naxs[0].set_ylabel(\"Re($X_{k}$) Değeri\")\naxs[0].set_title(\"Hızlı Fourier Dönüşümü\")\naxs[1].set_ylabel(\"Im($X_{k}$) Değeri\")\naxs[1].set_yticklabels([])\naxs[2].set_ylabel(\"|$X_{k}$| Değeri\")\naxs[2].set_xlabel(\"Frekans (Hz)\")\nplt.legend()\nplt.show()\nplt.close()\n# Tek bir tarafı çizdir (Pozitif Frekanslar)\nplt.stem(frekPoz, np.abs(XPoz)/(N/2), 'r', markerfmt=\" \", basefmt=\"-r\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.ylabel(\"Normalize, Tek Taraflı |$X_{k}$|$_{norm}$ Değeri\")\n# X Eksenindeki Sayıları Belirle\nplt.xticks([1, 4, 7, 10, 20, 30, 40, 50, 60])\nplt.tight_layout()\nplt.show()\nplt.close()",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hız-testi",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hız-testi",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Hız Testi",
    "text": "Hız Testi\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport time\n# Örnekleme sayısı\norneklemOrani = 2**11\n# Zaman\norneklemAraligi = 1.0/orneklemOrani\nt = np.arange(0, 1, orneklemAraligi)\n# Toplam Örnekleme Sayısı\nN= len(t)\n# Birinci dalgayı olustur\n# Frekans\nfrek = 1.\n# Birinci dalgayı oluştur\nx = 3*np.sin(2* np.pi* frek* t)\n# İkinci dalganın frekansı\nfrek = 4\n# İkinci dalgayı oluştur\nx += np.sin(2* np.pi* frek* t)\n# Üçüncü dalganın frekansı\nfrek = 7\n# Üçüncü dalgayı oluştur\nx += 0.5* np.sin(2* np.pi* frek* t)\nprint(f\"Örnekleme Sayısı: {N}\")\n# Kesikli Fourier Dönüşümü\nstart = time.time()\nX=bym.fourier_kfd(x)\nend = time.time()\nprint(f\"Kesikli Fourier Dönüşümü: {end-start:.2f} saniye\")\n# Hızlı Fourier Dönüşümü\nstart = time.time()\nX=bym.fourier_hfd(x)\nend = time.time()\nprint(f\"Hızlı Fourier Dönüşümü  : {end-start:.2f} saniye\")\n\nÖrnekleme Sayısı: 2048\nKesikli Fourier Dönüşümü: 5.86 saniye\nHızlı Fourier Dönüşümü  : 0.02 saniye",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hazır-fonksiyonlar",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hazır-fonksiyonlar",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Hazır Fonksiyonlar",
    "text": "Hazır Fonksiyonlar\nDaha detaylı bilgi için numpy.fft ve scipy.fft modüllerinin dökümantasyonunu inceleyebilirsiniz.\n\nimport numpy as np\n#import scipy.fft as spfft\nimport matplotlib.pyplot as plt\n# Örnekleme sayısı\norneklemOrani = 2**13\n# Zaman\norneklemAraligi = 1.0/orneklemOrani\nt = np.arange(0, 6, orneklemAraligi)\n#toplamSure= 1\n#t= np.linspace(0, toplamSure, orneklemOrani* toplamSure)\nN= len(t)\n# Açısal Frekans\nfrekans= 5\nfrekans2= 7\n# Sinyal\nsinyal= np.sin((2 * np.pi) *frekans* t)\\\n    + 2*np.sin((2 * np.pi) *frekans2* t)\n# Hızlı Fourier Dönüşümü\nX= np.fft.fft(sinyal)\n# X= spfft.fft(sinyal)\n# Frekans\nfrek= np.fft.fftfreq(N, 1/orneklemOrani)\n#frek= spfft.fftfreq(N, 1/orneklemOrani)\n# Çiz\nplt.stem(frek, np.abs(X)/orneklemOrani, 'b', markerfmt=\" \", basefmt=\"-b\")\nplt.xlim(-15, 15)\nplt.show()\n\n\n\n\n\n\n\n\nGrafikteki y ekseni, dalga içerisindeki frekansların büyüklüğünü gösterir. Yani 5 Hz’e sahip olan dalganın genliği, 10 Hz’e sahip olan dalganın genliğinin yarısıdır.\n\n\n\n\n\n\nNot\n\n\n\nHızlı Fourier dönüşümünde scipy, numpy’dan daha hazlıdır  [2].",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#problemler",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#problemler",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAçısal frekansı 5, genliği 10 olan bir cosinüs sinyali ve açısal frekansı 10, genliği 5 olan bir sinüs sinyalinin toplamını çizdirin. Örneklem oranı \\(100\\), \\(t=[0,6)\\) aralığında olsun. Sinyalin HFD’sini hesaplayın ve doğru frekanslar için çizdirin.\n\n\nProblem 2\nBir sinyalin frekans uzayını kullanarak örneklem miktarını arttıralım. Bunun için örnek bir sinyal oluşturacağız. Bu sinyalin örneklem sayısını frekans uzayında arttırıp efektif olarak interpolasyon yapacağız.\n\nBir sinyal oluşturun. Bu sinyal, \\(0\\) ile \\(8\\pi\\) arasında, her \\(\\pi/2\\) aralığında bir örnekleme ile alınmış olsun.\nSinyal \\(\\sin(t) + 0.3\\sin(0.2t)\\) şeklinde olsun.\nBu sinyalin HFD’sini hesaplayın.\nBu sinyalin frekans bileşenlerini bulun.\nBu sinyalin örneklem sayısını \\(64\\) kat artırın.\nYeni örneklem sayısına göre frekans bileşenlerini bulun.\nYeni bir hfd sinyal değişkeni oluşturun. Bu yeni hfd sinyal değişkeni yeni örneklem sayısından oluşan frekans boyutunda olacaktır.\nEski hfd sinyalinin 0. bileşenini yeni hfd sinyal değişkeninin 0. bileşenine atayın.\nEski hfd sinyalinin pozitif ([1:N//2+1]) bileşenlerini ve negatif ([-N//2+1:]) bileşenlerini yeni hfd sinyal değişkenine atayın.\nEski ve yeni hfd sinyallerini çizdirin.\nYeni hfd sinyalini ters Fourier dönüşümü yaparak zaman uzayına çevirin.\nOrijinal ve interpolasyon yapılmış sinyalleri çizdirin.\n\n\n\nProblem 3\nZamandan bağımsız Schrödinger denklemini boşluk için çözdüğümüzde Gaussian dalga paketini elde ederiz. Konum uzayındaki dalga fonksiyonu aşağıdaki gibidir.\n\\[ \\psi(x, t=0) = &lt;x | \\psi(0)&gt;= e^{-\\frac{(x- \\mu)^{2}}{4\\sigma_{x}^{2}}+i k_{0} x}\\]\nBurada \\(\\mu\\) paketin merkezini yani ortalama (mean) değeridir. \\(\\sigma_{x}\\) ise \\(x\\) uzayındaki standart sapmayı yani belirsizliği verir. \\(k_{0}= p/\\hbar\\) ise paketin momentumunu verir.\n\n[5 Puan] Yukarıda verilen dalga paketinin konum uzayındaki olasılık yoğunluğunu çizdirin. Formülde \\(\\mu = 0\\), \\(\\sigma_{x} = 0.1\\) ve \\(k_{0} = 10\\) olarak alın. Konumu \\(x = -1\\) ile \\(x = 1\\) arasında on bin parçaya ayırarak alabilirsiniz.\n[10 Puan] Elde ettiğiniz dalga paketinin Fourier dönüşümünü ve frekansları hesaplayın.\n[5 Puan] Fourier dönüşümünden elde ettiğiniz Gaussian dalga paketinin momentum uzayındaki olasılık yoğunluğunu çizdirin.\n[5 Puan] Aynı işlemi \\(\\sigma_x=0.001\\) için tekrar edin. Konum uzayındaki olasılık fonksiyonunu ve momentum uzayındaki olasılık fonksiyonunu nasıl değişti? print() fonksiyonu ile açıklayın.\n[5 Puan] Yukarıdaki işlem ile Heisenberg belirsizlik ilkesi arasında nasıl bir bağlantı vardır? print() fonksiyonu ile açıklayın.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kaynaklar",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kaynaklar",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nPython Programming and Numerical Methods, Qingkai Kong, 2018\nhttps://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html",
    "title": "Uygulama - Ses Dalgaları",
    "section": "",
    "text": "Örnek olarak aşağıdaki adımları takip edelim.\n\nscipy.io.wavfile modülünü çağırın.\nÖrnekleme oranı \\(44100\\) Hz olsun. Yani oluşturacağınız sinyallerin bir saniyesindeki veri sayısı bu olsun. Ses bilgi için  [1] numaralı kaynağa bakabilirsiniz.\nBir sinüs sinyali oluşturun. Frekansı 440 Hz, süresi 5 saniye olsun.\nBir sinüs sinyali oluşturun. Frekansı 880 Hz, süresi 5 saniye olsun.\nBu iki sinyali başka bir değişkende toplayın.\nTüm sinyalleri alt alta çizdirin.\nTüm sinyalleri 0.01 saniyeye kadar olan kısmını alt alta çizdirin.\nTüm değişkenleri oranlayın wav dosyası kaydetmek üzere değişkene atayın (scaling).\nTüm değişkenleri write(\"&lt;dosya_adi&gt;.wav\", örneklemeOranı, &lt;degisken&gt;) ile kaydedin.\n\nŞimdi bu adımları kodlayalım.\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\n# Veriyi oluştur\norneklemeOrani= 44100 # 1 saniyede kaç tane veri var?\nsure= 5 # s\n# Zaman\nt= np.linspace(0, sure, orneklemeOrani* sure)\n# Sinüs dalgaları\nveri1_440Hz= np.sin(2*np.pi*440*t)\nveri2_880Hz= np.sin(2*np.pi*880*t)\nveri3= veri1_440Hz + veri2_880Hz\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(t, veri1_440Hz)\naxs[0].set_title(\"440Hz\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, veri2_880Hz)\naxs[1].set_title(\"880Hz\")\naxs[1].set_xlim([0, 0.01])\naxs[2].plot(t, veri3)\naxs[2].set_title(\"440Hz + 880Hz\")\naxs[2].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\n# Normalizasyon için [-32767, 32767] kullacağız.\n# Çünkü 16 bitlik ses dosyaları bu aralıkta değer alır.\nveri1_440Hz = np.int16((veri1_440Hz/ np.max(np.abs(veri1_440Hz)))* 32767)\nveri2_880Hz = np.int16((veri2_880Hz/ np.max(np.abs(veri2_880Hz)))* 32767)\nveri3 = np.int16((veri3/ np.max(np.abs(veri3)))* 32767)\n# Dosyları wav formatında, ../../../sesler klasörüne kaydet\nwavfile.write(sesler_dir+ \"sin1_440Hz.wav\", orneklemeOrani, veri1_440Hz)\nwavfile.write(sesler_dir+ \"sin2_880Hz.wav\", orneklemeOrani, veri2_880Hz)\nwavfile.write(sesler_dir+ \"sin3_440Hz880Hz.wav\", orneklemeOrani, veri3)",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#ses-dosyası-oluşturma",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#ses-dosyası-oluşturma",
    "title": "Uygulama - Ses Dalgaları",
    "section": "",
    "text": "Örnek olarak aşağıdaki adımları takip edelim.\n\nscipy.io.wavfile modülünü çağırın.\nÖrnekleme oranı \\(44100\\) Hz olsun. Yani oluşturacağınız sinyallerin bir saniyesindeki veri sayısı bu olsun. Ses bilgi için  [1] numaralı kaynağa bakabilirsiniz.\nBir sinüs sinyali oluşturun. Frekansı 440 Hz, süresi 5 saniye olsun.\nBir sinüs sinyali oluşturun. Frekansı 880 Hz, süresi 5 saniye olsun.\nBu iki sinyali başka bir değişkende toplayın.\nTüm sinyalleri alt alta çizdirin.\nTüm sinyalleri 0.01 saniyeye kadar olan kısmını alt alta çizdirin.\nTüm değişkenleri oranlayın wav dosyası kaydetmek üzere değişkene atayın (scaling).\nTüm değişkenleri write(\"&lt;dosya_adi&gt;.wav\", örneklemeOranı, &lt;degisken&gt;) ile kaydedin.\n\nŞimdi bu adımları kodlayalım.\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\n# Veriyi oluştur\norneklemeOrani= 44100 # 1 saniyede kaç tane veri var?\nsure= 5 # s\n# Zaman\nt= np.linspace(0, sure, orneklemeOrani* sure)\n# Sinüs dalgaları\nveri1_440Hz= np.sin(2*np.pi*440*t)\nveri2_880Hz= np.sin(2*np.pi*880*t)\nveri3= veri1_440Hz + veri2_880Hz\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(t, veri1_440Hz)\naxs[0].set_title(\"440Hz\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, veri2_880Hz)\naxs[1].set_title(\"880Hz\")\naxs[1].set_xlim([0, 0.01])\naxs[2].plot(t, veri3)\naxs[2].set_title(\"440Hz + 880Hz\")\naxs[2].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\n# Normalizasyon için [-32767, 32767] kullacağız.\n# Çünkü 16 bitlik ses dosyaları bu aralıkta değer alır.\nveri1_440Hz = np.int16((veri1_440Hz/ np.max(np.abs(veri1_440Hz)))* 32767)\nveri2_880Hz = np.int16((veri2_880Hz/ np.max(np.abs(veri2_880Hz)))* 32767)\nveri3 = np.int16((veri3/ np.max(np.abs(veri3)))* 32767)\n# Dosyları wav formatında, ../../../sesler klasörüne kaydet\nwavfile.write(sesler_dir+ \"sin1_440Hz.wav\", orneklemeOrani, veri1_440Hz)\nwavfile.write(sesler_dir+ \"sin2_880Hz.wav\", orneklemeOrani, veri2_880Hz)\nwavfile.write(sesler_dir+ \"sin3_440Hz880Hz.wav\", orneklemeOrani, veri3)",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#nota-silme",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#nota-silme",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Nota Silme",
    "text": "Nota Silme\n\nscipy.io.wavfile modülünü çağırın.\nBir önceki bölümde kaydettiğiniz toplam sinüs dalgası ses dosyasını wavfile.read() ile okuyun.\nSes dosyasının ilk 0.01 saniyesinin grafiğini çizdirin.\nSes dosyasının Fourier analizini yapın.\nscipy.fft.fftfreq(len(veri), 1/orneklemOrani) ile frekansları bulun.\nSes dosyasındaki frekansları (HFD) çizdirin.\n500 Hz’den büyük tüm frekansları sıfırlayın.\nTers Fourier dönüşümü yapın.\nSes dosyasının ilk 0.01 saniyesini gösterin.\nTers dönüşüm ile elde ettiğiniz ses dosyasını kaydedin.\n\nŞimdi bu adımları kodlayalım.\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\nimport scipy.fft as fft\n# sin3_440Hz880Hz.wav dosyasını oku\norneklemOrani, veri = wavfile.read(sesler_dir+ \"sin3_440Hz880Hz.wav\")\n# Süre\nsure= len(veri)/ orneklemOrani\n# Zaman dizisi\nt= np.linspace(0, sure, len(veri))\nplt.plot(t, veri)\nplt.xlim([0,0.01])\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.show()\nplt.close()\n# HFD\nveriHFD= fft.fft(veri)\n# Frekanslar\nveriHFDFrek= fft.fftfreq(len(veri), 1/orneklemOrani)\n# Çiz\nplt.plot(veriHFDFrek, np.abs(veriHFD))\nplt.xlim([-1000,1000])\nplt.ylabel(\"|X(f)|\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.show()\nplt.close()\n# 500 Hz'den büyük tüm frekansları sıfırla\n# (Low Pass Filter)\nveriHFD[veriHFDFrek &gt; 500] = 0 \n#veriHFD[veriHFDFrek &gt; 500] = veriHFD[veriHFDFrek &gt; 500]* 0.5\nveriHFD[veriHFDFrek &lt; -500] = 0\n#veriHFD[veriHFDFrek &lt; -500] = veriHFD[veriHFDFrek &lt; -500]* 0.5 \n# Çiz\nplt.plot(veriHFDFrek, np.abs(veriHFD))\nplt.xlim([-1000,1000])\nplt.ylabel(\"|X(f)| (Filtreli)\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.show()\nplt.close()\n# THFD\nveriTHFD_filtreli= fft.ifft(veriHFD)\n# Zaman\ntTHFD_filtreli=\\\n    np.linspace(0, sure, len(veriTHFD_filtreli))\n# Çiz\nplt.plot(tTHFD_filtreli, np.real(veriTHFD_filtreli))\nplt.xlim([0,0.01])\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.show()\nplt.close()\n# Normalizasyon\n# Gerek yok ama yine de yapalım\nveriTHFD_filtreli = np.int16((np.real(veriTHFD_filtreli)/ np.max(np.abs(veriTHFD_filtreli)))* 32767)\n# Dosyları wav formatında kaydet\nwavfile.write(sesler_dir+\"sin3_440Hz880Hz_filtreliLowPass500.wav\", orneklemOrani, veriTHFD_filtreli)",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#alıştırma-1",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#alıştırma-1",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nYukarıda yapılan örnekte 500’den küçük frekansları sıfırlayın ve tüm adımları tekrarlayın.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#gürültü-ve-ses-dosyası-analizi",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#gürültü-ve-ses-dosyası-analizi",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Gürültü ve Ses Dosyası Analizi",
    "text": "Gürültü ve Ses Dosyası Analizi\n\nÖrnekleme oranını 44100 Hz olarak belirleyin.\nToplam 5 saniye olacak şekilde bir zaman dizisi oluşturun.\n5 saniyelik rastgele bir sinyal gürültüsü oluşturun. np.rand.randn(arrayBoyutu) kullanabilirsiniz.\n5 saniyelik bir sinüs sinyali oluşturun. Frekansı 170 Hz olsun.\nGürültü ve sinüs sinyalini toplayın ve yeni bir değişkene atayın.\nTüm değişkenleri oranlayın (scaling) ve write(\"&lt;dosya_adi&gt;.wav\", örneklemeOranı, &lt;oranli-degisken&gt;) ile kaydedin.\nSinüs, gürültü ve toplam sinyallerinin ilk 0.1 saniyesini aynı grafikte alt alta çizdirin.\n3 adet sinyalin hızlı Fourier dönüşümünü (scipy.fft.fft()) yapın.\n3 adet sinyalin frekanslarını (scipy.fft.fftfreq(len(veri), 1/orneklem_orani)) hesaplayın. Frekans miktarı verinizden bağımsız olacaktır. Sadece verinizin örnekleme oranı (verinin büyüklüğü) ve saniyede kaç örnekleme yaptığınız önemlidir.\nFrekans uzayını, 3 adet alt alta grafik olacak şekilde çizdirin.\nToplam sinyalden gürültü frekansını silin.\nFiltrelenmiş sinyalin Fourier dönüşümünü, karşılaştırmalı olarak çizdirin.\nTers Fourier dönüşümü yapın ve filtrelenmiş sinyalin ilk 0.1 saniyesi ile filtrelenmemiş sinyalin ilk 0.1 saniyesini grafik üzerinde karşılaştırın.\nFiltrelenmiş sinyali wav dosyası olarak kaydedin.\n\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\nimport scipy.fft as fft\n# Veriyi oluştur\norneklemeOrani= 44100\nsure= 5 # s\n# Zaman\nt= np.linspace(0, sure, orneklemeOrani* sure)\n# Sinüs dalgaları\nveri4_170Hz= np.sin(2*np.pi*170*t)\nveri5_Gurultu= np.random.rand(len(t))\nveri6_topla= veri4_170Hz+ veri5_Gurultu\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(t, veri4_170Hz)\naxs[0].set_title(\"170Hz\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, veri5_Gurultu)\naxs[1].set_title(\"Gürültü\")\naxs[1].set_xlim([0, 0.01])\naxs[2].plot(t, veri6_topla)\naxs[2].set_title(\"Gürültü+170Hz\")\naxs[2].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Wav dosyası olarak kaydet\nwavfile.write(sesler_dir+ \"sin4_170Hz.wav\", orneklemeOrani, np.int16((np.real(veri4_170Hz)/ np.max(np.abs(veri4_170Hz)))* 32767))\nwavfile.write(sesler_dir+ \"gurultu.wav\", orneklemeOrani, np.int16((np.real(veri5_Gurultu)/ np.max(np.abs(veri5_Gurultu)))* 32767))\nwavfile.write(sesler_dir+ \"sin4_170Hz_gurultulu.wav\", orneklemeOrani, np.int16((np.real(veri6_topla)/ np.max(np.abs(veri6_topla)))* 32767))\n# HFD\nhfd_veri4_170Hz= fft.fft(veri4_170Hz)\nhfd_veri5_Gurultu= fft.fft(veri5_Gurultu)\nhfd_veri6_topla= fft.fft(veri6_topla)\n# Frekanslar\nhfd_veri4_170HZ_frek= fft.fftfreq(len(veri4_170Hz), 1/orneklemeOrani)\nhfd_veri5_Gurultu_frek= fft.fftfreq(len(veri5_Gurultu), 1/orneklemeOrani)\nhfd_veri6_topla_frek= fft.fftfreq(len(veri6_topla), 1/orneklemeOrani)\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(hfd_veri4_170HZ_frek, np.abs(hfd_veri4_170Hz))\naxs[0].set_title(\"HFD-170Hz\")\naxs[0].set_xlim([-1000, 1000])\naxs[1].plot(hfd_veri5_Gurultu_frek, np.abs(hfd_veri5_Gurultu))\naxs[1].set_title(\"HFD-Gürültü\")\naxs[1].set_xlim([-1000, 1000])\naxs[2].plot(hfd_veri6_topla_frek, np.abs(hfd_veri6_topla))\naxs[2].set_title(\"HFD-Toplam\")\naxs[2].set_xlim([-1000, 1000])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Toplam sinyalden gürültüyü çıkar\nhfd_veri7_topla_filtre= hfd_veri6_topla - hfd_veri5_Gurultu\n# Çiz\nfig, axs= plt.subplots(2,1)\naxs[0].plot(hfd_veri6_topla_frek, np.abs(hfd_veri6_topla))\naxs[0].set_title(\"HFD-Toplam\")\naxs[0].set_xlim([-1000, 1000])\naxs[1].plot(hfd_veri6_topla_frek, np.abs(hfd_veri7_topla_filtre))\naxs[1].set_title(\"HFD-Toplam-Gürültüsüz\")\naxs[1].set_xlim([-1000, 1000])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Ters HFD\nveri7_topla_filtre= fft.ifft(hfd_veri7_topla_filtre)\n# Çiz\nfig, axs= plt.subplots(2,1)\naxs[0].plot(t, np.abs(veri6_topla))\naxs[0].set_title(\"Toplam-Veri\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, np.real(veri7_topla_filtre))\naxs[1].set_title(\"Toplam-Veri-Gürültüsüz\")\naxs[1].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Wav dosyası olarak kaydet\nwavfile.write(sesler_dir+ \"sin4_170Hz_gurultulu_filtreli.wav\", orneklemeOrani, np.int16((np.real(veri7_topla_filtre)/ np.max(np.abs(veri7_topla_filtre)))* 32767))",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#problemler",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#problemler",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nKara Delik Birleşmesi (GW150914)\n\nhttps://gwosc.org/events/GW150914/ sitesine gidin. Bu sitede 2015 yılında tespit edilen kara delik birleşmesi verileri bulunmaktadır.\nObservation of Gravitational Waves from a Binary Black Hole Merger başlığına tıklayınız. Burada hem Hanford hem de Livingston merkezlerinden alınan veriler bulunmaktadır.\n\nhttps://gwosc.org/GW150914data/P150914/fig1-observed-H.txt\nhttps://gwosc.org/GW150914data/P150914/fig1-observed-L.txt\n\nBu dosyaları pandas kütüphanesini kullanarak okuyun, pandas.read_csv(\"&lt;LINK&gt;, skiprows=1, sep=\" \", header=None\") .\nVerilerin grafiğini üst üste çizdirin.\nVerileri wav dosyası olarak kaydedin. (https://www.youtube.com/watch?v=TWqhUANNFXw)\nVerilerin Fourier dönüşümünü yapın ve grafiklerini çizdirin.\n\n\n\nProblem 2\nGürültü Silme\n\nGürültü filtreleme işlemini problem2-gurultulu-sinyal.wav dosyası için yapın. Dosyaya bu linkten ulaşabilirsiniz. Bu dosya C akoru ve G akorunu ardı ardına eklenerek oluşturulmuştur.\nSes dosyasını tam ortadan ikiye ayırın.\nİlk yarısına hfd yapın. Bu frekansların 261.63 Hz, 329.63 Hz ve 392.0 Hz olduğunu göreceksiniz.\nBu frekanslar dışındaki tüm frekansları sıfırlayın.\nİkinci yarısına hfd yapın. Bu frekansların 392.0 Hz, 493.88 Hz ve 293.66 Hz olduğunu göreceksiniz.\nBu frekanslar dışındaki tüm frekansları sıfırlayın.\nArdından bu iki dosyanın ters hfd’sini alın ve birleştirin.\nFiltrelenmiş ses dosyasını problem2-gurultusuz-sinyal.wav olarak kaydedin.\n\n\n\nProblem 3\n\n/sesler/ klasörünün içerisinde bulunan DeepPurple_SmokeOnTheWaterIntro.wav dosyasını orneklemOrani, data = wavfile.read() olacak şekilde okuyun. Bu kayıt stereo bir dosyadır ve data değişkeninin ilk sütununu almanız yeterlidir. Bu işlem ile stereo ses kaydının sadece bir tarafını alıyorsunuz.\nSinyali 4’e ayırın. Bunun için aşağıda verilen tablodaki süreleri kullanın. Yardım: t zaman arrayiniz olsun. \\(t=2\\) saniyeye karşılık gelen argümanı bulmak için arg1=np.argmin(np.abs(t- 2)) komutunu kullanabilirsiniz. Yani arg1 değişkeni 100 gibi bir değer olursa t[arg1] değeri \\(2\\) saniye olacaktır.\nAyrılan riffleri zamana göre fig, axs= plt.subplots(4, 1) komutunu kullanarak 4 ayrı grafikte çizdirin. axs[0].plot() komutunu kullanın. Güzel gözükmesini istiyorsanız grafiği göstermeden önce fig.tight_layout() komutunu kullanabilirsiniz.\nAyırdığınız riffleri ayrı ayrı wav dosyası olarak kaydedin.\nTüm rifflerin Fourier dönüşümlerini alın ve frekanslarını belirleyin.\nTüm rifflerin pozitif frekans uzaylarını alt alta çizdirin. axs[0].set_xlim(0, 1000) komutunu kullanarak x-eksenini \\(0\\) ile \\(1000\\) arasında limitleyebilirsiniz.\nilk riff verisinin pozitif frekans uzayında gördüğünüz tepe (peak) değerleri hangi frekansa denk geliyor, bulun, ekrana yazdırın ve Fourier dönüşümü grafiğinde gösterin (plt.axvline(x= hfdfrek_riff1_tepeler_pozitif[0], color= \"red\", lw= 0.5, ls= \"--\")). Yardım: “fft verisinde hangi değerler fft &gt; 9e6 koşulunu sağlanıyor?” sorusuna cevap olacak şekilde bir komut yazabilirsiniz.\n\n\n\n\n\n\n\n\n\n\nRiff-1\nRiff-2\nRiff-3\nRiff-4\n\n\n\n\n0 s - 2.0 s\n2.0 s - 4.25 s\n4.25 s - 6.35 s\n6.35 s - Sonuna kadar",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html",
    "title": "BDP - Giriş",
    "section": "",
    "text": "Amaç \\(y'=F(x,y)\\) denklemini, \\(y(a)=\\alpha\\) başlangıç koşuluyla çözüp \\(y(x)\\)’i istenilen aralıkta elde etmek.\nAşağıdaki gibi formda olan diferansiyel denklemlere birinci dereceden adi diferansiyel denklemler denir.\n\\[\n\\frac{dy}{dx}=y'=f(x)\n\\]\nHer iki tarafın integralini alırsak sağ tarafta bir integral sabiti olur. Bu integral sabitini belirlemek için bir adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nEğer n. dereceden diferansiyel denklem varsa, yani \\(y^{(n)}=f(x,y,y',\\cdots,y^{(n-1)})\\), bu durumda n adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nYüksek dereceden diferansiyel denklemler düşük dereceden diferansiyel denklemlere çevrilebilir. Örneğin,\n\\[\ny''=-y(x) \\qquad y'(x) \\equiv v(x) \\qquad v'(x)=-y(x)\n\\]\nYukarıdaki denklemin koşulları \\(y(0)=1\\), \\(v(0)=1\\) şeklinde ise başlangıç değer problemi, \\(y(0)=1\\) ve \\(v(100)=0\\) şeklinde farklı ise sınır değer problemi olarak tanımlanır.\nDiferansiyel denklemler tek halde bulunabildiği gibi çoklu halde de bulunabilir. Örneğin,\n\\[\n\\textbf{y}'=\\textbf{F}(x,\\textbf{y})\n\\]\n\\[\n\\begin{bmatrix}\ny_1' \\\\\ny_2' \\\\\n\\vdots \\\\\ny_n'\n\\end{bmatrix}=\n\\begin{bmatrix}\nf_1(x,y_1,y_2,\\cdots,y_n) \\\\\nf_2(x,y_1,y_2,\\cdots,y_n) \\\\\n\\vdots \\\\\nf_n(x,y_1,y_2,\\cdots,y_n)\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html#başlangıç-değer-problemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html#başlangıç-değer-problemi",
    "title": "BDP - Giriş",
    "section": "",
    "text": "Amaç \\(y'=F(x,y)\\) denklemini, \\(y(a)=\\alpha\\) başlangıç koşuluyla çözüp \\(y(x)\\)’i istenilen aralıkta elde etmek.\nAşağıdaki gibi formda olan diferansiyel denklemlere birinci dereceden adi diferansiyel denklemler denir.\n\\[\n\\frac{dy}{dx}=y'=f(x)\n\\]\nHer iki tarafın integralini alırsak sağ tarafta bir integral sabiti olur. Bu integral sabitini belirlemek için bir adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nEğer n. dereceden diferansiyel denklem varsa, yani \\(y^{(n)}=f(x,y,y',\\cdots,y^{(n-1)})\\), bu durumda n adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nYüksek dereceden diferansiyel denklemler düşük dereceden diferansiyel denklemlere çevrilebilir. Örneğin,\n\\[\ny''=-y(x) \\qquad y'(x) \\equiv v(x) \\qquad v'(x)=-y(x)\n\\]\nYukarıdaki denklemin koşulları \\(y(0)=1\\), \\(v(0)=1\\) şeklinde ise başlangıç değer problemi, \\(y(0)=1\\) ve \\(v(100)=0\\) şeklinde farklı ise sınır değer problemi olarak tanımlanır.\nDiferansiyel denklemler tek halde bulunabildiği gibi çoklu halde de bulunabilir. Örneğin,\n\\[\n\\textbf{y}'=\\textbf{F}(x,\\textbf{y})\n\\]\n\\[\n\\begin{bmatrix}\ny_1' \\\\\ny_2' \\\\\n\\vdots \\\\\ny_n'\n\\end{bmatrix}=\n\\begin{bmatrix}\nf_1(x,y_1,y_2,\\cdots,y_n) \\\\\nf_2(x,y_1,y_2,\\cdots,y_n) \\\\\n\\vdots \\\\\nf_n(x,y_1,y_2,\\cdots,y_n)\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html",
    "title": "SDP - Giriş",
    "section": "",
    "text": "Farz edelim ki aşağıdaki gibi ikinci dereceden diferansiyel denklemimiz olsun.\n\\[\ny''(x) = f(x,y(x),y'(x))\n\\]\nBu denklemdeki \\(y(x)\\) ve \\(y'(x)\\) fonksiyonunun aynı \\(x\\) (ör. \\(x=0\\)) noktasındaki değerini biliyorsak bu denklem başlangıç değer problemidir. Bu denklemin \\(y(x=a)\\) ve \\(y(x=b)\\) noktalarındaki değerlerini biliyorsak bu denklem kabaca sınır değer problemidir. Yukarıda verdiğimiz örneğe iki-noktalı sınır değer problemi de denir (2-point boundary value problem). Birinci dereceden diferansiyel denklem için sınır değer problemi ile başlangıç değer problemi aynıdır, çünkü denklem bir adet koşula sahiptir.\nÖrneğin Kuyudaki bir parçacığın kuantum mekaniksel hareket denklemi aşağıdaki gibi yazılır.\n\\[\n\\frac{-h}{4\\pi m}\\frac{d^{2}}{dx^{2}}\\psi(x) = E\\psi(x), \\qquad \\psi(x=-L/2)=0, \\qquad \\psi(x=L/2)=0 \\text{.}\n\\]\nBirinci türeve ait bir koşul bilmiyoruz. Sadece bulmak istediğimiz fonksiyonun sınır değerlerini biliyoruz.\n\n\n\n\n\n\nUyarı\n\n\n\nBaşlangıç değer probleminde n. dereceden diferansiyel denklemi çözebilmek için n adet başlangıç koşuluna ihtiyaç vardır. Bu başlangıç koşulları da (n-1). dereceden türeve kadar olmak zorundadır.\n\n\nSınır değer problemlerini çözmek için birinci türeve ait olan denklemdeki başlangıç koşuluna ihtiyaç vardır. Bu sorunu:\n\nBaşlangıç koşulunu  tahmin ederek  aşabiliriz. Bu yönteme atış yöntemi (shooting method) denir.\nDiferansiyel denklemi  örgü noktalarına  (mesh points) bölerek çözebiliriz. Bu yönteme sonlu farklar yöntemi (finite difference method) denir.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html#sınır-değer-problemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html#sınır-değer-problemi",
    "title": "SDP - Giriş",
    "section": "",
    "text": "Farz edelim ki aşağıdaki gibi ikinci dereceden diferansiyel denklemimiz olsun.\n\\[\ny''(x) = f(x,y(x),y'(x))\n\\]\nBu denklemdeki \\(y(x)\\) ve \\(y'(x)\\) fonksiyonunun aynı \\(x\\) (ör. \\(x=0\\)) noktasındaki değerini biliyorsak bu denklem başlangıç değer problemidir. Bu denklemin \\(y(x=a)\\) ve \\(y(x=b)\\) noktalarındaki değerlerini biliyorsak bu denklem kabaca sınır değer problemidir. Yukarıda verdiğimiz örneğe iki-noktalı sınır değer problemi de denir (2-point boundary value problem). Birinci dereceden diferansiyel denklem için sınır değer problemi ile başlangıç değer problemi aynıdır, çünkü denklem bir adet koşula sahiptir.\nÖrneğin Kuyudaki bir parçacığın kuantum mekaniksel hareket denklemi aşağıdaki gibi yazılır.\n\\[\n\\frac{-h}{4\\pi m}\\frac{d^{2}}{dx^{2}}\\psi(x) = E\\psi(x), \\qquad \\psi(x=-L/2)=0, \\qquad \\psi(x=L/2)=0 \\text{.}\n\\]\nBirinci türeve ait bir koşul bilmiyoruz. Sadece bulmak istediğimiz fonksiyonun sınır değerlerini biliyoruz.\n\n\n\n\n\n\nUyarı\n\n\n\nBaşlangıç değer probleminde n. dereceden diferansiyel denklemi çözebilmek için n adet başlangıç koşuluna ihtiyaç vardır. Bu başlangıç koşulları da (n-1). dereceden türeve kadar olmak zorundadır.\n\n\nSınır değer problemlerini çözmek için birinci türeve ait olan denklemdeki başlangıç koşuluna ihtiyaç vardır. Bu sorunu:\n\nBaşlangıç koşulunu  tahmin ederek  aşabiliriz. Bu yönteme atış yöntemi (shooting method) denir.\nDiferansiyel denklemi  örgü noktalarına  (mesh points) bölerek çözebiliriz. Bu yönteme sonlu farklar yöntemi (finite difference method) denir.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "",
    "text": "İkinci dereceden diferansiyel denklemleri çözmek için Euler yöntemini iki kere kullanmak gerekir. Örneğin,\n\\[\ny''(x)+4y(x)=0\n\\]\nİlk adımda \\(y''\\) türevi yerine \\(v(x) \\equiv y'(x)\\) tanımlaması yapalım bu durumda denklem şu şekilde olur.\n\\[\nv'(x)=-4y\n\\]\nYukarıdaki denklem birinci dereceden bir diferansiyel denklem olduğu için Euler yöntemi ile çözülebilir. Bu denklemi çözdükten sonra \\(y(x)\\) fonksiyonunu bulmak için \\(y'(x)\\equiv v(x)\\) denklemini çözmemiz gerekir. Sonuç olarak ikinci dereceden diferansiyel denklemi 2 adet birbirine bağlı dif. denk. sistemi olarak düşünebiliriz.\nDikkat edilmesi gereken husus başlangıç koşullarının \\(y(x)\\) ve \\(v(x)\\) fonksiyonları için yazmaktır. İkinci dereden bir diferansiyel denklemin çözümünü bulabilmek için hem \\(y(x_{0})\\) hem de \\(y'(x_{0})=v(x_{0})\\) koşullarına ihtiyaç vardır.\nİkinci dereceden diferansiyel denklemleri çözmek üst üste Euler çözücü fonksiyonu çağırmak yerine denklemi vektörel bir şekilde yazabiliriz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#bdp---ikinci-dereceden-diferansiyel-denklemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#bdp---ikinci-dereceden-diferansiyel-denklemler",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "",
    "text": "İkinci dereceden diferansiyel denklemleri çözmek için Euler yöntemini iki kere kullanmak gerekir. Örneğin,\n\\[\ny''(x)+4y(x)=0\n\\]\nİlk adımda \\(y''\\) türevi yerine \\(v(x) \\equiv y'(x)\\) tanımlaması yapalım bu durumda denklem şu şekilde olur.\n\\[\nv'(x)=-4y\n\\]\nYukarıdaki denklem birinci dereceden bir diferansiyel denklem olduğu için Euler yöntemi ile çözülebilir. Bu denklemi çözdükten sonra \\(y(x)\\) fonksiyonunu bulmak için \\(y'(x)\\equiv v(x)\\) denklemini çözmemiz gerekir. Sonuç olarak ikinci dereceden diferansiyel denklemi 2 adet birbirine bağlı dif. denk. sistemi olarak düşünebiliriz.\nDikkat edilmesi gereken husus başlangıç koşullarının \\(y(x)\\) ve \\(v(x)\\) fonksiyonları için yazmaktır. İkinci dereden bir diferansiyel denklemin çözümünü bulabilmek için hem \\(y(x_{0})\\) hem de \\(y'(x_{0})=v(x_{0})\\) koşullarına ihtiyaç vardır.\nİkinci dereceden diferansiyel denklemleri çözmek üst üste Euler çözücü fonksiyonu çağırmak yerine denklemi vektörel bir şekilde yazabiliriz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#sec-alistirma1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#sec-alistirma1",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nSürtünmesiz bir düzlemde serbest düşen bir parçacığın konum zaman grafiğini ve hız zaman grafiğini Newton’un ikinci yasasını kullanarak çizin. \\(g=9.81\\) m/s \\(^{2}\\) sabit düşüş ivmesi. Denklemleri Euler yöntemi ile çözün. Başlangıç koşulları \\(v(0)=0\\) ve \\(y(0)=100\\) olsun. Çözümü \\(n=100\\) s adımda yapın. Zaman aralığı \\(t=0\\) s’den \\(t=10\\) s’ye kadar olsun.\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Global değişkenler\ng=9.81\n# Denklemin sağ tarafı\ndef F(yVek, x):\n    # F=m*a\n    # F=m*y''(t)\n    # -g=y''(t)\n    # y'(t)=v(t)\n    # v'(t)=-g\n    return np.array([yVek[1], -g])\n# Başlangıç koşulları\nx0=0\nyVek=np.array([100, 0])\nxStop=5\nn=100\n# Çöz\nxTum, yVekTum = bym.add_coz_euler_sistem(F, x0, xStop, yVek, n)\n# Analitik çözüm\n# y(t) = y0 + v0*t - (1/2)*g*t^2\n# v(t) = v0 - g*t\nyAnalitik= yVek[0] + yVek[1]*xTum - (1/2)*g*xTum**2\nvAnalitik= yVek[1] - g*xTum\n# Çiz\nfig,axs=plt.subplots(1,2)\n# Soldaki grafik\naxs[0].plot(xTum, yVekTum[0,:], 'o-', color='r', label='Euler $y(t)$')\naxs[0].plot(xTum, yAnalitik, 'k', label='Analitik $y(t)$')\naxs[0].set_ylabel('$y(t)$')\naxs[0].legend()\n# Sağdaki grafik\naxs[1].plot(xTum, yVekTum[1,:], 'o-', color='r', label='Euler $v(t)$')\naxs[1].plot(xTum, vAnalitik, 'k', label='Analitik $v(t)$')\naxs[1].set_ylabel('$v(t)$')\naxs[1].set_xlabel('$t$')\naxs[1].legend()\n# Sıkıştır\nplt.tight_layout()\n# Göster\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#problemler",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nBölüm 2 verilen denklemi ilk hızı \\(v(0)=10\\) m/s olarak değiştirerek çözün. Grafikleri karşılaştırın.\n\n\nProblem 2\nYatay düzlemde \\(k=100\\) N/m sabitine sahip \\(m=1\\) kg kütleli yay olsun. Bu cisme denge noktasından \\(x_{0}=0.1\\) m sıkıştırılarak harekete başlatılıyor. Cisim bırakıldığı anda hızı \\(v_{0}=0\\) m/s. Bu cismin hareket denklemini \\(t=0-5\\) aralığında Euler yöntemiyle çözünüz.\n\\[\n-kx=m\\frac{d^{2}x}{dt^{2}}\n\\]\nAnalitik çözüm: \\(x(t) = A\\cos(\\sqrt{k/m}x)+B\\sin(\\sqrt{k/m}x)\\)\n\n\nProblem 3\nBölüm 3.2 bölümündeki soruyu \\(F_{sürtünme}= -bv\\) sürtünme kuvveti varlığında çözünüz. Burada \\(b=1\\) Ns/m sabit ve \\(v\\) cismin hızıdır.\n\\[\n-b\\frac{dx}{dt}-kx=m\\frac{d^{2}x}{dt^{2}}\n\\]\nAnalitik çözüm: \\(x(t) = Ae^{-\\sigma t}e^{i\\omega t}+ Be^{-\\sigma t}e^{-i \\omega t}\\). Burada frekans \\(\\omega = \\sqrt{(k/m)-(b^{2}/4m^{2})}\\) ve genliği belirleyen terim \\(\\sigma=b/2m\\)  [1].\n\n\nProblem 4\nDüşey düzlemde \\(m=1\\) kg kütleli bir cisim salınsın. Bu cisim denge noktasından \\(\\theta_{0}=\\pi/9\\) rad açı ile harekete başlıyor. Cisim bırakıldığı anda açısal hızı \\(\\omega_{0}=\\) rad/s. Bu cismin hareket denklemini \\(t=0-10\\) arasında Euler yöntemiyle çözünüz. En uygun sonuç için \\(n=10000\\) adım alınız. (\\(g=9.81\\))\n\\[\n\\frac{d^{2}\\theta}{dt^{2}}=-\\frac{g}{l}\\sin \\theta\n\\]\nAnalitik çözüm: \\(x(t) = A\\cos(\\sqrt{g/l}x)+B\\sin(\\sqrt{g/l}x)\\)\n\n\nProblem 5\nBölüm 3.4 bölümündeki problemi \\(\\theta_{0}=\\pi/2\\) başlangıç koşulu için tekrar çalıştırınız. \\(\\sin \\theta \\approx \\theta\\) yaklaşıklığı artık geçerli olmadığı için analitik çözümün hatalı olduğunu unutmayınız.\n\n\nProblem 6\nİki cisim problemini (baryosentrik yani merkezdeki cisim hareket etmesin) Euler yöntemiyle (\\(n= 1000, 10000, 100000\\) adımda) çözünüz. Burada \\(\\mu=3.98\\times 10^{5}\\) km \\(^{3}\\)/s \\(^{2}\\), \\(x_{0}=-2500\\) km, \\(y_{0}=-5500\\) km, \\(v_{x0}=7.5\\) km/s, \\(v_{y0}=0.5\\) km/s olarak alın. Aşağıdaki denklemleri \\(t=0-100000\\) s arasında çözün. \\(y-x\\) grafiği çizin. \\((x,y)=(0,0)\\) noktası merkezdeki cismin konumunu göstersin.\n\\[\n\\frac{d^{2}x}{dt^{2}}=-\\frac{\\mu}{(x^{2}+y^{2})^{3/2}}x\n\\]\n\\[\n\\frac{d^{2}y}{dt^{2}}=-\\frac{\\mu}{(x^{2}+y^{2})^{3/2}}y\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "",
    "text": "Euler yöntemi için Taylor serisini birinci dereceden türevli terimden kesmiştik. Eğer Taylor serisinde daha yüksek mertebelerden türevler kullanılırsa, bu yöntemlere Runge-Kutta yöntemleri adı verilir.\n\n\n\n\n\n\nDikkat\n\n\n\nYüksek mertebeden türevler kullanmak demek, yüksek mertebe diferansiyel denklem çözümü anlamına gelmez. Örneğin, birinci dereceden diferansiyel denklemi, Taylor serisinin üçüncü dereceden teriminden keserek çözebiliriz. Runge-Kutta yöntemleri, Euler yönteminin bir genelleştirilmesidir.\n\n\n\n\nAna denklemi yazalım.\n\\[\ny'(x)=f(y,x)\n\\]\nEuler yöntemini hatırlayalım. \\(y'(x)=f(y,x)\\) bağıntısını da kullanalım.\n\\[\ny(x+h)= y(x)+hy'(y,x) = y(x)+hf(y,x)\n\\]\nTaylor serisinin ikinci mertebesinden kesmeden önce en genel formülü yazalım. Bu formül Runge-Kutta yöntemlerinin genel formülüdür.\n\\[\ny(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hf(x+ph,y+qhF(y,x))\n\\]\nBurada \\(c_{0},c_{1},p,q\\) birer katsayıdır. Taylor serisine dönelim.\n\\[\n\\begin{align*}\ny(x+h) &= y(x) + y'(x)h + \\frac{1}{2}y''(x)h^{2}\\\\\n       &= y(x) + F(y,x)h + \\frac{1}{2}f'(y,x)h^{2}    \n\\end{align*}\n\\]\nBurada \\(f'(y,x)\\) aşağıdaki gibi yazılır.\n\\[\n\\begin{align*}\nf'(y,x)&= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}f \\\\\n       &= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}y'\n\\end{align*}\n\\]\nVektörize edilmiş \\(F\\) için ise,\n\\[\nF'(y,x)= \\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nşeklinde yazılır. Taylor açılımından elde ettiğimiz denklemde yerine koyarsak,\n\\[\ny(x+h)= y(x) + F(y,x)h + \\frac{h^{2}}{2}\\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nifadesini elde ederiz. Şimdi genelleştirilmiş formülü, yani \\(y(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hF(x+ph,y+qhF(y,x))\\) terimindeki \\(F(x+ph,y+qhF(y,x))\\) terimi açalım.\n\\[\nF(x+ph,y+qhF(y,x)) = F(y,x) + \\frac{\\partial F}{\\partial x}ph + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}qhF_{i}(y,x)\n\\]\n\nYukarıdaki açılımı genelleştirilmiş formülde yerine koyalım.\n\n\\[\ny(x+h) = y(x) + (c_{0}+c_{1})F(y,x)h+ c_{1}\\left[\\frac{\\partial F}{\\partial x}ph + qh \\sum_{i=1}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\\right]\n\\]\nBurada elde ettiğimiz formül ile Taylor serisinde elde ettiğimiz formülü karşılaştıralım. Eğer\n\\[\nc_{0}+c_{1}=1 \\quad \\text{ve} \\quad c_{1}p=c_{1}q=\\frac{1}{2}\n\\]\nolursa, iki formül de aynı olur. Buradaki \\(c_{0}, c_{1},q,p\\) parametreleri farklı farklı seçilebilir. Bazı farklı seçimler için özel isimlendirme yapılır.\n\n\n\nİsim\n\\(c_{0}\\)\n\\(c_{1}\\)\np\nq\n\n\n\n\nDeğiştirilmiş (Modified) Euler\n0\n1\n1/2\n1/2\n\n\nHeun Yöntemi\n1/2\n1/2\n1\n1\n\n\nRalston Yöntemi\n1/3\n2/3\n3/4\n3/4\n\n\n\n\nTüm bu sınıflandırma 2. derece Runge-Kutta yöntemleri altındadır.\nBu yöntemler birbirlerinden üstün değildir.\nBirinci derece Runge-Kutta yöntemi olan Euler yönteminde ise \\(c_{0}=1\\) ve diğer terimler sıfırdır.\n\nGenelleştirmek adına değiştirilmiş Euler motdunu aşağıdaki gibi yazabiliriz.\n\\[\n\\vec{y}(x+h) = \\vec{y}(x) + \\vec{F}\\left[x+\\frac{h}{2},\\vec{y}+\\frac{h}{2}\\vec{F}(x,\\vec{y}) \\right]\n\\]\nRunge-Kutta metodları için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\vec{K}_{0} = h\\vec{F}(x,\\vec{y})\n\\]\n\nEn popüler Runge-Kutta diferansiyel denklem çözme yöntemi dördüncü dereceden Runge-Kutta yöntemidir.\n\n\n\n\nDördüncü Derece Runge-Kutta yöntemi için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\begin{align*}\n    \\vec{K}_{0} &= h\\vec{F}(x,\\vec{y})\\\\\n    \\vec{K}_{1} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{0}\\right)\\\\\n    \\vec{K}_{2} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{1}\\right)\\\\\n    \\vec{K}_{3} &= h\\vec{F}\\left(x+h,\\vec{y}+\\vec{K}_{2}\\right)\n\\end{align*}\n\\]\nSonuç olarak bir sonraki adım aşağıdaki gibi yazılır.\n\\[\n\\vec{y}(x+h)= \\vec{y}(x) + \\frac{1}{6}\\left(\\vec{K}_{0}+2\\vec{K}_{1}+2\\vec{K}_{2}+\\vec{K}_{3}\\right)\n\\]\nKatsayı tablosu oluşturalım.\n\n\n\n\n\n\n\n\n\n\\(K_{0}\\)\n\\(K_{1}\\)\n\\(K_{2}\\)\n\\(K_{3}\\)\n\n\n\n\n\\(hF(y,x)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{0}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{1}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+K_{2}, x+h\\right)\\)\n\n\n\nKatsayıları kullanarak bir sonraki adım hesaplanır.\n\\[\ny(x+h)= y(x) + \\frac{1}{6}(K_{0}+2K_{1}+2K_{2}+K_{3})\n\\]\nPython kodunu yazalım. add_coz_rk4_sistem adlı fonksiyon bilYonMod.py modülünde tanımlıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_rk4_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-yöntemleri",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-yöntemleri",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "",
    "text": "Euler yöntemi için Taylor serisini birinci dereceden türevli terimden kesmiştik. Eğer Taylor serisinde daha yüksek mertebelerden türevler kullanılırsa, bu yöntemlere Runge-Kutta yöntemleri adı verilir.\n\n\n\n\n\n\nDikkat\n\n\n\nYüksek mertebeden türevler kullanmak demek, yüksek mertebe diferansiyel denklem çözümü anlamına gelmez. Örneğin, birinci dereceden diferansiyel denklemi, Taylor serisinin üçüncü dereceden teriminden keserek çözebiliriz. Runge-Kutta yöntemleri, Euler yönteminin bir genelleştirilmesidir.\n\n\n\n\nAna denklemi yazalım.\n\\[\ny'(x)=f(y,x)\n\\]\nEuler yöntemini hatırlayalım. \\(y'(x)=f(y,x)\\) bağıntısını da kullanalım.\n\\[\ny(x+h)= y(x)+hy'(y,x) = y(x)+hf(y,x)\n\\]\nTaylor serisinin ikinci mertebesinden kesmeden önce en genel formülü yazalım. Bu formül Runge-Kutta yöntemlerinin genel formülüdür.\n\\[\ny(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hf(x+ph,y+qhF(y,x))\n\\]\nBurada \\(c_{0},c_{1},p,q\\) birer katsayıdır. Taylor serisine dönelim.\n\\[\n\\begin{align*}\ny(x+h) &= y(x) + y'(x)h + \\frac{1}{2}y''(x)h^{2}\\\\\n       &= y(x) + F(y,x)h + \\frac{1}{2}f'(y,x)h^{2}    \n\\end{align*}\n\\]\nBurada \\(f'(y,x)\\) aşağıdaki gibi yazılır.\n\\[\n\\begin{align*}\nf'(y,x)&= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}f \\\\\n       &= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}y'\n\\end{align*}\n\\]\nVektörize edilmiş \\(F\\) için ise,\n\\[\nF'(y,x)= \\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nşeklinde yazılır. Taylor açılımından elde ettiğimiz denklemde yerine koyarsak,\n\\[\ny(x+h)= y(x) + F(y,x)h + \\frac{h^{2}}{2}\\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nifadesini elde ederiz. Şimdi genelleştirilmiş formülü, yani \\(y(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hF(x+ph,y+qhF(y,x))\\) terimindeki \\(F(x+ph,y+qhF(y,x))\\) terimi açalım.\n\\[\nF(x+ph,y+qhF(y,x)) = F(y,x) + \\frac{\\partial F}{\\partial x}ph + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}qhF_{i}(y,x)\n\\]\n\nYukarıdaki açılımı genelleştirilmiş formülde yerine koyalım.\n\n\\[\ny(x+h) = y(x) + (c_{0}+c_{1})F(y,x)h+ c_{1}\\left[\\frac{\\partial F}{\\partial x}ph + qh \\sum_{i=1}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\\right]\n\\]\nBurada elde ettiğimiz formül ile Taylor serisinde elde ettiğimiz formülü karşılaştıralım. Eğer\n\\[\nc_{0}+c_{1}=1 \\quad \\text{ve} \\quad c_{1}p=c_{1}q=\\frac{1}{2}\n\\]\nolursa, iki formül de aynı olur. Buradaki \\(c_{0}, c_{1},q,p\\) parametreleri farklı farklı seçilebilir. Bazı farklı seçimler için özel isimlendirme yapılır.\n\n\n\nİsim\n\\(c_{0}\\)\n\\(c_{1}\\)\np\nq\n\n\n\n\nDeğiştirilmiş (Modified) Euler\n0\n1\n1/2\n1/2\n\n\nHeun Yöntemi\n1/2\n1/2\n1\n1\n\n\nRalston Yöntemi\n1/3\n2/3\n3/4\n3/4\n\n\n\n\nTüm bu sınıflandırma 2. derece Runge-Kutta yöntemleri altındadır.\nBu yöntemler birbirlerinden üstün değildir.\nBirinci derece Runge-Kutta yöntemi olan Euler yönteminde ise \\(c_{0}=1\\) ve diğer terimler sıfırdır.\n\nGenelleştirmek adına değiştirilmiş Euler motdunu aşağıdaki gibi yazabiliriz.\n\\[\n\\vec{y}(x+h) = \\vec{y}(x) + \\vec{F}\\left[x+\\frac{h}{2},\\vec{y}+\\frac{h}{2}\\vec{F}(x,\\vec{y}) \\right]\n\\]\nRunge-Kutta metodları için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\vec{K}_{0} = h\\vec{F}(x,\\vec{y})\n\\]\n\nEn popüler Runge-Kutta diferansiyel denklem çözme yöntemi dördüncü dereceden Runge-Kutta yöntemidir.\n\n\n\n\nDördüncü Derece Runge-Kutta yöntemi için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\begin{align*}\n    \\vec{K}_{0} &= h\\vec{F}(x,\\vec{y})\\\\\n    \\vec{K}_{1} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{0}\\right)\\\\\n    \\vec{K}_{2} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{1}\\right)\\\\\n    \\vec{K}_{3} &= h\\vec{F}\\left(x+h,\\vec{y}+\\vec{K}_{2}\\right)\n\\end{align*}\n\\]\nSonuç olarak bir sonraki adım aşağıdaki gibi yazılır.\n\\[\n\\vec{y}(x+h)= \\vec{y}(x) + \\frac{1}{6}\\left(\\vec{K}_{0}+2\\vec{K}_{1}+2\\vec{K}_{2}+\\vec{K}_{3}\\right)\n\\]\nKatsayı tablosu oluşturalım.\n\n\n\n\n\n\n\n\n\n\\(K_{0}\\)\n\\(K_{1}\\)\n\\(K_{2}\\)\n\\(K_{3}\\)\n\n\n\n\n\\(hF(y,x)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{0}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{1}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+K_{2}, x+h\\right)\\)\n\n\n\nKatsayıları kullanarak bir sonraki adım hesaplanır.\n\\[\ny(x+h)= y(x) + \\frac{1}{6}(K_{0}+2K_{1}+2K_{2}+K_{3})\n\\]\nPython kodunu yazalım. add_coz_rk4_sistem adlı fonksiyon bilYonMod.py modülünde tanımlıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_rk4_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-1",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBirbirine bağlı iki adet diferansiyel denklemi çözmek için Euler yöntemini, 4. Mertebe Runge-Kutta ve scipy.integrate.odeint yöntemlerini kullanınız. Toplamda 10 adım kullanın.\nDenklem sistemi aşağıdaki gibidir.\n\\[\n\\begin{align*}\n\\frac{d}{dx}y(v(x), x) &= v(x) \\\\\n\\frac{d}{dx}v(x) &= x\n\\end{align*}\n\\]\nAnalitik çözümü yazabiliriz. Önce \\(v(x)\\)’i çözelim.\n\\[\n\\frac{d}{dx}v(x) = x \\Rightarrow v(x) = \\frac{x^{2}}{2} + C\n\\]\nBaşlangıç koşulunu, \\(v(0)=0\\) koşulunu kullanarak \\(C\\) sabitini bulalım.\n\\[\nv(0) = 0 \\Rightarrow C = 0  \\Rightarrow v(x) = \\frac{x^{2}}{2}\n\\]\nŞimdi \\(y(x)\\)’i çözelim.\n\\[\n\\begin{align*}\n    \\frac{d}{dx}y(v(x), x) =& v(x) \\\\\n    y(x) =& \\int v(x)dx \\\\\n         =& \\int \\frac{x^{2}}{2}dx = \\frac{x^{3}}{6} + C\n\\end{align*}\n\\]\nBaşlangıç koşulunu, \\(y(0)=1\\) koşulunu kullanarak \\(C\\) sabitini bulalım.\n\\[\ny(0) = 1 \\Rightarrow C = 1 \\Rightarrow y(x) = \\frac{x^{3}}{6} + 1\n\\]\nAnalitik çözüm aşağıdaki gibi olur.\n\\[\ny(x)= \\frac{x^{3}}{6} + 1 \\quad \\text{ve} \\quad v(x) = \\frac{x^{2}}{2}\n\\]\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.integrate as spInt\n# Fonksiyon\ndef fonk_yVek_x(yVek, x):\n    dydx = yVek[1]\n    return np.array([dydx, x])\n# Başlangıç koşulları\ny0 = 1\nv0 = 0\nx0 = 0\nxSon = 10\nn = 10\n# Çöz, Euler\nxTumEuler, yTum_VekEuler = bym.add_coz_euler_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Çöz, 4. Mertebe Runge-Kutta\nxTumRK4, yTum_VekRK4 = bym.add_coz_rk4_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Çöz, scipy.integrate.odeint\nxTumScipy= np.linspace(x0, xSon, n)\nyTumScipy= spInt.odeint(fonk_yVek_x, np.array([y0, v0]), xTumScipy)\n# Analitik çözüm\nyAnalitik = xTumEuler**3/6 + 1\nvAnalitik = xTumEuler**2/2\n# Çiz\nfig, ax = plt.subplots(1, 2)\n# Sol grafik\nax[0].plot(xTumEuler, yTum_VekEuler[0], lw='5', label='y(x) Euler', color='red')\nax[0].plot(xTumRK4, yTum_VekRK4[0], lw='3', label='y(x) RK4', color='green')\nax[0].plot(xTumScipy, yTumScipy[:,0], lw='1', label='y(x) Scipy', color='blue')\nax[0].plot(xTumEuler, yAnalitik, label='y(x) Analitik', color='black', linestyle='--')\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\nax[0].legend()\n# Sağ grafik\nax[1].plot(xTumEuler, yTum_VekEuler[1], lw='5', label='v(x) Euler', color='blue')\nax[1].plot(xTumRK4, yTum_VekRK4[1], lw='3', label='v(x) RK4', color='green')\nax[1].plot(xTumScipy, yTumScipy[:,1], lw='1', label='v(x) Scipy', color='red')\nax[1].plot(xTumEuler, vAnalitik, label='v(x) Analitik', color='cyan', linestyle='--')\nax[1].set_xlabel('x')\nax[1].set_ylabel('v(x)')\nax[1].legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-2",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-2",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\nAşağıdaki diferansiyel denklem sistemini tüm bildiğiniz çözüm yöntemleri ile çözün  [1].\n\n\n\n\n\n\\[\n\\begin{align*}\nm_{1}\\ddot{x}_{1}+b_{1}\\dot{x}_{1}+ k_{1}(x_{1} - L_{1})-k_{2}(x_{2}-x_{1}-L_{2})=0 \\\\\nm_{2}\\ddot{x}_{2}+b_{2}\\dot{x}_{2}+ k_{2}(x_{2}- x_{1}-L_{2})=0\n\\end{align*}\n\\]\n\n\\(m_{1}= 1\\) kg, \\(m_{2}=1.5\\) kg: Cisimlerin kütlesi\n\\(k_{1}= 8\\) N/m, \\(k_{2}=40.0\\) N/m: Yayların esneklik katsayısı\n\\(b_{1}= 0.8\\) Ns/m, \\(b_{2}=0.5\\) Ns/m: Sürtünme katsayısı\n\\(L_{1}= 0.5\\) m, \\(L_{2}=1.0\\) m: Yayların kuvvet yokkenki uzunluğu\n\nBaşlangıç koşulları:\n\n\\(x_{1}=0.5\\) m\n\\(v_{1}=0.0\\) m/s\n\\(x_{2}=2.25\\) m\n\\(v_{2}=0.0\\) m/s\n\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.integrate as spInt\n# Global değişkenler\nm1 = 1.0\nm2 = 1.5\nk1 = 8.0\nk2 = 40.0\nL1 = 0.5\nL2 = 1.0\nb1 = 0.8\nb2 = 0.5\n# Fonksiyonlar\ndef fonkVek(yVek, t):\n    x1= yVek[0]\n    v1= yVek[1]\n    x2= yVek[2]\n    v2= yVek[3]\n    return np.array([v1\\\n        , (-b1 * v1 - k1 * (x1 - L1) + k2 * (x2 - x1 - L2)) / m1 \\\n        , v2 \\\n        , (-b2 * v2 - k2 * (x2 - x1 - L2)) / m2])\n# Başlangıç koşulları\nyVek0= np.array([0.5, 0.0, 2.25, 0.0])\nt0=0\ntSon=50\nn=100\n# Çöz, Euler\ntTumEuler, yTum_VekEuler = bym.add_coz_euler_sistem(fonkVek, t0, tSon, yVek0, n)\n# Çöz, 4. Mertebe Runge-Kutta\ntTumRK4, yTum_VekRK4 = bym.add_coz_rk4_sistem(fonkVek, t0, tSon, yVek0, n)\n# Çöz, scipy.integrate.odeint\ntTumScipy= np.linspace(t0, tSon, n)\nyTumScipy= spInt.odeint(fonkVek, yVek0, tTumScipy)\n# Çiz\nfig, ax = plt.subplots(2, 2)\n# Sol üst grafik\nax[0,0].plot(tTumEuler, yTum_VekEuler[0], lw='5', label='x1(t) Euler', color='red')\nax[0,0].plot(tTumRK4, yTum_VekRK4[0], lw='3', label='x1(t) RK4', color='green')\nax[0,0].plot(tTumScipy, yTumScipy[:,0], lw='1', label='x1(t) Scipy', color='blue')\nax[0,0].set_xlabel('t')\nax[0,0].set_ylabel('x1(t)')\nax[0,0].legend()\n# Sağ üst grafik\nax[0,1].plot(tTumEuler, yTum_VekEuler[1], lw='5', label='v1(t) Euler', color='blue')\nax[0,1].plot(tTumRK4, yTum_VekRK4[1], lw='3', label='v1(t) RK4', color='green')\nax[0,1].plot(tTumScipy, yTumScipy[:,1], lw='1', label='v1(t) Scipy', color='red')\nax[0,1].set_xlabel('t')\nax[0,1].set_ylabel('v1(t)')\nax[0,1].legend()\n# Sol alt grafik\nax[1,0].plot(tTumEuler, yTum_VekEuler[2], lw='5', label='x2(t) Euler', color='red')\nax[1,0].plot(tTumRK4, yTum_VekRK4[2], lw='3', label='x2(t) RK4', color='green')\nax[1,0].plot(tTumScipy, yTumScipy[:,2], lw='1', label='x2(t) Scipy', color='blue')\nax[1,0].set_xlabel('t')\nax[1,0].set_ylabel('x2(t)')\nax[1,0].legend()\n# Sağ alt grafik\nax[1,1].plot(tTumEuler, yTum_VekEuler[3], lw='5', label='v2(t) Euler', color='blue')\nax[1,1].plot(tTumRK4, yTum_VekRK4[3], lw='3', label='v2(t) RK4', color='green')\nax[1,1].plot(tTumScipy, yTumScipy[:,3], lw='1', label='v2(t) Scipy', color='red')\nax[1,1].set_xlabel('t')\nax[1,1].set_ylabel('v2(t)')\nax[1,1].legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-fehlberg-rk45-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-fehlberg-rk45-yöntemi",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Runge-Kutta-Fehlberg (RK45) Yöntemi",
    "text": "Runge-Kutta-Fehlberg (RK45) Yöntemi\n\nRunge-Kutta-Fehlberg (RK45) yöntemi, dördüncü ve beşinci mertebe Runge-Kutta yöntemi kullanarak çözüm elde eder.\nRK45, değişken adım aralığı (adaptive step size) kullanır.\nRK45’in girdilerinden (input) biri rölatif (relative) hata değeridir. RK4 ile elde edilen sonuç ile RK5 ile elde edilen sonuç arasındaki fark rölatif hatadan büyükse adım aralığı küçültülür ve o adım tekrar hesaplanır.\nBunun gibi metotlara değişken (adaptive) adım aralığı yöntemleri denir.\nRunge-Kutta metotları açık (explicit) yöntemlerdir.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#scipy-paketleri-hakkında",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#scipy-paketleri-hakkında",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Scipy Paketleri Hakkında",
    "text": "Scipy Paketleri Hakkında\n\nScipy içerisinde başlangıç değer problemi çözümleri için birçok fonksiyon var  [2].\nEski api olarak odeint hala kullanılabiliyor ancak scipy’ın gelecekteki versiyonlarında çıkarılma ihtimali çok yüksek.\nodeint fonksiyonunda çağırılan \\(f\\) fonksiyonunda \\(f(y,t)\\) olmak zorunda. solve_ivp’de ise bu durum tam tersi. Bu farklılığı tfirst=True parametresi ile değiştirebilirsiniz - 1.1.0 versiyonundan itibaren.\nodeint ile ilgili bilgi için  [3] referansına bakabilirsiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#problemler",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAşağıdaki matris denklemlerini yazdığımız rk4 fonksiyonu ile çözün.\n\\[\n\\begin{align*}\n\\frac{d}{dt}\n\\begin{bmatrix}\n\\rho_{11}(t) & \\rho_{12}(t) \\\\\n\\rho_{21}(t) & \\rho_{22}(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\rho_{11}(t) & -2\\rho_{12}(t) \\\\\n-3\\rho_{21}(t) & -4\\rho_{22}(t)\n\\end{bmatrix}\n\\end{align*}\n\\]\n\n\nProblem 2\nscipy.integrate.solve_ivp fonksiyonunu kullanarak aşağıdaki denklemi çözün. Çözüm yöntemi olarak method='RK45' ve method='LSODA' kullanın.\n\\[\n\\frac{d}{dx}y(x) = \\sin(5x)\n\\]\nBaşlangıç koşulu: \\(y(-3)=4.5\\). Çözümü -3 ile 3 arasında çizdirin.\nAynı denklemi sağ taraf \\(\\sin(15x)\\) ve \\(\\sin(25x)\\) olacak şekilde çözün.\n\n\nProblem 3\nSönümlü harmonik salınıcının Lagranjiyen’i aşağıdaki gibidir.\n\\[\nL(x,v) = \\frac{1}{2}mv^{2} - \\frac{1}{2}kx^2\n\\]\nBurada \\(v\\) hız olup konumun \\(x\\) zamana göre birinci türevine eşittir. Lagrange hareket denklemleri aşağıdaki gibi yazılır.\n\\[\n    \\left(\\frac{d}{dt}\\frac{\\partial L}{\\partial v} \\right) - \\frac{\\partial L}{\\partial x} = \\frac{\\partial F^{dis}}{\\partial v}\n\\]\nYukarıda verilen formülden diferansiyel denklem setini oluşturun. Burada \\(F^{dis}=-\\frac{1}{2}bv^{2}\\) sönümleyici kuvvettir. \\(t=0-50\\) arasındaki değerler için ve \\(n=1000\\) adımda, - Runge-Kutta-4 (veya 5(4) mertebe için Runge-Kutta methodu) yöntemi ile çözün. - x ile t’nin oluşturduğu grafiği çizdirin.\nBaşlangıç koşulları ve sabitler aşağıdaki gibidir.\n\n\\(m=1\\) kg\n\\(k=1\\) N/m\n\\(b=0.1\\) Ns/m\n\\(x(t=0)=1\\) m\n\\(v(t=0)=0\\) m/s\n\n\n\nProblem 4\nAşağıdaki diferansiyel denklemi Runge Kutta 4(5) yöntemini kullanarak \\(N=100\\) adımda çözün. Analitik sonuçla karşılaştırın.\n\\[\ny''(t) = t^{3}+t+5, \\quad y(0)=1, \\quad y'(0)=5\n\\]\n\n\nProblem 5\nDüşey düzlemde \\(l=1\\) m uzunluğunda bir ipin ucunda birim kütleli bir cisim salınsın. Bu cisim denge noktasından \\(\\theta(t=0s)=\\pi/9\\) rad açı ile harekete başlıyor. \\(g=9.81\\) m/\\(s^{2}\\). Cisim bırakıldığı anda açısal hızı \\(\\omega(t=0s)=0\\) rad/s. Bu cismin hareket denklemini \\(t=(0,10)\\) arasında\n\nEuler yöntemiyle çözün.\nRK4 (veya RK45 veya LSODA) yöntemiyle çözün.\nAnalitik çözümü de dikkate alın ve tüm çözümleri üst üste bindirerek çizdirin.\n\nEuler metodunda adım sayısını \\(n=10000\\) alın.\n\\[\n\\frac{d^{2}\\theta}{dt^{2}}=-\\frac{g}{l}\\sin \\theta\n\\]\nAnalitik çözüm: \\(\\theta(t) = A\\cos(t\\sqrt{g/l})+B\\sin(t\\sqrt{g/l})\\)",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi.html",
    "href": "icerik/konular/veri-analizi.html",
    "title": "Veri Analizi",
    "section": "",
    "text": "Fizikte ve diğer branşlarda çok büyük veri kümeleriyle çalışmak gerekebilir. Bu veri istatistiksel bir anlam çıkarmak için kullanılabilir veya bir analiz sonucunda ortaya çıkmış olabilir.\nBu bölümde veri analizi için kullanılan temel yöntemlerden bazılarına değineceğiz.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi.html#veri-analizi",
    "href": "icerik/konular/veri-analizi.html#veri-analizi",
    "title": "Veri Analizi",
    "section": "",
    "text": "Fizikte ve diğer branşlarda çok büyük veri kümeleriyle çalışmak gerekebilir. Bu veri istatistiksel bir anlam çıkarmak için kullanılabilir veya bir analiz sonucunda ortaya çıkmış olabilir.\nBu bölümde veri analizi için kullanılan temel yöntemlerden bazılarına değineceğiz.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/hipotez-testi.html",
    "href": "icerik/konular/istatistik/hipotez-testi.html",
    "title": "Hipotez Testi",
    "section": "",
    "text": "Bir iddianın doğruluğunu test etmek için kullanılan istatistiksel bir yöntemdir.\nBir hipotezi test ederken önce boş (null) hipotez ve alternatif hipotez olmak üzere iki hipotez kurulur.\n\nBoş hipotez (\\(H_{0}\\)): İddia edilen durumun doğru olmadığını savunan hipotezdir.\nAlternatif hipotez (\\(H_{1}\\)): İddia edilen durumun doğru olduğunu savunan hipotezdir.\n\nBoş hipotez veya alternatif hipotezden biri reddedilir.\nHipotezler kurulduktan sonra veri toplanır.\nVeri toplandıktan sonra veriye uygun bir test istatistiği seçilir ve hesaplanır.\nSonraki adım olarak test istatistiği ile p-değeri hesaplanır.\nSon olarak p-değeri, önem düzeyi (significant level) (\\(\\alpha\\), genelde %5 veya %1) ile karşılaştırılır ve karşılaştırma sonucunda boş hipotez reddedilir veya reddedilmez.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Hipotez Testi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/hipotez-testi.html#alıştırma-1",
    "href": "icerik/konular/istatistik/hipotez-testi.html#alıştırma-1",
    "title": "Hipotez Testi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBir araştırmacı, bir ilaç tedavisinin etkililiğini test etmek için bir hipotez testi yapabilir. Null hipotez, “bu ilaç tedavisi, hastalığın iyileşme oranını artırmaz” şeklinde olabilir. Test istatistiği hesaplandıktan sonra, önem düzeyi (alfa) belirlenir ve test istatistiği, alfa ile karşılaştırılır. Eğer elde edilen p-değeri, alfa’dan küçükse, null hipotez reddedilir ve alternatif hipotez kabul edilir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Hipotez Testi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/hipotez-testi.html#hipotez-testinin-aşamaları",
    "href": "icerik/konular/istatistik/hipotez-testi.html#hipotez-testinin-aşamaları",
    "title": "Hipotez Testi",
    "section": "Hipotez Testinin Aşamaları",
    "text": "Hipotez Testinin Aşamaları\n\nBoş ve alternatif hipotezlerin formüle edilmesi,\nTest istatistiğinin seçilmesi. Boş hipotez altında dağılımı bilinen bir test istatistiği seçilir (kesin veya yaklaşık),\nVeri toplanması\nVeriye uygun test istatistiğinin hesaplanması ve boş hipotez altında p-değeri hesaplanması,\np-değeri ve önem düzeyi karşılaştırması ve boş hipotezin reddedilip reddedilmeyeceğinin belirlenmesi.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Hipotez Testi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/hipotez-testi.html#alıştırma-2",
    "href": "icerik/konular/istatistik/hipotez-testi.html#alıştırma-2",
    "title": "Hipotez Testi",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\n\nBoş hipotez: Ortalama değer \\(\\mu_{0} = 1\\)’dir.\n\\(X\\) örneklemi verilsin ve bu örneklemdeki veri boş hipotez altında test edilsin.\nFarz edelim ki elimizdeki veri \\(X\\) örneklemi normal dağılıma sahip, \\(\\mu=0.8\\) ve \\(\\sigma=0.5\\) olan 100 adet veriye sahip olsun.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n# Bilinen değerler\nmu0, mu, sigma = 1.0, 0.8, 0.5\n# Test edeceğimiz veriyi oluşturalım.\nX = stats.norm(mu, sigma)\nn = 100\nX_samples = X.rvs(n)\n\n\nTest istatistiğini hesap edelim. Eğer standart sapma \\(\\sigma\\) biliniyorsa z istatistiği kullanılır. Bu da şu şekilde hesaplanır:\n\n\\[\nz = \\frac{\\bar{X}-\\mu_{0}}{\\sigma/\\sqrt{n}}\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n# Bilinen değerler\nmu0, mu, sigma = 1.0, 0.8, 0.5\n# Test edeceğimiz veriyi oluşturalım.\nX = stats.norm(mu, sigma)\n# Z istatistiği\nz= (X_samples.mean() - mu0) / (sigma / np.sqrt(n))\nprint(f\"z değeri: {z}\")\n\nz değeri: -3.5097281483476106\n\n\n\nEğer standart sapma \\(\\sigma\\) bilinmiyorsa t istatistiği kullanılır. Bu da şu şekilde hesaplanır:\n\n\\[t = \\frac{\\bar{X}-\\mu_{0}}{s/\\sqrt{n}}\\]\n\nBurada \\(s\\) örneklem standart sapmasıdır ve şu şekilde hesaplanır:\n\n\\[s = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n}(X_{i}-\\bar{X})^{2}}\\]\n\nEğer t-istatiği kullanılırsa, normal dağılım yerine öğrencinin t dağılımı kullanılır.\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n# Bilinen değerler\nmu0, mu, sigma = 1.0, 0.8, 0.5\n# Test edeceğimiz veriyi oluşturalım.\nX = stats.norm(mu, sigma)\nt = (X_samples.mean() - mu0) / (X_samples.std(ddof=1) / np.sqrt(n))\nprint(f\"t değeri: {t}\")\n\nt değeri: -3.178228364416206",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Hipotez Testi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/hipotez-testi.html#kaynaklar",
    "href": "icerik/konular/istatistik/hipotez-testi.html#kaynaklar",
    "title": "Hipotez Testi",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Python: Scientific Computing and Data, Science Applications with Numpy, SciPy and Matplotlib, Robert Johansson, Apress, İkinci Basım, 2019",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Hipotez Testi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html",
    "title": "Dağılımlarin Modellenmesi",
    "section": "",
    "text": "Bu zamana kadar elde ettiğimiz dağılımlar (normal ve düzgün (uniform)) empirik yani gözlem verilerine dayalıydı.\nŞimdi analitik dağılımlardan bahsedeceğiz. Analitik dağılımlar bir formül ile karakterize edildiği için kesikli değil sürekli olur.\nPMF (Olasılık kütle fonksiyonu) kesikli değerler üzerinde tanımlı olduğu için yeni bir tanım yani PDF (olasılık yoğunluk fonksiyonu) tanımı yapacağız.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#dağılımların-modellenmesi",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#dağılımların-modellenmesi",
    "title": "Dağılımlarin Modellenmesi",
    "section": "",
    "text": "Bu zamana kadar elde ettiğimiz dağılımlar (normal ve düzgün (uniform)) empirik yani gözlem verilerine dayalıydı.\nŞimdi analitik dağılımlardan bahsedeceğiz. Analitik dağılımlar bir formül ile karakterize edildiği için kesikli değil sürekli olur.\nPMF (Olasılık kütle fonksiyonu) kesikli değerler üzerinde tanımlı olduğu için yeni bir tanım yani PDF (olasılık yoğunluk fonksiyonu) tanımı yapacağız.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#olasılık-yoğunluk-fonksiyonu-pdf-probability-density-function",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#olasılık-yoğunluk-fonksiyonu-pdf-probability-density-function",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Olasılık Yoğunluk Fonksiyonu, PDF (Probability Density Function)",
    "text": "Olasılık Yoğunluk Fonksiyonu, PDF (Probability Density Function)\nTıpkı PMF gibi PDF de rastgele bir değişkeni (örnek uzayında) alıp olasılıklardan oluşan tanım kümesine götüren bir fonksiyondur.\nPDF, bir sürekli değişkenin değerlerinin olasılıklarını tanımlar.\n\nPDF’nin Özellikleri\n\n(normalizasyon) PDF’de tıpkı PMF gibi olasılık fonksiyonu olduğu için için değerlerinin toplamı 1 olmak zorundadır.\n\n\\[\n\\int_{-\\infty}^{\\infty} PDF(x) dx = 1\n\\]\n\n(pozitiflik.) PDF’nin değeri her zaman pozitif olmak zorundadır. \\(PDF(x) \\geq 0\\)\n(Değerlerin Olasılık Yoğuluğu) PDF’in değeri 1’e ne kadar yakınsa o kadar yüksek olasılık değerine sahiptir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#alıştırma-1",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#alıştırma-1",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\n\\(PDF(x=2) = 0.5\\) ise \\(x\\) rastgele değişkeninin olasılığı \\(0.5\\)’dir. \\(PDF(x=3)=0.2\\) ise \\(3\\) rastgele değişkeninin olasılığı \\(0.2\\)’dir.\n\n(PDF ile PMF arasındaki ilişki) PDF ile PMF arasındaki matematiksel ilişki aşağıdaki gibidir.\n\n\\[\nPDF(x) = \\frac{PMF(x)}{\\Delta x}\n\\]\nBurada \\(\\Delta x\\) birim uzunlukta \\(x\\)’in alabileceği değerlerin sayısıdır.\n\n(PDF ile CDF arasındaki ilişki) PDF ile CDF arasındaki türev/integral ilişkisi vardır.\n\n\\[\nCDF(x) = \\int_{-\\infty}^{x} PDF(t) dt\n\\]\nveya\n\\[\nPDF(x) = \\frac{d}{dx} CDF(x)\n\\]\nCDF fonksiyonunun \\(x\\) noktasındaki türevi ne kadar yüksek ise \\(x\\)’in o bölgede olma olasılığı o kadar yüksektir ki bu da PMF(x)’in o bölgede yüksek değerde olması demektir.\n\n(Beklenen Değer veya PDF’in Ortalaması (Mean)) Bir dağılımın ortalama değeri veya beklenen değeri \\(E[x]\\) veya \\(&lt;x&gt;\\) aşağıdaki gibi hesaplanır.\n\n\\[E[x] \\equiv \\mu \\equiv &lt;x&gt; = \\int_{-\\infty}^{\\infty} x ~ PDF(x) dx\\]\n\n(Varyans) Bir dağılımın varyansı \\(\\sigma^2\\) aşağıdaki gibi hesaplanır.\n\n\\[\\sigma^2 = \\int_{-\\infty}^{\\infty} (x - E[x])^2 PDF(x) dx\\]\n\nVaryans Üzerine Not\nVaryansı başka bir şekilde de hesaplayabiliriz.\n\\[\n\\sigma^2 = E[(x-E[x])^{2}] = \\int_{-\\infty}^{\\infty} (x - E[x])^2 PDF(x) dx\n\\]\n\\[\n\\begin{align}\n    E[(x-E[x])^{2}] =& E[x^2 - 2 x E[x] + E[x]^2] \\\\\n    =& E[x^2] - E[2 x E[x]] + E[E[x]^2] \\\\\n    =& E[x^2] - 2 E[x] E[x] + E[x]^2 \\\\\n    =& E[x^2] - E[x]^2\n\\end{align}\n\\]\nBurada kullandığımız özellikler\n\n\\(E[x+y] = E[x] + E[y]\\)\n\\(E[c x] = c E[x]\\)\n\\(E[x E[x]] = E[x]E[x]\\) (\\(E[x]\\) ’in bir sayı olduğunu unutmayın.)\n\\(E[E[x]^2] = E[x]^2\\) (\\(E[c]= c\\), \\(c\\) sabit bir sayıdır.)\n\nBu durumda varyans şu şekilde hesaplanabilir.\n\\[\n\\sigma^2 \\equiv Var[x] = E[x^2] - E[x]^2\n\\]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#eksponansiyel-dağılım",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#eksponansiyel-dağılım",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Eksponansiyel Dağılım",
    "text": "Eksponansiyel Dağılım\nEksponansiyel dağılımı veren PDF formülü aşağıdaki gibidir:\n\\[PDF(x) |_{exp} = \\lambda e^{-\\lambda x}\\]\nBurada \\(\\lambda\\) parametresi pozitif bir reel sayıdır ve dağılımın karakteristiğini belirler. Bir diğer adı da ölçü (rate) parametresidir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#normal-dağılım",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#normal-dağılım",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Normal Dağılım",
    "text": "Normal Dağılım\n\nBir diğer ismi Gaussyen dağılımdır.\nNormal dağılım \\(\\mu\\) ve \\(\\sigma\\) parametreleri ile tanımlanır.\n\n\\(\\mu\\) ortalama değerdir.\n\\(\\sigma\\) standart sapmadır.\n\\(\\mu=0\\) ve \\(\\sigma=1\\) ise standart normal dağılım denir.\n\n\nNormal dağılımın PDF formülü aşağıdaki gibidir:\n\\[PDF(x) |_{normal} = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp{\\left[-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\right]}\\]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#poisson-dağılımı",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#poisson-dağılımı",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Poisson Dağılımı",
    "text": "Poisson Dağılımı\nPoisson dağılımı veren PDF formülü aşağıdaki gibidir:\n\\[PDF(x) |_{poisson} = \\frac{\\lambda^{x} e^{-\\lambda}}{x!}\\]\nBurada \\(\\lambda\\) parametresi pozitif bir reel sayıdır ve dağılımın karakteristiğini belirler. Bir diğer adı da ölçü (rate) parametresidir.\nBurada \\(x\\) bir tamsayıdır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#maxwell-boltzmann-dağılımı",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#maxwell-boltzmann-dağılımı",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Maxwell-Boltzmann Dağılımı",
    "text": "Maxwell-Boltzmann Dağılımı\nMaxwell-Boltzmann dağılımı veren PDF formülü aşağıdaki gibidir:\n\\[PDF(x) |_{maxwell} = \\sqrt{\\frac{2}{\\pi}} \\frac{x^{2}}{a^{3}} e^{-\\frac{x^{2}}{2a^{2}}}\\]\nBurada \\(a\\) parametresi pozitif bir reel sayıdır ve dağılımın karakteristiğini belirler.\nFizikten bildiğimiz Maxwell Boltzman dağılımı aşağıdaki gibidir:\n\\[ n_{i}= \\frac{1}{e^{\\frac{E_{i}-\\mu}{kT}}} \\]\n\nBurada \\(E\\) enerji, \\(\\mu\\) kimyasal potansiyel, \\(k\\) Boltzman sabiti, \\(n_{i}\\) \\(E_{i}\\) enerjisine sahip parçacıkların sayısı ve \\(T\\) sıcaklıktır.\nBu dağılım normalize değildir.\n\nBir diğer Maxwell Boltzman dağılımı ise ayırt edilemez parçacıkların hız dağılımıdır. 3 Boyutlu Maxwell Boltzman hız dağılımı aşağıdaki gibidir:\n\\[ f(v) = \\left(\\frac{m}{2\\pi k T}\\right)^{3/2} 4\\pi v^{2} e^{-\\frac{mv^{2}}{2kT}} \\]\n\nBurada \\(m\\) parçacığın kütlesi, \\(v\\) parçacığın hızı, \\(k\\) Boltzman sabiti ve \\(T\\) sıcaklıktır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#bose-einstein-dağılımı",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#bose-einstein-dağılımı",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Bose-Einstein Dağılımı",
    "text": "Bose-Einstein Dağılımı\nBose-Einstein dağılımı veren PDF formülü aşağıdaki gibidir:\n\\[PDF(E) |_{bose-einstein} = \\frac{1}{e^{\\frac{E-\\mu}{kT}}-1}\\]\n\n\\(\\mu\\) kimyasal potansiyeldir. Değeri \\(0\\) ile \\(1\\) arasında değişir.\nBurada \\(k\\) Boltzmann sabitidir. Değeri \\(8.617 \\times 10^{-5}\\) eV/K’dır.\n\\(T\\) sıcaklıktır. Birimi Kelvin’dir.\n\\(E\\) enerji seviyesidir. Birimi eV’dir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#fermi-dirac-dağılımı",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#fermi-dirac-dağılımı",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Fermi-Dirac Dağılımı",
    "text": "Fermi-Dirac Dağılımı\nFermi-Dirac dağılımı veren PDF formülü aşağıdaki gibidir:\n\\[PDF(E) |_{fermi-dirac} = \\frac{1}{e^{(E-\\mu)/kT} + 1}\\]\n\nBurada \\(\\mu\\) kimyasal potansiyeldir. Birimi Joule’dur.\n\\(k\\) Boltzmann sabitidir ve değeri \\(1.380649 \\times 10^{-23} J/K\\)’dır.\n\\(T\\) ise sıcaklıktır. Birimi Kelvin’dir.\n\\(E\\) enerji seviyesidir. Birimi eV’dir.\nBu dağılım sadece \\(T \\geq 0\\) için tanımlıdır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#diğer-dağılımlar",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#diğer-dağılımlar",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Diğer Dağılımlar",
    "text": "Diğer Dağılımlar\n\nUniform Dağılım\n\nUniform dağılım \\(a\\) ve \\(b\\) parametreleri ile tanımlanır.\n\n\\(a\\) alt sınır değeridir.\n\\(b\\) üst sınır değeridir.\n\n\nUniform dağılımın PDF formülü aşağıdaki gibidir:\n\\[PDF(x) |_{uniform} = \\frac{1}{b-a}\\]\n\n\nBinom Dağılım\n\nBinom dağılımı \\(n\\) ve \\(p\\) parametreleri ile tanımlanır.\n\n\\(n\\) deneme sayısıdır.\n\\(p\\) başarı olasılığıdır.\n\n\nBinom dağılımın PMF formülü aşağıdaki gibidir:\n\\[PMF(x) |_{binom} = \\binom{n}{x} p^{x} (1-p)^{n-x}\\]\n\n\nGamma Dağılım\n\nGamma dağılımı \\(\\alpha\\) ve \\(\\beta\\) parametreleri ile tanımlanır.\n\n\\(\\alpha\\) şekil parametresidir.\n\\(\\beta\\) ölçü (rate) parametresidir.\n\n\nGamma dağılımın PDF formülü aşağıdaki gibidir:\n\\[PDF(x) |_{gamma} = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} x^{\\alpha-1} e^{-\\beta x}\\]\n\n\nÖğrencinin t Dağılımı (t-dağılımı) (Student’s t-distribution)\n\nÖğrencinin t fonksiyonu, normal dağılımın standart sapmasının bilinmediği durumlarda kullanılır.\nÖrneklem büyüklüğü küçük olduğunda veya popülasyon normal dağılımdan sapma gösterdiği durumlarda kullanılır.\nt-distribution, hipotez testleri ve güven aralıklarının hesaplanmasında yaygın olarak kullanılır\nPDF fonksiyonu aşağıdaki gibidir:\n\n\\[ f(x, \\nu) = \\frac{\\Gamma(\\frac{\\nu+1}{2})}{\\sqrt{\\nu\\pi}\\Gamma(\\frac{\\nu}{2})} \\left(1+\\frac{x^2}{\\nu}\\right)^{-\\frac{\\nu+1}{2}} \\]\n\n\nChi-kare Dağılımı (Chi-square Distribution)\n\nHipotez testleri ve istatistiksel çıkarımlar için kullanılan bir olasılık dağılımıdır.\nChi-kare dağılımı, normal dağılım verilerinin veya bir örneklemin varyansının test edilmesinde kullanılır.\nPDF fonksiyonu aşağıdaki gibidir:\n\n\\[ f(x, k) = \\frac{1}{2^{\\frac{k}{2}}\\Gamma(\\frac{k}{2})} x^{\\frac{k}{2}-1} e^{-\\frac{x}{2}} \\]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#teorik-dağılımları-modelleri-neden-kullanırız",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#teorik-dağılımları-modelleri-neden-kullanırız",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Teorik Dağılımları (Modelleri) Neden Kullanırız?",
    "text": "Teorik Dağılımları (Modelleri) Neden Kullanırız?\nVeri biliminde veri analizi yaparken veri setindeki verilerin dağılımının şeklinden birçok bilgi çıkarabiliriz. Bunun iki örneği aşağıdaki gibidir.\n\nParçacıkların Hız Dağılımı\nKlasik, ideal Gaz parçacıklarının hız dağılımının simülasyonunu aşağıdaki github reposunda bulabilirsiniz:\nhttps://github.com/rafael-fuente/Ideal-Gas-Simulation-To-Verify-Maxwell-Boltzmann-distribution\n\n\nNötrinonun Keşfi\n1900’lerin başında Curie, beta bozunumundan çıkan elektronların enerjisine baktı. Bu enerjinin bir dağılım değil belli bir enerjide olması gerekiyordu. Bunun sebebini aşağıdaki diyagramdan anlayabiliriz.\n\\[\n(A,Z) \\rightarrow (A,Z+1) + e^{-}\n\\]\nBurada, çekirdek içerisinde bir adet nötron bir adet protona dönüşmektedir. Bu sırada açığa çıkan enerjiyi de sadece elektronun taşıması gerekir. Fakat yapılan spektrum (açığa çıkan elektronun hangi enerjide olduğunun grafiği) analizlerinde elektronun Fermi-Dirac dağılımında olduğu bulunuyordu. Bunun iki sebebi olabilirdi:\n\nEnerji korunmuyordu.\nBaşka bir parçacık daha vardı.\n\nEnrico Fermi 1934 yılında bu sorunu çözdü. Enerji korunuyordu. Fakat başka bir parçacık daha vardı ve bu parçacığa nötrino adını verdi. Nötrinolar yük korunumundan dolayı yüksüz ve açısal momentum korunumundan dolayı da spin 1/2 yani fermion olmalıydı.\n\\[\n(A,Z) \\rightarrow (A,Z+1) + e^{-} + \\bar{\\nu_{e}}\n\\]\n1956 yılında Amerikan bir ekip (Clyde Cowan, Frederick Reines, Francis B. ve diğerleri) açığa çıkan nötrinoyu deneysel olarak buldu ve 1995 yılında Nobel Fizik Ödülü’nü kazandılar.\nElektronun Fermi-Dirac dağılımına bakarak cismin kütle ve sıcaklığı hakkında tahminde bulunabiliriz.\n\n\nBose-Einstein Yoğunlaşması\nBose-Einstein dağılımının grafiğine tekrar bakalım. Bu grafikte üzerine yorum yapılacak iki nokta var.\n\nParçacıkların hepsi, sıcakları düştükçe belli bir enerjide bulunma olasılıkları artıyor. Bu duruma Bose-Einstein yoğuşması (Bose–Einstein condensate) adı verilir.\nTeorik olarak negatif sıcaklıklar da olabilir. Negatif sıcaklığa, pozitif enerjili parçacıkların gelebilmesi için sonsuz miktarda enerjiye ihtiyaç vardır.\n\nBozonların (spin tam sayı) uyduğu Bose-Einstein dağılımına bakarak cismin kütle ve sıcaklığı hakkında tahminde bulunabiliriz.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#problemler",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#problemler",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nHeisenberg belirsizlik ilkesi aşağıdaki gibi verilir.\n\\[\\sigma_{x} \\sigma_{p} \\geq \\frac{\\hbar}{2}\\]\nBurada \\(\\sigma_{x}\\), x’teki belirsizliği yani standart sapmayı verir. Bu eşitliği beklenen değerler cinsinden matematiksel olarak yazın.\n\n\nProblem 2\nÖğrendiğiniz tüm dağılımları bir fonksiyon olarak yazın.\n\nEksponansiyel dağılım için \\(\\lambda=0.1,1,2\\) alın ve grafiğini çizdirin.\nNormal dağılım için \\((\\mu,\\sigma)= (0,1),(0,2), (0,3)\\) alın ve grafiğini çizdirin. Aynı şekilde \\((\\mu,\\sigma)= (-2,1),(0,1), (2,1)\\) alın ve grafiğini çizdirin.\nPoisson dağılımı için \\(\\lambda=0.1,1,2\\) alın ve grafiğini çizdirin.\nMaxwell-Boltzman dağılımı için \\(a=1,2,5\\) alın ve grafiğini çizdirin. 3 Boyutlu Maxwell-Boltzman hız dağılımı formülünü kullanarak 1Mol He, Ne ve Ar atomlarının hız dağılımını çizdirin.\nBose-Einstein dağılım için \\((\\mu [eV], T [K]) = (0,5), (0,100), (0,273)\\) alın ve grafiğini çizdirin. Ayrı bir grafikte \\((\\mu [eV], T [K]) = (0,273), (0.01,273), (0.05,273)\\) alın ve çizdirin.\nFermi-Dirac dağılımı için \\((\\mu [eV], T [K]) = (0.5,5), (0.5,100), (0.5,273)\\) alın ve grafiğini çizdirin. Ayrı bir grafikte \\((\\mu [eV], T [K]) = (0.5,273), (0.55,273), (0.85,273)\\) alın ve çizdirin.\n\n\n\nProblem 3\n\nAşağıdaki sorularda eksponansiyel dağılımı \\(\\lambda=2\\) için, normal dağılımı \\((\\mu,\\sigma)= (0,1)\\) için hesaplayın.\nDağılımların hem formülünü kullanarak hem de scipy.stats kütüphanesini kullanarak yaratın. \\(x=1\\) ile \\(x=100\\) arasında 1000 nokta için hesaplayın.\n\n\nNormal dağılımların ortalama değerini, varyansını, standart sapmasını hesaplayın ve ekrana yazdırın.\nNormal ve eksponansiyel dağılımların CDF fonksiyonlarını teorik olarak hesaplayın. Normal dağılım için integral hali ile bırakın. İntegral almak için scipy.integrate.quad fonksiyonunu kullanabilirsiniz.\nNormal ve eksponansiyel dağılımların PDF fonksiyonunu ve aynı grafikte çizdirin.\nNormal dağılımda \\(\\mu=0\\) için \\(\\sigma=0.25,0.81,1,9\\) olan 4 farklı dağılımı aynı grafikte çizdirin.\nNormal dağılımda \\(\\sigma=3\\) için \\(\\sigma=−5,-2.5,0,3,6\\) olan 4 farklı dağılımı aynı grafikte çizdirin.\n\n\n\nProblem 4\nNormal (Gaussian) dağılım formülünü kullanarak standart dağılım formülünü (\\(\\mu=0\\), \\(\\sigma=1\\)) elde ediniz.\n\n\nProblem 5\n\nSonsuz kuyu içerisindeki bir parçacığın dalga fonksiyonu aşağıdaki gibidir.\n\n\\[\\psi(x) = \\sqrt{\\frac{2}{a}} \\sin{\\left( \\frac{n \\pi x}{a} \\right)}\\]\nBurada \\(a\\) kuyunun genişliği, \\(n\\) ise parçacığın enerji seviyesidir.\n\n\\(a = 10\\) ve \\(n = 1\\) olarak sabit kabul edilsin. Bu durumda \\(\\psi(x)\\) fonksiyonunu konuma göre çizdirin.\nOlasılık yoğunluğu dalga fonksiyonunun karesi ile verilir. \\(\\psi(x)\\) fonksiyonunun karesini çizdirin.\nYukarıdaki dalga fonksiyonunu \\(n=2\\) veya \\(n=3\\) için de çizerek gözlemleyin.\n\\(n=1\\) için olasılık yoğunluğunun standart sapmasını bulun.\n\\(n=1\\) için olasılık yoğunluğunun ortalamasını bulun.\n\\(n=1\\) için olasılık yoğunluğunun varyansını bulun.\nYukarıda elde ettiğiniz değerler olasılık yoğunluğunun standart sapması oluğunu unutmayın. Yani fizikten bildiğimiz \\(&lt;x&gt;\\) büyüklüğünü hesaplamıyoruz. Bunun için \\(&lt;x&gt; = \\int_{0}^{a} x \\psi(x)^{2} dx\\) integralini hesaplamamız gerekir.\nKuyu içerisinde bir parçacığın \\(x=4\\) noktasında bulunma olasılığını bulun.\nKümülatif yoğunluk fonksiyonunu çizdirin. Bunun için np.cumsum() fonksiyonunu kullanın ve elde ettiğiniz cdf dizisini de cdf’in son değerine bölerek \\(1\\)’e normalize etmeyi unutmayın.\n\n\n\nProblem 6\nAşağıdaki dağılımları fonksiyon olarak yazın ve verilen değerler için PDF grafiklerini çizdirin.\n\nEksponansiyel dağılım için \\(\\lambda=0.1,1,2\\) alın ve grafiğini çizdirin. (\\(x=[0,5]\\))\nNormal dağılım için \\((\\mu,\\sigma)= (0,1),(0,2), (0,3)\\) alın ve grafiğini çizdirin. Aynı şekilde \\((\\mu,\\sigma)= (-2,1),(0,1), (2,1)\\) alın ve grafiğini çizdirin. (\\(x=[-8,8]\\))\nPoisson dağılımı için \\(\\lambda=0.1,1,2\\) alın ve grafiğini çizdirin. Faktöriyel almak için scipy.special.factorial() fonksiyonunu kullanın. (\\(x=[0,10]\\))\n3 Boyutlu Maxwell-Boltzman hız dağılımı formülünü kullanarak 1Mol He, Ne ve Ar atomlarının hız dağılımını çizdirin. Sıcaklığı \\(T=298.15\\) K alın. (\\(v=[0,2500]\\))\nBose-Einstein dağılım için \\((\\mu [eV], T [K]) = (0,5), (0,100), (0,273)\\) alın ve grafiğini çizdirin. Ayrı bir grafikte \\((\\mu [eV], T [K]) = (0,273), (0.01,273), (0.05,273)\\) alın ve çizdirin. Grafikde y eksenini -0.1 ile 1.1 arasında sınırlayın. (\\(E=[0.0001,0.2]\\))\nFermi-Dirac dağılımı için \\((\\mu [eV], T [K]) = (0.5,5), (0.5,100), (0.5,273)\\) alın ve grafiğini çizdirin. Ayrı bir grafikte \\((\\mu [eV], T [K]) = (0.5,273), (0.55,273), (0.85,273)\\) alın ve çizdirin. (\\(E=[0.45,0.65]\\))\n\nYaralı bilgiler\n\nAvagadro sayısı \\(N_{A} = 6.022 \\times 10^{23}\\)\nBoltzman sabiti \\(k = 1.380649 \\times 10^{-23} J/K\\)\nBoltzman sabiti \\(k = 8313.25 g~ m^{2}~ s^{-2}/K\\)\nBoltzman sabiti \\(k = 8.617e-5 \\times 10^{-5} eV/K\\)\n\\(1 eV = 1.602176634 \\times 10^{-19} J\\)\nHelyumun kütlesi \\(m_{He} = 4.002602 u\\)\nNeonun kütlesi \\(m_{Ne} = 20.1797 u\\)\nArgonun kütlesi \\(m_{Ar} = 39.948 u\\)\n\\(1 u = 1.66053906660 \\times 10^{-23} g\\).\nIşık hızı \\(c = 299792458 m/s\\)\nPlanck sabiti \\(h = 6.62607015 \\times 10^{-34} J s\\)\n\\(1 \\mathring{A} = 10^{-10} m\\)\n\\(1 nm = 10^{-9} m\\)\n\\(1 \\mu m = 10^{-6} m\\)",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#kaynaklar",
    "href": "icerik/konular/istatistik/dagilimlarin-modellenmesi.html#kaynaklar",
    "title": "Dağılımlarin Modellenmesi",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nThink Stats: Probability and Statistics for Programmers, Allen B. Downey, Franklin W. Olin, Green Tea Press, 2014\nhttps://acikders.ankara.edu.tr/pluginfile.php/102514/mod_resource/content/0/Konu%209.pdf",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Dağılımlarin Modellenmesi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "",
    "text": "Para atma örneğine tekrar dönelim. 100 tane parayı atalım ve tura gelenleri sayalım. Atışta gelen tura sayısını kaydedelim. Ardından aynı işlemi 500 kere daha yapalım.\nNe bekliyoruz? İdeal koşullarda 100 tane paranın 50 tanesi tura gelecek. Bu işlemi 500 kere bile yapsak her seferinde tura gelmesini bekleriz.\nNeden? Tura gelme olasılığı \\(1/2\\)’dir.\nOlasılık Kütle Fonksiyonu (Probability Mass Function) Tura gelme dağılımı ile olasılığı eşleştiren (mapping) fonksiyondur.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Değişkenler\nparaAtmaSayisi= 100\ntekrarlamaSayisi= 500\n\n# Tura sayısını tutacak dizi\narr_toplamTura= np.zeros(tekrarlamaSayisi)\n\n# Tekrarlam Sayisi kadar döngü\nfor it in range(tekrarlamaSayisi):\n    # 100 tane rastgele 0 veya 1 değeri üret\n    # 0: yazı, 1: tura\n    paraAtma= np.random.choice([0,1], size=paraAtmaSayisi)\n    \n    # Tüm Değerleri topla. 1'ler sanki tura gelmiş gibi düşünülebilir.\n    arr_toplamTura[it] = np.sum(paraAtma)\n\n# Çiz\nplt.hist(arr_toplamTura, bins=range(101))\nplt.xlabel(\"Tura Sayısı\")\nplt.ylabel(\"Frekans\")\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki grafiği çizdirirken yatayda, tura gelme sayısını dikkate almıştık. Şimdi yataydaki değerlerin hepsini toplam sayıya yani \\(100\\)’e bölerek çizelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Değişkenler\nparaAtmaSayisi= 100\ntekrarlamaSayisi= 500\n\n# Tura sayısını tutacak dizi\narr_toplamTura= np.zeros(tekrarlamaSayisi)\n\n# Tekrarlam Sayisi kadar döngü\nfor it in range(tekrarlamaSayisi):\n    # 100 tane rastgele 0 veya 1 değeri üret\n    # 0: yazı, 1: tura\n    paraAtma= np.random.choice([0,1], size=paraAtmaSayisi)\n    \n    # Tüm Değerleri topla. 1'ler sanki tura gelmiş gibi düşünülebilir.\n    arr_toplamTura[it] = np.sum(paraAtma)\n\n# Çiz\nplt.hist(arr_toplamTura/100, bins=20)\nplt.xlabel(\"Olasılık\")\nplt.ylabel(\"Frekans\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nGörüldüğü üzere sıklıkları toplam sayıya böldüğümüzde olasılıklar elde edilmiş oldu. İşte bu tanıma olasılık kütle fonksiyonu (probability mass function) adı verilir. Kısaca pmf olarak adlandırılır.\n\nOlasılık kütle fonksiyonu 0 ile 1 arasında değer alır.\nOlasılık kütle fonksiyonu, dağılım değerlerinin süreksiz yani kesikli olması durumunda geçerlidir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#olasılık-kütle-fonksiyonu",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#olasılık-kütle-fonksiyonu",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "",
    "text": "Para atma örneğine tekrar dönelim. 100 tane parayı atalım ve tura gelenleri sayalım. Atışta gelen tura sayısını kaydedelim. Ardından aynı işlemi 500 kere daha yapalım.\nNe bekliyoruz? İdeal koşullarda 100 tane paranın 50 tanesi tura gelecek. Bu işlemi 500 kere bile yapsak her seferinde tura gelmesini bekleriz.\nNeden? Tura gelme olasılığı \\(1/2\\)’dir.\nOlasılık Kütle Fonksiyonu (Probability Mass Function) Tura gelme dağılımı ile olasılığı eşleştiren (mapping) fonksiyondur.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Değişkenler\nparaAtmaSayisi= 100\ntekrarlamaSayisi= 500\n\n# Tura sayısını tutacak dizi\narr_toplamTura= np.zeros(tekrarlamaSayisi)\n\n# Tekrarlam Sayisi kadar döngü\nfor it in range(tekrarlamaSayisi):\n    # 100 tane rastgele 0 veya 1 değeri üret\n    # 0: yazı, 1: tura\n    paraAtma= np.random.choice([0,1], size=paraAtmaSayisi)\n    \n    # Tüm Değerleri topla. 1'ler sanki tura gelmiş gibi düşünülebilir.\n    arr_toplamTura[it] = np.sum(paraAtma)\n\n# Çiz\nplt.hist(arr_toplamTura, bins=range(101))\nplt.xlabel(\"Tura Sayısı\")\nplt.ylabel(\"Frekans\")\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki grafiği çizdirirken yatayda, tura gelme sayısını dikkate almıştık. Şimdi yataydaki değerlerin hepsini toplam sayıya yani \\(100\\)’e bölerek çizelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Değişkenler\nparaAtmaSayisi= 100\ntekrarlamaSayisi= 500\n\n# Tura sayısını tutacak dizi\narr_toplamTura= np.zeros(tekrarlamaSayisi)\n\n# Tekrarlam Sayisi kadar döngü\nfor it in range(tekrarlamaSayisi):\n    # 100 tane rastgele 0 veya 1 değeri üret\n    # 0: yazı, 1: tura\n    paraAtma= np.random.choice([0,1], size=paraAtmaSayisi)\n    \n    # Tüm Değerleri topla. 1'ler sanki tura gelmiş gibi düşünülebilir.\n    arr_toplamTura[it] = np.sum(paraAtma)\n\n# Çiz\nplt.hist(arr_toplamTura/100, bins=20)\nplt.xlabel(\"Olasılık\")\nplt.ylabel(\"Frekans\")\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\nGörüldüğü üzere sıklıkları toplam sayıya böldüğümüzde olasılıklar elde edilmiş oldu. İşte bu tanıma olasılık kütle fonksiyonu (probability mass function) adı verilir. Kısaca pmf olarak adlandırılır.\n\nOlasılık kütle fonksiyonu 0 ile 1 arasında değer alır.\nOlasılık kütle fonksiyonu, dağılım değerlerinin süreksiz yani kesikli olması durumunda geçerlidir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#alıştırma-1",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#alıştırma-1",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\n\nVerimiz [1,1,2] olsun. Bu veri kümesinin frekansını ve olasılık kütle fonksiyonunu hesaplayalım ve çizelim.\nAynı işlemleri [1,1,2,2,3,3] için yapalım.\n\n\nÇözüm\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Veri\nseri1= pd.Series([1,1,2])\n\n# Olasılık kütle fonksiyonu\nprint(f\"Tekrar eden sayılar\\n{seri1.value_counts()}\")\nprint(\"-\"*20)\nprint(f\"Kaç sayı var? {len(seri1)}\")\nprint(\"-\"*20)\npmf= seri1.value_counts()/len(seri1)\nprint(f\"pmf=\\n{pmf}\")\nprint(\"-\"*20)\n# pmf değişkenini dataframe'e çevir\npmf.name= \"Olasılık\"\n# Çiz\npmf.plot(kind=\"bar\", title=\"Pmf [1,1,2]\")\nplt.show()\n#---\nseri1= pd.Series([1,1,2,2,3,3])\n\n# Olasılık kütle fonksiyonu\nprint(f\"Tekrar eden sayılar\\n{seri1.value_counts()}\")\nprint(\"-\"*20)\nprint(f\"Kaç sayı var? {len(seri1)}\")\nprint(\"-\"*20)\npmf= seri1.value_counts()/len(seri1)\nprint(f\"pmf=\\n{pmf}\")\nprint(\"-\"*20)\n# pmf değişkenini dataframe'e çevir\npmf.name= \"Olasılık\"\n# Çiz\npmf.plot(kind=\"bar\", title=\"Pmf [1,1,2,2,3,3]\")\n\nTekrar eden sayılar\n1    2\n2    1\nName: count, dtype: int64\n--------------------\nKaç sayı var? 3\n--------------------\npmf=\n1    0.666667\n2    0.333333\nName: count, dtype: float64\n--------------------\nTekrar eden sayılar\n1    2\n2    2\n3    2\nName: count, dtype: int64\n--------------------\nKaç sayı var? 6\n--------------------\npmf=\n1    0.333333\n2    0.333333\n3    0.333333\nName: count, dtype: float64\n--------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nPMF fonksiyonu çizdirilirken histogram grafiği değil bar grafiği çizdiriyoruz.\n\n\nPmf fonksiyonunu elde etmek için yapılan işleme normalizasyon (normalization) denir. Normalizasyon işlemi, olasılık kütle fonksiyonunun toplamı 1 olacak şekilde yapılır, çünkü olasılığın tanımı gereği toplamı 1 olmalıdır.\nOlasılık kütle fonksiyonunu veri üzerinden değil de ideal koşullarda gelmesi gereken tüm değerler üzerinden de tanımlayabiliriz.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#alıştırma-2",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#alıştırma-2",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\nBir para 3 kez atılıyor. Tura gelmelerinin sayısına ait olasılık kütle fonksiyonunu bulalım.\n\nÇözüm\nOlası çözümlerimiz:\n\nTTT\nTTY, TYT, YTT\nTYY, YTY, YYT\nYYY\n\nToplam 8 ihtimal vardır. Her bir ihtimali rastgele değişkenlere atayalım.\n\n\\(X\\): Tura gelme sayısı\n\n\\[\nX= {0, 1, 2, 3}\n\\]\nBurada 3 kez para atıldığında;\n\nHiç tura gelmeyebilir \\(X=0\\).\nBir kere tura gelebilir \\(X=1\\).\nİki kere tura gelebilir \\(X=2\\).\nÜç kere tura gelebilir \\(X=3\\).\n\nBu rastgele değişkenleri kullanarak olasılık kütle fonksiyonunu bulalım.\n\n\n\nx\n0\n1\n2\n3\n\n\n\n\nP(X=x)\n1/8\n3/8\n3/8\n1/8\n\n\n\nBuradaki \\(P(x)\\) olasılık kütle fonksiyonudur veya kesikli olasılık dağılımıdır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#beklenen-değer",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#beklenen-değer",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "Beklenen Değer",
    "text": "Beklenen Değer\n\nBeklenen değer, rastgele değişkenin olasılık kütle fonksiyonu ile çarpımından elde edilir.\nBir verinin ortalaması (mean) değerini hesaplamak demek, o verinin beklenen değerini hesaplamak demektir.\n\n\\[\nE(X)\\equiv \\mu = \\sum_{x} x P(X=x)\n\\]\n\\[\n&lt;X&gt; = \\sum_{x} x P(X=x)\n\\]\nHer bir rastgele değişken, \\(x_{i}\\), ile o rastgele değişkenin olasılığı, \\(P(X=x_{i})\\) çarpılır ve tüm bu çarpımlar toplanır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#alıştırma-3",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#alıştırma-3",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "Alıştırma 3",
    "text": "Alıştırma 3\nBir elektronun spininin \\(z\\) bileşeni \\(\\hbar/2\\) veya \\(-\\hbar/2\\) değerlerini alabilir. Bu durumda bir elektronun spini \\(0.5\\) olasılıkla \\(\\hbar/2\\), \\(0.5\\) olasılıkla \\(-\\hbar/2\\) olur. Elektronun spini ile ilgili rastgele değişkeni \\(X\\) ile gösterelim.\n\nÇözüm\n\\[\nX = \\{-1/2, 1/2\\}\n\\]\nElektronun spini ile ilgili olasılık kütle fonksiyonunu bulalım.\n\n\n\nx\n\\(-\\hbar/2\\)\n\\(\\hbar/2\\)\n\n\n\n\nP(X=x)\n0.5\n0.5\n\n\n\nElektronun spinin \\(z\\) bileşeninin beklenen değeri, \\(E(X)\\) bulalım.\n\\[\nE(X) = \\sum_{i} x_{i} P(X=x_{i}) = \\frac{\\hbar}{2} \\times 0.5 -\\frac{\\hbar}{2} \\times 0.5 = 0\n\\]\nElektronun spinin \\(z\\) bileşeninin beklenen değeri \\(0\\)’dır.\nFiziksel notasyon ile karşılaştıralım. Bir elektronun spininin \\(z\\) bileşeninin beklenen değeri, \\(S_{z}\\), \\(\\psi\\) dalga fonksiyonu ile hesaplanır.\n\\[\n\\langle S_{z}\\rangle \\equiv \\langle\\psi | S_{z} | \\psi\\rangle\n\\]\nBurada dalga fonksiyonunu aşağıdaki gibi yazabiliriz. Spin yukarıyı \\(|\\uparrow\\rangle\\) ile gösterelim, spin aşağıyı \\(|\\downarrow\\rangle\\) ile gösterelim.\n\\[\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}} |\\uparrow\\rangle +\\frac{1}{\\sqrt{2}} |\\downarrow\\rangle\n\\]\nMatris gösterimi ile de yazabiliriz.\n\\[\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} + \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\\\\n\\]\n\\[\n|\\psi\\rangle = \\begin{bmatrix} 1/\\sqrt{2} \\\\ 1/\\sqrt{2} \\end{bmatrix}\n\\]\nŞimdi de \\(S_{z}\\) operatörünü matris formda yazalım. \\(S_{z}\\) operatörü, spinin \\(z\\) bileşenini temsil eder yani Pauli spin matrislerinin \\(z\\) bileşenidir.\n\\[\nS_{z} = \\frac{\\hbar}{2} \\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}\n\\]\nBeklenen değeri hesaplayalım.\n\\[\n\\langle S_{z}\\rangle = \\langle \\psi | S_{z} | \\psi \\rangle = \\begin{bmatrix} 1/\\sqrt{2} & 1/\\sqrt{2} \\end{bmatrix} \\frac{\\hbar}{2} \\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix} \\begin{bmatrix} 1/\\sqrt{2} \\\\ 1/\\sqrt{2} \\end{bmatrix} = 0\n\\]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#problemler",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#problemler",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n1 ile 10 arasında rastgele 100 sayı üretin.\n\nBu sayıların histogram grafiğini çizdirin.\nBu sayıların frekanslarını ekrana yazdırın.\nBu sayıları normalize edin ve ekrana yazdırın.\nBu sayıların olasılık kütle grafiğini çizdirin.\n\n\n\nProblem 2\nBir zar atıldığında beklenen değer ne olur? Matematiksel olarak hesaplayınız (Bilgisayarda değil).\n\n\nProblem 3\n\n2 zar atıldığında zarların toplamının beklenen değerini, varyansını ve standart sapmasını teorik olarak hesaplayan betik dosyası yazın.\n2 zarı atın ve zarların toplamını kaydedin. Bu işlemi 3600 kere yapın.\n\nToplam kaç kere “2,3,4,5,6,7,8,9,10,11,12” geldiğini gösteren histogramı aynı grafikte çizdirin.\nOlasılık kütle fonksiyonunu çizdirin. (y eksenini 1’e normalize edin. Bunun için np.array(np.unique(toplamGelme, return_counts=True)) fonksiyonunu kullanıp hangi sayıdan kaç adet geldiği bilgisini alabilirsiniz.) Bir önceki sorudan olması gereken olasılık kütle fonksiyonu değerlerini de bu grafikte gösteriniz. Bonus: Bu işlemleri pandas paketini kullanarak yapınız.\nBeklenen değerini, varyansı ve standart sapmasını, üstte bulduğunuz deney sonuçlarını ile bulduğunuz olasılık kütle fonksiyonunu kullanarak hesaplayın. Bu değerler ile teorik değerler ile karşılaştırın.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#kaynaklar",
    "href": "icerik/konular/istatistik/olasilik-kutle-fonksiyonu.html#kaynaklar",
    "title": "Olasılık Kütle Fonksiyonu",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nThink Stats: Probability and Statistics for Programmers, Allen B. Downey, Franklin W. Olin, Green Tea Press, 2014, syf:31\nhttps://www.youtube.com/watch?v=6HQV3zg4ExQ",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Olasılık Kütle Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "",
    "text": "Bir veri kümesi düşünelim. Öyle ki 1’den 300’e kadar tam sayılardan oluşmuş rastgele 5000 sayıdan oluşsun. Bu verinin olasılık kütle fonksiyonunu çizelim.\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nveri1 = pd.Series(np.random.randint(1,300,5000))\n# Frekans değerlerini hesapla ve normalize et.\nveri1_pmf= veri1.value_counts()/len(veri1)\n\nprint(veri1_pmf)\n\n# PMF çizilirken bar grafiği kullanıyoruz.\n# Yatay eksen elde edilen frekansların etkietleri (index)\n# Düşey eksen normalize edilmiş frekans değerleri\nplt.bar(veri1_pmf.index, veri1_pmf, width=1)\n\n250    0.0060\n55     0.0052\n94     0.0052\n33     0.0052\n11     0.0052\n        ...  \n6      0.0018\n188    0.0016\n67     0.0016\n240    0.0016\n206    0.0014\nName: count, Length: 299, dtype: float64\n300 adet sayının gelme olasılığına baktığımızda herhangi bir sayının gelme olasılığı yaklaşık \\(1/300\\) olmaktadır.\nBu grafikte her bir sayının gelme olasılığını hesaplayıp çizmek yerine gelme olasılıklarını toplayarak da çizebiliriz. Yani kümülatif olarak da çizebiliriz. Önce 1’in gelme olasılığı bulunur. Ardından 2’nin gelme olasılığına 1’in gelme olasılığını ekleyeceğiz. Sistematik işlemleri aşağıdaki gibi yapılır.\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nveri1 = pd.Series(np.random.randint(1,300,5000))\n# Frekans değerlerini hesapla.\nveri1_norm= veri1.value_counts()/len(veri1)\n\n# PMF çizilirken bar grafiği kullanıyoruz.\nplt.title(\"PMF\")\nplt.bar(veri1.value_counts().index.astype(float), veri1_norm, width=1)\nplt.show()\nplt.close()\n\n# Kümülatif dağılım fonksiyonu\n# Sırala\nveri1_norm.sort_index(inplace=True)\nprint(veri1_norm)\n# Kümülatif toplam\nveri1_norm_cum = veri1_norm.cumsum() # cumsum() fonksiyonu kümülatif toplamı verir.\n# Çizdir\nplt.title(\"CDF\")\nplt.plot(veri1_norm_cum, 'r')\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n1      0.0034\n2      0.0034\n3      0.0036\n4      0.0030\n5      0.0036\n        ...  \n295    0.0034\n296    0.0028\n297    0.0038\n298    0.0042\n299    0.0026\nName: count, Length: 299, dtype: float64",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#alıştırma-1",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#alıştırma-1",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nVeri seti aşağıdaki sayılardan oluşsun. Bu veri setinin kümülatif olasılık fonksiyonunu çizelim.\n[1,\\\n 2,2,2,2,2,2,2,2,2,\\\n 3,\\\n 4,\\\n 5,\\\n 6,\\\n 7,\\\n 8,\\\n 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9]\n\nÇözüm\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nveri1= pd.Series([1,2,2,2,2,2,2,2,2,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9])\n# Frekans değerlerini hesapla.\nveri1_norm= veri1.value_counts()/len(veri1)\n\n# PMF çizilirken bar grafiği kullanıyoruz.\nplt.title(\"PMF\")\nplt.bar(veri1.value_counts().index.astype(float), veri1_norm, width=1)\nplt.show()\nplt.close()\n\n# Kümülatif dağılım fonksiyonu\n# Sırala\nveri1_norm.sort_index(inplace=True)\n# Kümülatif toplam\nveri1_norm_cum = veri1_norm.cumsum() # cumsum() fonksiyonu kümülatif toplamı verir.\n# Çizdir\nplt.title(\"CDF\")\nplt.plot(veri1_norm_cum, 'r')\nplt.show()\nplt.close()",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#yüzdeler-percentiles",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#yüzdeler-percentiles",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "Yüzdeler (Percentiles)",
    "text": "Yüzdeler (Percentiles)\nYüzde Sıralama (Percentile Rank) : Bir veri kümesindeki değerlerin yüzde kaçının bu değerden küçük olduğunu gösteren değerdir.\nÖrneğin bir test yapılsın. Sonucunuz \\(67/90\\) olsun ve yüzde 20’lik dilimde (in the 20th percentile) olduğunuz size söylendi. Bu durumda sizin puanınız insanların yüzde 20’sinden daha iyi demektir. Ama yeriniz yüzde 20’de olduğu için sınıfın yüzde 80’inin notu sizden daha iyi.\n\nYüzde 50’lik dilimde (in the 50th percentile) olmak, medyan değerine eşdeğerdir.\nYüzde 25’lik dilimde (in the 25th percentile) olmak, ilk çeyreğe eşdeğerdir.\nYüzde 75’lik dilimde (in the 75th percentile) olmak, üçüncü çeyreğe eşdeğerdir.\nİlk çeyrek ile üçüncü çeyrek arasındaki farka çeyrekler arası (interquartile range) denir.\n\n\n\n\nYuzdeler, Standart Sapmalar, Kümülatif Yüzdeler  [1]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#yüzde-sıralama-percentile-rank",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#yüzde-sıralama-percentile-rank",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "Yüzde Sıralama (Percentile Rank)",
    "text": "Yüzde Sıralama (Percentile Rank)\nBir veri kümesindeki değerlerin yüzde kaçının bu değerden küçük olduğunu gösteren değerdir. Yukarıdaki örnekten devam edelim.\nYüzde 20’lik dilimde iseniz sizin yüzde sıralamanız 20’dir. Yani sınıftaki öğrencilerin yüzde 20’sinden daha iyi not almışsınız demektir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#kümülatif-dağılım-fonksiyonu-ve-yüzde-sıralama",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#kümülatif-dağılım-fonksiyonu-ve-yüzde-sıralama",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "Kümülatif Dağılım Fonksiyonu ve Yüzde Sıralama",
    "text": "Kümülatif Dağılım Fonksiyonu ve Yüzde Sıralama\nKümülatif dağılım fonksiyonuna bakarak yüzde sıralamayı bulabiliriz.\nKümülatif dağılım fonksiyonunu çizdirirken x-eksenindeki değerler veri kümesindeki değerler olmalıdır. y-eksenindeki değerler ise o değerden küçük olan değerlerin sayısı olmalıdır. Örneğin, y-eksenindeki değer 0.25 olduğunda, x-eksenindeki değer 5 ise bu, veri kümesindeki değerlerin 5’ten küçük olanların sayısının 0.25 olduğunu gösterir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#problemler",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#problemler",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nRastgele 1000 adet normal dağılımda sayı üretin ve histogramını (bin=50 olsun) siyah olarak çizdirin.\nBu dağılımın yüzde 50’lik dilimine (np.percentile()) mavi bir çizgi (plt.axvline()) çizin.\nBu dağılımın ilk ve son çeyreğine düz yeşil bir çizgi çizin.\nKümülatif dağılım fonksiyonunu (np.cumsum()) çizdirin.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#kaynaklar",
    "href": "icerik/konular/istatistik/kumulatif-dagilim-fonksiyonu.html#kaynaklar",
    "title": "Kümülatif Dağılım Fonksiyonu",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nThink Stats: Probability and Statistics for Programmers, Allen B. Downey, Franklin W. Olin, Green Tea Press, 2014, syf:31\nhttps://www.statisticshowto.com/probability-and-statistics/percentiles-rank-range/\nhttps://youtu.be/N_dokwUfmVo",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Kümülatif Dağılım Fonksiyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html",
    "href": "icerik/konular/veri-analizi/pandas-giris.html",
    "title": "pandas - Giris",
    "section": "",
    "text": "Pandas, Python programlama dilini kullanarak veri manüpilasyonu ve analizi için kullanılan bir kütüphanedir. Tıpkı numpy paketi gibi veri işleme konulardı önemli bir yer teşkil ederi.\nWeb sitesi: pandas.pydata.org\nDökümantasyon: pandas.pydata.org\nPandas, tıpkı numpy arrayleri gibi veri yapılarını kullanarak veri analizi yapmamızı sağlayan bir Python modülüdür. Arka planda numpy, matplotlib ve scipy gibi modülleri kullanır.\nPandas modülünü kullanabilmek için öncelikle modülü içe aktarmamız gerekiyor. Bu modülün yanında genellikle numpy ve matplotlib modüllerini de içe aktarıyoruz.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#pandas-modülüne-giriş",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#pandas-modülüne-giriş",
    "title": "pandas - Giris",
    "section": "",
    "text": "Pandas, Python programlama dilini kullanarak veri manüpilasyonu ve analizi için kullanılan bir kütüphanedir. Tıpkı numpy paketi gibi veri işleme konulardı önemli bir yer teşkil ederi.\nWeb sitesi: pandas.pydata.org\nDökümantasyon: pandas.pydata.org\nPandas, tıpkı numpy arrayleri gibi veri yapılarını kullanarak veri analizi yapmamızı sağlayan bir Python modülüdür. Arka planda numpy, matplotlib ve scipy gibi modülleri kullanır.\nPandas modülünü kullanabilmek için öncelikle modülü içe aktarmamız gerekiyor. Bu modülün yanında genellikle numpy ve matplotlib modüllerini de içe aktarıyoruz.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#seriler",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#seriler",
    "title": "pandas - Giris",
    "section": "Seriler",
    "text": "Seriler\nTıpkı numpy paketindeki bir boyutlu diziler gibi pandas paketinde de bir boyutlu seriler vardır. Bu seriler aşağıdaki gibi oluşturulur.\n\nimport pandas as pd\n## Numpy Array\n#arr1= np.array([1,2,3,4])\n#print(arr1)\n# Pandas Serisi\ns=pd.Series([909976, 8615246, 2872086, 2273305])\nprint(s)\n\n0     909976\n1    8615246\n2    2872086\n3    2273305\ndtype: int64\n\n\nnumpy paketindeki dizilerdeki gibi serilerde de dtype parametresi ile veri tipi belirtilir. dtype parametresi belirtilmezse veri tipi otomatik olarak belirlenir. Yukarıdaki örnekte dtype parametresi belirtilmediği için veri tipi otomatik olarak int64 olarak belirlenmiştir.\nnumpy dizileri ile pandas serileri arasındaki en büyük fark indekslemedir. s değişkenini ekrana yazdırdığımızda değerlerin sol tarafında sıfırdan başlayan etiketler (index) görüyoruz. Bu etiketler serilerdeki değerlerin sırasını gösterir.\nEtiketlerin ne olduğunda erişmek için .index komutu kullanılır.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305])\nprint(f\"s.index       =&gt; {s.index}\")\nprint(f\"list(s.index) =&gt; {list(s.index)}\")\n# Python listelerinde de benzer durum vardır.\nprint(f\"range(4)       =&gt; {range(4)}\")\nprint(f\"list(range(4)) =&gt; {list(range(4))}\")\n\ns.index       =&gt; RangeIndex(start=0, stop=4, step=1)\nlist(s.index) =&gt; [0, 1, 2, 3]\nrange(4)       =&gt; range(0, 4)\nlist(range(4)) =&gt; [0, 1, 2, 3]\n\n\nSerilerin etiketsiz, yani ham değerlerine de .values komutu ile erişilir.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305])\n# Değerleri\nprint(s.values)\n# Değişkene ata\nliste=s.values\nprint(liste[2])\n# Kısa versiyonu\nprint(s.values[2])\n\n[ 909976 8615246 2872086 2273305]\n2872086\n2872086\n\n\nEtiketleme yöntemi ile veriye erişmek faydalıdır. Örneğin s ile tanımladığımız değerler Stockholm, Londra, Roma ve Paris’in nüfusları olsun. Bu durumda etiketleri de şehir isimlerine değiştirebiliriz. Aynı zamanda serinin ismini de belirleyebiliriz.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305])\n# Etiketleri değiştirme\ns.index=['Stockholm', 'Londra', 'Roma', 'Paris']\nprint(s)\nprint(\"---o---o---\")\ns.name='Nüfus'\nprint(s)\n\nStockholm     909976\nLondra       8615246\nRoma         2872086\nParis        2273305\ndtype: int64\n---o---o---\nStockholm     909976\nLondra       8615246\nRoma         2872086\nParis        2273305\nName: Nüfus, dtype: int64\n\n\nTüm bu işlemleri tek tek yapmaktansa seriyi tanımlarken de yapabiliriz.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305], index=['Stockholm', 'Londra', 'Roma', 'Paris'], name='Nüfus')\nprint(s)\n\nStockholm     909976\nLondra       8615246\nRoma         2872086\nParis        2273305\nName: Nüfus, dtype: int64",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#veriye-erişmek",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#veriye-erişmek",
    "title": "pandas - Giris",
    "section": "Veriye Erişmek",
    "text": "Veriye Erişmek\nTıpkı numpy dizilerinde veya matrislerinde olduğu gibi pandas serilerinde de bazı verilere erişmek gerekecektir. Bunun için çeşitli yöntemler vardır.\nÖnce yukarıda tanımladığımız s serisinin “Londra” etiketine sahip değerine erişelim.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305], index=['Stockholm', 'Londra', 'Roma', 'Paris'], name='Nüfus')\n# İki çeşit erişim\nprint(f\"s['Londra'] =&gt; {s['Londra']}\")\nprint(f\"s.Londra    =&gt; {s.Londra}\")\n\ns['Londra'] =&gt; 8615246\ns.Londra    =&gt; 8615246\n\n\nGörüldüğü üzere etiketler üzerinden iki farklı şekilde veriye erişebiliyoruz. Benzer şekilde hem “Londra” hem de “Roma” etiketlerine sahip değerlere erişmek için aşağıdaki gibi bir kod yazabiliriz. Sonucun yeni bir seri olduğuna dikkat edin.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305], index=['Stockholm', 'Londra', 'Roma', 'Paris'], name='Nüfus')\n# Londra, Roma etiketlerine sahip değerler\n# Sonuç yeni bir SERİ olacaktır.\nprint(f\"s[['Londra', 'Roma']] =&gt; \\n{s[['Londra', 'Roma']]}\")\nprint(\"---o---o---\")\n\ns[['Londra', 'Roma']] =&gt; \nLondra    8615246\nRoma      2872086\nName: Nüfus, dtype: int64\n---o---o---\n\n\npandas paketi temel olarak istatistiksel işlemler yapmaya uygun olduğu için tanımlanan serilerde bazı istatistiksel işlemler yapılabilir.\n\nimport pandas as pd\ns=pd.Series([909976, 8615246, 2872086, 2273305], index=['Stockholm', 'Londra', 'Roma', 'Paris'], name='Nüfus')\n# Medyan (Ortanca)\nprint(f\"Medyan: {s.median()}\")\n# Ortalama\nprint(f\"Ortalama: {s.mean()}\") \n# Standart Sapma\nprint(f\"Standart Sapma: {s.std()}\") \n# Min-Max\nprint(f\"Min: {s.min()}\")\nprint(f\"Max: {s.max()}\")\nprint(\"---o---o---\")\n# Tanımlı istatistiksel değerler\nprint(s.describe())\n\nMedyan: 2572695.5\nOrtalama: 3667653.25\nStandart Sapma: 3399048.5005155364\nMin: 909976\nMax: 8615246\n---o---o---\ncount    4.000000e+00\nmean     3.667653e+06\nstd      3.399049e+06\nmin      9.099760e+05\n25%      1.932473e+06\n50%      2.572696e+06\n75%      4.307876e+06\nmax      8.615246e+06\nName: Nüfus, dtype: float64\n\n\nSerileri çizdimrk için plot fonksiyonu kullanılır. Plot fonksiyonunu eskiden yaptığımız gibi plt.plot() şeklinde de kullanabiliriz veya s.plot() şeklinde de kullanabiliriz. s.plot() şeklinde kullanılması, pandas paketinin içerisinde matplotlib paketinin bulunduğu anlamına gelir.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.style.use('ggplot') # İstatistiksel grafikleri daha estektik hale getirir.\ns=pd.Series([909976, 8615246, 2872086, 2273305], index=['Stockholm', 'Londra', 'Roma', 'Paris'], name='Nüfus')\n# Çiz\n# # 1 satır 4 sütunluk bir grafik\n# fig, axes= plt.subplots(1,4)\n# # s verisini çizdir\n# s.plot(ax=axes[0], kind='line', title='Çizgi Grafiği')\n# s.plot(ax=axes[1], kind='bar', title='Çubuk Grafiği')\n# s.plot(ax=axes[2], kind='barh', title='Yatay Çubuk Grafiği')\n# s.plot(ax=axes[3], kind='pie', title='Pasta Grafiği')\ns.plot(kind='line', title='Çizgi Grafiği')\nplt.show()\nplt.close()\ns.plot(kind='bar', title='Çubuk Grafiği')\nplt.show()\nplt.close()\ns.plot(kind='barh', title='Yatay Çubuk Grafiği')\nplt.show()\nplt.close()\ns.plot(kind='pie', title='Pasta Grafiği')\nplt.show()\nplt.close()",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#alıştırma-1",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#alıştırma-1",
    "title": "pandas - Giris",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\n\nAşağıdaki verileri içeren bir pandas serisi oluşturun.\n\n\n\n\nİsim\nYaş\n\n\n\n\nAli\n25\n\n\nAyşe\n30\n\n\nMehmet\n40\n\n\nFatma\n35\n\n\nHasan\n20\n\n\nHüseyin\n50\n\n\nZeynep\n45\n\n\nMerve\n30\n\n\nÖzlem\n35\n\n\n\n\nBu serinin ismini “Yaşlar” olarak ayarlayın.\nBu serideki Fatma’nın yaşını ekrana yazdırın.\nBu serideki Fatma’nın, Hasan’ın ve Zeynep’in yaşlarını ekrana yazdırın.\nBu serideki Fatma’nın yaşını 18 yapın.\nBu seri’deki en yaşlı kişinin yaşını ekrana yazdırın.\nBu seri’deki en genç kişinin yaşını ekrana yazdırın.\nYaşların ortalamasını ekrana yazdırın.\nBu seriyi dikey bar ve pasta grafiği olarak çizdirin.\n\n\nÇözüm\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.style.use('ggplot')\n# 1. Soru\ns=pd.Series([25, 30, 40, 35, 20, 50, 45, 30, 35], index=['Ali', 'Ayşe', 'Mehmet', 'Fatma', 'Hasan', 'Hüseyin', 'Zeynep', 'Merve', 'Özlem'], name='Yaşlar')\n# s=pd.Series([25, 30, 40, 35, 20, 50, 45, 30, 35])\n# s.index=['Ali', 'Ayşe', 'Mehmet', 'Fatma', 'Hasan', 'Hüseyin', 'Zeynep', 'Merve', 'Özlem']\n# 2. Soru\ns.name='Yaşlar'\n# 3. Soru\nprint(f\"Fatma'nın yaşı: {s['Fatma']}\")\n# print(f\"Fatma'nın yaşı: {s.Fatma}\")\n# 4. Soru\nprint(f\"Fatma, Hasan ve Zeynep'in yaşları: \\n{s[['Fatma', 'Hasan', 'Zeynep']]}\")\n# 5. Soru\ns['Fatma']=18\n# s.Fatma=18\n# 6. Soru\nprint(f\"En yaşlı kişi: {s.max()}\")\n# 7. Soru\nprint(f\"En genç kişi: {s.min()}\")\n# 8. Soru\nprint(f\"Ortalama: {s.mean()}\")\n# 9. Soru\ns.plot(kind='bar', title='Yaşlar')\nplt.show()\nplt.close()\ns.plot(kind='pie', title='Yaşlar')\nplt.show()\nplt.close()\n\nFatma'nın yaşı: 35\nFatma, Hasan ve Zeynep'in yaşları: \nFatma     35\nHasan     20\nZeynep    45\nName: Yaşlar, dtype: int64\nEn yaşlı kişi: 50\nEn genç kişi: 18\nOrtalama: 32.55555555555556",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#veri-çerçevesi-dataframe",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#veri-çerçevesi-dataframe",
    "title": "pandas - Giris",
    "section": "Veri Çerçevesi (DataFrame)",
    "text": "Veri Çerçevesi (DataFrame)\nSerileri tek boyutlu diziler olarak düşünebiliriz. Yukarıda verdiğimiz örnekte, s serisi sadece şehirlerin nüfus bilgisini içeriyordu. pandas paketinde verileri iki boyutlu bir yapıda tutan veri çerçeveleri (data frame) vardır.Veri çerçevelerini aşağıdaki gibi oluşturabiliriz.\n\nimport pandas as pd\n# Data Frame\ndf= pd.DataFrame([\\\n      [909976, \"İsveç\"]\\\n    , [8615246, \"Birleşik Krallık\"]\\\n    , [2872086, \"İtalya\"]\\\n    , [2273305, \"Fransa\"]]\n        , index=['Stockholm', 'Londra', 'Roma', 'Paris'], columns=['Nüfus', 'Ülke'])\nprint(df)\n\n             Nüfus              Ülke\nStockholm   909976             İsveç\nLondra     8615246  Birleşik Krallık\nRoma       2872086            İtalya\nParis      2273305            Fransa\n\n\nSerideki nüfus bilgisine ek olarak ülke verisini de kaydettik. Yatayda (satır) eklenen veri etiket, index bazında ilerlerken düşeyde (sütun) eklenen veri sütun bazında ilerlemektedir. Sütunlar columns- olarak isimlendirilmektedir. Eğer herhangi bir adlandırma yapılmazsa, tıpkı etiketlerde olduğu gibi otomatik olarak sıfırdan başlayan sıralı sayılar atanır.\nSütunlara erişmek için aşağıdaki gibi bir kod yazılır.\n\nimport pandas as pd\n# Data Frame\ndf= pd.DataFrame([\\\n      [909976, \"İsveç\"]\\\n    , [8615246, \"Birleşik Krallık\"]\\\n    , [2872086, \"İtalya\"]\\\n    , [2273305, \"Fransa\"]]\n        , index=['Stockholm', 'Londra', 'Roma', 'Paris'], columns=['Nüfus', 'Ülke'])\nprint(df.columns)\n# Sütunlardaki sadece nüfus elemanına erişmek için\nprint(df.columns[0])\n\nIndex(['Nüfus', 'Ülke'], dtype='object')\nNüfus\n\n\nDataframe’leri python sözlük (dictionary) şeklinde de tanımlayabiliriz.\n\nimport pandas as pd\n# Alternatif Tanımlama\ndf2= pd.DataFrame({\n    \"Nüfus\": [909976, 8615246, 2872086, 2273305],\n    \"Ülke\": [\"İsveç\", \"Birleşik Krallık\", \"İtalya\", \"Fransa\"]},\n    index=['Stockholm', 'Londra', 'Roma', 'Paris'])\nprint(df2)\n\n             Nüfus              Ülke\nStockholm   909976             İsveç\nLondra     8615246  Birleşik Krallık\nRoma       2872086            İtalya\nParis      2273305            Fransa",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#veriye-erişim",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#veriye-erişim",
    "title": "pandas - Giris",
    "section": "Veriye Erişim",
    "text": "Veriye Erişim\nSerilerde olduğu gibi dataframe’lerde de verilere erişmek gerekecektir. Bunun için çeşitli yöntemler vardır.\n\n\n\n\n\n\nDikkat\n\n\n\nDataFrame’lerde veriye ulaşmak için kullanılan köşeli parantez yöntemi sadece sütunlar için geçerlidir.\n\n\n\n\n\n\n\n\nUyarı\n\n\n\nTürkçe karakter kullanarak tanımlanan sütunlarda nokta kullanarak erişim sağlayamayabilirsiniz. Bunun için köşeli parantez ve tırnak kullanmanız gerekir.\n\n\n\nimport pandas as pd\n# Data Frame\ndf= pd.DataFrame([\\\n      [909976, \"İsveç\"]\\\n    , [8615246, \"Birleşik Krallık\"]\\\n    , [2872086, \"İtalya\"]\\\n    , [2273305, \"Fransa\"]]\n        , index=['Stockholm', 'Londra', 'Roma', 'Paris'], columns=['Nüfus', 'Ülke'])\n# Nüfus sütununa erişim\nprint(df[\"Nüfus\"])\nprint(\"----------------\")\n#! Türkçe karakter kullandığımızda hata vermedi !?\nprint(df.Nüfus)\nprint(\"----------------\")\n#print(df[\"Roma\"]) #! Hata verir\n\nStockholm     909976\nLondra       8615246\nRoma         2872086\nParis        2273305\nName: Nüfus, dtype: int64\n----------------\nStockholm     909976\nLondra       8615246\nRoma         2872086\nParis        2273305\nName: Nüfus, dtype: int64\n----------------\n\n\n\n\n\n\n\n\nUyarı\n\n\n\nSerilerde [\"Satır\"] şeklinde erişim yaparken dataframe’lerde [\"Sütun\"] şeklinde erişim yapılır.\n\n\n\nimport pandas as pd\n# Seri\ns=pd.Series([909976, 8615246, 2872086, 2273305], index=['Stockholm', 'Londra', 'Roma', 'Paris'], name='Nüfus')\n# Data Frame\ndf= pd.DataFrame([\\\n      [909976, \"İsveç\"]\\\n    , [8615246, \"Birleşik Krallık\"]\\\n    , [2872086, \"İtalya\"]\\\n    , [2273305, \"Fransa\"]]\n        , index=['Stockholm', 'Londra', 'Roma', 'Paris'], columns=['Nüfus', 'Ülke'])\n# Seride \"Londra\" etiketine sahip değer\nprint(f\"s['Londra'] =&gt; {s['Londra']}\")\nprint(\"---o---o---o---\")\n# Dataframe'de \"Nüfus\" sütununa sahip sütun\nprint(f\"df['Nüfus'] =&gt; \\n{df['Nüfus']}\")\n\ns['Londra'] =&gt; 8615246\n---o---o---o---\ndf['Nüfus'] =&gt; \nStockholm     909976\nLondra       8615246\nRoma         2872086\nParis        2273305\nName: Nüfus, dtype: int64\n\n\nSütunlara köşeli parantez veya nokta kullanarak erişebildik. Satırlara dar .loc[] yöntemi ile erişebiliriz. loc yöntemi ile erişmek istediğimizde belirlediğimiz satır(lar)daki tüm sütun değerlerini alırız.\nEğer belirlediğimiz bir satırın tüm sütun değerlerini almak istemiyorsak, sütunları da belirtmemiz gerekir. Bunun için loc[Satır(lar), Sütun(lar)] şeklinde bir kullanım yaparız.\n\nimport pandas as pd\n# Data Frame\ndf= pd.DataFrame([\\\n      [909976, \"İsveç\"]\\\n    , [8615246, \"Birleşik Krallık\"]\\\n    , [2872086, \"İtalya\"]\\\n    , [2273305, \"Fransa\"]]\n        , index=['Stockholm', 'Londra', 'Roma', 'Paris'], columns=['Nüfus', 'Ülke'])\n# Data Frame Yazdır\nprint(f\"df =&gt; \\n{df}\")\nprint(\"---o---o---o---\")\nprint(f\"df.loc['Roma'] =&gt; \\n{df.loc['Roma']}\")\nprint(\"---o---o---o---\")\nprint(f\"df.loc[['Roma', 'Paris']] =&gt; \\n{df.loc[['Roma', 'Paris']]}\")\nprint(\"---o---o---o---\")\nprint(f\"df.loc[['Roma', 'Paris'], 'Nüfus'] =&gt; \\n{df.loc[['Roma', 'Paris'], 'Nüfus']}\")\n\ndf =&gt; \n             Nüfus              Ülke\nStockholm   909976             İsveç\nLondra     8615246  Birleşik Krallık\nRoma       2872086            İtalya\nParis      2273305            Fransa\n---o---o---o---\ndf.loc['Roma'] =&gt; \nNüfus    2872086\nÜlke      İtalya\nName: Roma, dtype: object\n---o---o---o---\ndf.loc[['Roma', 'Paris']] =&gt; \n         Nüfus    Ülke\nRoma   2872086  İtalya\nParis  2273305  Fransa\n---o---o---o---\ndf.loc[['Roma', 'Paris'], 'Nüfus'] =&gt; \nRoma     2872086\nParis    2273305\nName: Nüfus, dtype: int64",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#alıştırma-2",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#alıştırma-2",
    "title": "pandas - Giris",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\n\nAşağıdaki verileri içeren bir pandas dataframe (veri çerçevesi) oluşturun.\n\n\n\n\nİsim\nYaş\nMeslek\nMaaş\nCinsiyet\n\n\n\n\nAli\n25\nÖğrenci\n1000\nErkek\n\n\nAyşe\n30\nÖğretmen\n5000\nKadın\n\n\nMehmet\n40\nMühendis\n8000\nErkek\n\n\nFatma\n35\nDoktor\n10000\nKadın\n\n\nHasan\n20\nÖğrenci\n1000\nErkek\n\n\nHüseyin\n50\nMühendis\n8000\nErkek\n\n\nZeynep\n45\nDoktor\n10000\nKadın\n\n\nMerve\n30\nÖğretmen\n5000\nKadın\n\n\n\n\nBu veri çerçevesinin ismini “Personel” olarak ayarlayın.\nBu veri çerçevesindeki “Meslek” sütununu ekrana yazdırın.\nBu veri çerçevesindeki “Meslek” ve “Maaş” sütunlarını ekrana yazdırın.\nBu veri çerçevesindeki “Meslek” ve “Maaş” sütunlarını “Meslekler” ve “Maaşlar” olarak ayarlayın.\nBu veri çerçevesindeki “Ali”’nin tüm bilgilerini ekrana yazdırın.\nBu veri çerçevesindeki “Ali”, “Ayşe” ve “Mehmet”’in tüm bilgilerini ekrana yazdırın.\nBu veri çerçevesindeki “Ali”’nin “Meslek” ve “Maaş” bilgilerini ekrana yazdırın.\nBu veri çerçevesindeki “Ali”, “Ayşe” ve “Mehmet”’in “Yaş” ve “Cinsiyet” bilgilerini ekrana yazdırın.\n\n\nÇözüm\n\nimport pandas as pd\n# 1. Soru\ndf= pd.DataFrame({\n    \"Yaş\": [25, 30, 40, 35, 20, 50, 45, 30],\n    \"Meslek\": [\"Öğrenci\", \"Öğretmen\", \"Mühendis\", \"Doktor\", \"Öğrenci\", \"Mühendis\", \"Doktor\", \"Öğretmen\"],\n    \"Maaş\": [1000, 5000, 8000, 10000, 1000, 8000, 10000, 5000],\n    \"Cinsiyet\": [\"Erkek\", \"Kadın\", \"Erkek\", \"Kadın\", \"Erkek\", \"Erkek\", \"Kadın\", \"Kadın\"]\n    },\n    index=['Ali', 'Ayşe', 'Mehmet', 'Fatma', 'Hasan', 'Hüseyin', 'Zeynep', 'Merve'])\n# 2. Soru\ndf.name='Personel'\nprint(f\"df.name =&gt; {df.name}\")\nprint(\"---o---o---o---\")\n# 3. Soru\nprint(f\"df['Meslek'] =&gt; \\n{df['Meslek']}\")\nprint(\"---o---o---o---\")\n# 4. Soru\nprint(f\"df[['Meslek', 'Maaş']] =&gt; \\n{df[['Meslek', 'Maaş']]}\")\nprint(\"---o---o---o---\")\n# 5. Soru\ndf=df.rename(columns= {'Meslek' : 'Meslekler'})\ndf=df.rename(columns= {'Maaş' : 'Maaşlar'})\nprint(f\"df.columns =&gt; {df.columns}\")\nprint(\"---o---o---o---\")\n# 6. Soru\nprint(f\"df.loc['Ali'] =&gt; \\n{df.loc['Ali']}\")\nprint(\"---o---o---o---\")\n# 7. Soru\nprint(f\"df.loc[['Ali', 'Ayşe', 'Mehmet']] =&gt; \\n{df.loc[['Ali', 'Ayşe', 'Mehmet']]}\")\nprint(\"---o---o---o---\")\n# 8. Soru\nprint(f\"df.loc['Ali', ['Meslekler', 'Maaşlar']] =&gt; \\n{df.loc['Ali', ['Meslekler', 'Maaşlar']]}\")\nprint(\"---o---o---o---\")\n# 9. Soru\nprint(f\"df.loc[['Ali', 'Ayşe', 'Mehmet'], ['Yaş', 'Cinsiyet']] =&gt; \\n{df.loc[['Ali', 'Ayşe', 'Mehmet'], ['Yaş', 'Cinsiyet']]}\")\nprint(\"---o---o---o---\")\n\ndf.name =&gt; Personel\n---o---o---o---\ndf['Meslek'] =&gt; \nAli         Öğrenci\nAyşe       Öğretmen\nMehmet     Mühendis\nFatma        Doktor\nHasan       Öğrenci\nHüseyin    Mühendis\nZeynep       Doktor\nMerve      Öğretmen\nName: Meslek, dtype: object\n---o---o---o---\ndf[['Meslek', 'Maaş']] =&gt; \n           Meslek   Maaş\nAli       Öğrenci   1000\nAyşe     Öğretmen   5000\nMehmet   Mühendis   8000\nFatma      Doktor  10000\nHasan     Öğrenci   1000\nHüseyin  Mühendis   8000\nZeynep     Doktor  10000\nMerve    Öğretmen   5000\n---o---o---o---\ndf.columns =&gt; Index(['Yaş', 'Meslekler', 'Maaşlar', 'Cinsiyet'], dtype='object')\n---o---o---o---\ndf.loc['Ali'] =&gt; \nYaş               25\nMeslekler    Öğrenci\nMaaşlar         1000\nCinsiyet       Erkek\nName: Ali, dtype: object\n---o---o---o---\ndf.loc[['Ali', 'Ayşe', 'Mehmet']] =&gt; \n        Yaş Meslekler  Maaşlar Cinsiyet\nAli      25   Öğrenci     1000    Erkek\nAyşe     30  Öğretmen     5000    Kadın\nMehmet   40  Mühendis     8000    Erkek\n---o---o---o---\ndf.loc['Ali', ['Meslekler', 'Maaşlar']] =&gt; \nMeslekler    Öğrenci\nMaaşlar         1000\nName: Ali, dtype: object\n---o---o---o---\ndf.loc[['Ali', 'Ayşe', 'Mehmet'], ['Yaş', 'Cinsiyet']] =&gt; \n        Yaş Cinsiyet\nAli      25    Erkek\nAyşe     30    Kadın\nMehmet   40    Erkek\n---o---o---o---",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#problemler",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#problemler",
    "title": "pandas - Giris",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nGithub reposunda bulunan veri-analizi-european_cities.csv dosyasınına bu linkten erişin. Bu dosyayı okuyarak bir pandas dataframe (veri çerçevesi) oluşturun. Bu datayı okumak için pd.read_csv('european_cities.csv') fonksiyonunu kullanabilirsiniz.\n [1] referansındaki european_cities.csv dosyasını okuyarak farklı isimde bir pandas dataframe (veri çerçevesi) oluşturun.\n.info() fonksiyonunu kullanarak içeriği hakkında bilgi edinin.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-giris.html#kaynaklar",
    "href": "icerik/konular/veri-analizi/pandas-giris.html#kaynaklar",
    "title": "pandas - Giris",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Python: Scientific Computing and Data, Science Applications with Numpy, SciPy and Matplotlib, Robert Johansson, Apress, İkinci Basım, 2019, syf 406\nVS Code ile csv dosyası görüntüleme: Excel Viewer",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Giris"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-uygulama.html",
    "href": "icerik/konular/veri-analizi/pandas-uygulama.html",
    "title": "pandas - Uygulama",
    "section": "",
    "text": "# Seriler\ns= pd.Series()\ns.index\ns.values\ns.name\ns[\"Londra\"]\ns.Londra\ns.describe()\ns.max()\ns.min()\ns.std()\ns.mean()\ns.median()\ns.plot(kind= 'line')\ns.plot(kind= 'bar')\ns.plot(kind= 'barh')\ns.plot(kind= 'pie')\n# ----------------\ndf= pd.DataFrame()\ndf.columns\ndf[\"Nüfus\"] #! Sütunun İsmi\ndf.Nüfus #! Türkçe karakter kullanma, Sütunun ismi\ndf.loc[\"Londra\"] # Satır ismi\ndf.loc[[\"Londra\", \"Roma\"]]\ndf.rename(columns= {\"Nüfus\" : \"Nüfuslar\"})\ndf.info()\n# ----------------\ndf= pd.read_csv()\ndf.head()\ndf.tail()\ndf.loc[\"Etiket İsmi\"]\ndf.iloc[0]\ndf.iloc[1, 2]\ndf.shape\ndf[\"Yeni Sütun\"]\ndf[\"Sütun İsmi\"].unique()\ndf[\"Sütun İsmi\"].value_counts()\ndf[\"Sütun İsmi\"].duplicated()\ndf.drop(\"Sütun İsmi\", axis=1)\ndf.pop(\"Sütun İsmi\")\ndf.drop(\"Etiket İsmi\", axis=0)\ndf.Population.apply(lambda x: int(x.replace(',','')))\ndf.State.str.capitalize()\ndf.index.name\ndf.sort_index()\ndf.sort_values(by=\"Sütun İsmi\", ascending=True)\ndf.set_index([\"State\", \"City\"]).sort_index(level=0)\ndf.set_index([\"State\", \"City\"]).sort_index(level=1)\ndf.sum()",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Uygulama"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-uygulama.html#neler-öğrendik",
    "href": "icerik/konular/veri-analizi/pandas-uygulama.html#neler-öğrendik",
    "title": "pandas - Uygulama",
    "section": "",
    "text": "# Seriler\ns= pd.Series()\ns.index\ns.values\ns.name\ns[\"Londra\"]\ns.Londra\ns.describe()\ns.max()\ns.min()\ns.std()\ns.mean()\ns.median()\ns.plot(kind= 'line')\ns.plot(kind= 'bar')\ns.plot(kind= 'barh')\ns.plot(kind= 'pie')\n# ----------------\ndf= pd.DataFrame()\ndf.columns\ndf[\"Nüfus\"] #! Sütunun İsmi\ndf.Nüfus #! Türkçe karakter kullanma, Sütunun ismi\ndf.loc[\"Londra\"] # Satır ismi\ndf.loc[[\"Londra\", \"Roma\"]]\ndf.rename(columns= {\"Nüfus\" : \"Nüfuslar\"})\ndf.info()\n# ----------------\ndf= pd.read_csv()\ndf.head()\ndf.tail()\ndf.loc[\"Etiket İsmi\"]\ndf.iloc[0]\ndf.iloc[1, 2]\ndf.shape\ndf[\"Yeni Sütun\"]\ndf[\"Sütun İsmi\"].unique()\ndf[\"Sütun İsmi\"].value_counts()\ndf[\"Sütun İsmi\"].duplicated()\ndf.drop(\"Sütun İsmi\", axis=1)\ndf.pop(\"Sütun İsmi\")\ndf.drop(\"Etiket İsmi\", axis=0)\ndf.Population.apply(lambda x: int(x.replace(',','')))\ndf.State.str.capitalize()\ndf.index.name\ndf.sort_index()\ndf.sort_values(by=\"Sütun İsmi\", ascending=True)\ndf.set_index([\"State\", \"City\"]).sort_index(level=0)\ndf.set_index([\"State\", \"City\"]).sort_index(level=1)\ndf.sum()",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Uygulama"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-uygulama.html#alıştırma-1",
    "href": "icerik/konular/veri-analizi/pandas-uygulama.html#alıştırma-1",
    "title": "pandas - Uygulama",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\n\nAmerika’daki Kalifornya eyaletinin elektrik tüketimini veren bu veriyi okuyun  [1]. Okuma tarihi 25.05.2023.\nİlk ve son 5 satırını yazdırın.\nTimestamp (Hour Ending) sütun ismini Tarih Bilgisi yapın.\nDemand (MWh) sütun ismini Talep (MWh) yapın.\nTalep (MWh) sütununundaki NaN olan satırlarını silin.\nYatayda Tarih Bilgisi, düşeyde Talep (MWh) olacak şekilde bir grafik çizin.\n\n\nÇözüm\n\n################################################\nimport os\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nveri_dir = os.path.join(\\\n    os.path.abspath(\\\n        os.path.join(\\\n    current_dir, os.pardir, os.pardir, os.pardir))\\\n        , 'veri')\n################################################\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# Oku\ndf = pd.read_csv(veri_dir+\"/veri-930-data-export.csv\",\n    delimiter=\",\")\n# İlk ve son 5 satır\nprint(df.head())\nprint(df.tail())\n# Sütun isimlerini değiştir\ndf.rename(columns={\"Timestamp (Hour Ending)\":\"Tarih Bilgisi\"},\n    inplace=True)\ndf.rename(columns={\"Demand (MWh)\":\"Talep (MWh)\"}\\\n    , inplace=True)\n# NaN satırlarını \"Talep (MWh)\" sütunundan sil\ndf.dropna(subset=[\"Talep (MWh)\"], inplace=True)\n# Çiz\nplt.plot(df[\"Tarih Bilgisi\"], df[\"Talep (MWh)\"])\nplt.xlabel(\"Tarh Bilgisi\")\nplt.ylabel(\"Kalifornya Elektrik Talebi (MWh)\")\nplt.xticks(rotation=25)\nplt.xticks(np.arange(0, len(df), step=20))\nplt.show()\nplt.close()\n\n  Region Code Timestamp (Hour Ending)  Demand (MWh)  Demand Forecast (MWh)  \\\n0        US48   5/17/2023 12 a.m. EDT      446173.0                 438971   \n1        US48    5/17/2023 1 a.m. EDT      418994.0                 412814   \n2        US48    5/17/2023 2 a.m. EDT      399252.0                 389905   \n3        US48    5/17/2023 3 a.m. EDT      381525.0                 373869   \n4        US48    5/17/2023 4 a.m. EDT      370696.0                 363882   \n\n   Net Generation (MWh)  Total Interchange (MWh)  \n0              438045.0                  -5573.0  \n1              410208.0                  -5438.0  \n2              389248.0                  -5768.0  \n3              372178.0                  -4785.0  \n4              363001.0                  -4675.0  \n    Region Code Timestamp (Hour Ending)  Demand (MWh)  Demand Forecast (MWh)  \\\n188        US48    5/24/2023 8 p.m. EDT           NaN                 504300   \n189        US48    5/24/2023 9 p.m. EDT           NaN                 494357   \n190        US48   5/24/2023 10 p.m. EDT           NaN                 479733   \n191        US48   5/24/2023 11 p.m. EDT           NaN                 457902   \n192        US48   5/25/2023 12 a.m. EDT           NaN                 431842   \n\n     Net Generation (MWh)  Total Interchange (MWh)  \n188                   NaN                      NaN  \n189                   NaN                      NaN  \n190                   NaN                      NaN  \n191                   NaN                      NaN  \n192                   NaN                      NaN  \n\n\n/opt/hostedtoolcache/Python/3.10.14/x64/lib/python3.10/site-packages/dateutil/parser/_parser.py:1207: UnknownTimezoneWarning: tzname EDT identified but not understood.  Pass `tzinfos` argument in order to correctly return a timezone-aware datetime.  In a future version, this will raise an exception.\n  warnings.warn(\"tzname {tzname} identified but not understood.  \"",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Uygulama"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-uygulama.html#alıştırma-2",
    "href": "icerik/konular/veri-analizi/pandas-uygulama.html#alıştırma-2",
    "title": "pandas - Uygulama",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\nBu linkte, ülkelerin mutluluk skorları ve bunlar ile ilintili bilgilerin olduğu csv dosyaları bulunmaktadır. Her yıl için, 2015, 2016, 2017, 2018, 2019, indirin ve aşağıdaki soruları cevaplayın.\n\nBeş yıllık veri setini tek bir veri setinde birleştirin.\nTürkiye’nin mutluluk skorunu yıllara göre nasıl değiştiğini grafik gösterin.\nTürkiye’nin gayri safi milli hasılası (GSMH, sütunlarda GDP per capita isminde) yıllara göre nasıl değiştiğini grafik üzerinde gösterin.\n\n\nÇözüm\n\n################################################\nimport os\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nveri_dir = os.path.join(\\\n    os.path.abspath(\\\n        os.path.join(\\\n    current_dir, os.pardir, os.pardir, os.pardir))\\\n        , 'veri')\n################################################\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# 2015\nhappiness2015 = pd.read_csv(veri_dir+'/veri_mutluluk_2015.csv')\nhappiness2015['Year'] = 2015\nhappiness2015.rename(columns={'Happiness Score':  'Score', 'Economy (GDP per Capita)': 'GDP per capita'}, inplace=True)\n# 2016\nhappiness2016 = pd.read_csv(veri_dir+'/veri_mutluluk_2016.csv')\nhappiness2016['Year'] = 2016\nhappiness2016.rename(columns={'Happiness Score':  'Score', 'Economy (GDP per Capita)': 'GDP per capita'}, inplace=True)\n# 2017\nhappiness2017 = pd.read_csv(veri_dir+'/veri_mutluluk_2017.csv')\nhappiness2017['Year'] = 2017\nhappiness2017.rename(columns={'Happiness.Score':  'Score', 'Economy..GDP.per.Capita.': 'GDP per capita'}, inplace=True)\n# 2018\nhappiness2018 = pd.read_csv(veri_dir+'/veri_mutluluk_2018.csv')\nhappiness2018['Year'] = 2018\nhappiness2018.rename(columns={'Country or region':  'Country'}, inplace=True)\n# 2019\nhappiness2019 = pd.read_csv(veri_dir+'/veri_mutluluk_2019.csv')\nhappiness2019['Year'] = 2019\nhappiness2019.rename(columns={'Country or region':  'Country'}, inplace=True)\n# Ortak sütunlar\nhappiness = pd.concat([happiness2015, happiness2016, happiness2017, happiness2018, happiness2019], ignore_index=True)\n# Türkiye\nturkiye = happiness[happiness['Country'] == 'Turkey']\nprint(turkiye.head())\n# Çiz\nplt.plot(turkiye['Year'], turkiye['Score'], marker='.')\nplt.xlabel('Yıllar')\nplt.ylabel('Mutluluk Skoru (Happiness Score)')\nplt.title('Türkiye Mutluluk Skoru (Happiness Score) Değişimi')\nplt.show()\nplt.close()\n# Gayri Safi Milli Hasıla\n# Çiz\nplt.plot(turkiye['Year'], turkiye['GDP per capita'], marker='.')\nplt.xlabel('Yıllar')\nplt.ylabel('Gayri Safi Milli Hasıla (GDP per capita)')\nplt.title('Gayri Safi Milli Hasıla (GDP per capita) Değişimi')\nplt.show()\n\n    Country                           Region  Happiness Rank  Score  \\\n75   Turkey  Middle East and Northern Africa            76.0  5.332   \n235  Turkey  Middle East and Northern Africa            78.0  5.389   \n383  Turkey                              NaN             NaN  5.500   \n543  Turkey                              NaN             NaN  5.483   \n704  Turkey                              NaN             NaN  5.373   \n\n     Standard Error  GDP per capita    Family  Health (Life Expectancy)  \\\n75          0.03864        1.060980  0.946320                   0.73172   \n235             NaN        1.164920  0.877170                   0.64718   \n383             NaN        1.198274  1.337753                       NaN   \n543             NaN        1.148000       NaN                       NaN   \n704             NaN        1.183000       NaN                       NaN   \n\n      Freedom  Trust (Government Corruption)  ...  Whisker.high  Whisker.low  \\\n75   0.228150                        0.15746  ...           NaN          NaN   \n235  0.238890                        0.12348  ...           NaN          NaN   \n383  0.300741                            NaN  ...      5.594865     5.405135   \n543       NaN                            NaN  ...           NaN          NaN   \n704       NaN                            NaN  ...           NaN          NaN   \n\n     Health..Life.Expectancy.  Trust..Government.Corruption.  \\\n75                        NaN                            NaN   \n235                       NaN                            NaN   \n383                  0.637606                       0.099672   \n543                       NaN                            NaN   \n704                       NaN                            NaN   \n\n     Dystopia.Residual  Overall rank  Social support  Healthy life expectancy  \\\n75                 NaN           NaN             NaN                      NaN   \n235                NaN           NaN             NaN                      NaN   \n383           1.879278           NaN             NaN                      NaN   \n543                NaN          74.0            1.38                    0.686   \n704                NaN          79.0            1.36                    0.808   \n\n     Freedom to make life choices  Perceptions of corruption  \n75                            NaN                        NaN  \n235                           NaN                        NaN  \n383                           NaN                        NaN  \n543                         0.324                      0.109  \n704                         0.195                      0.106  \n\n[5 rows x 26 columns]",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Uygulama"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-uygulama.html#problemler",
    "href": "icerik/konular/veri-analizi/pandas-uygulama.html#problemler",
    "title": "pandas - Uygulama",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nGithub sitesinde bulunan veri_imdb_1e5rows.tsv dosyasındaki verinin metadatasına inceleyin. Bu veri, title.akas.tsv.gz adlı dosyanın ilk \\(10^{5}\\) satırıdır. Bu veriyi pd.read_table() fonksiyonu ile okuyun.\nEğer tüm veri ile çalışmak istiyorsanız (1.8 gb) şu linkteki dosyayı indirin. Bu dosya sıkıştırılmış dosyadır. Bu dosyayı indirdikten sonra dışarı aktarın.\nBu veri hakkında aşağıdaki soruları cevaplayın.\n\nBu verinin sütunları nelerdir?\nBu verinin kaç sütunu var?\nBu verinin kaç satırı var?\nBu verinin ilk 2 satırını gösterin.\nBu verinin son 2 satırını gösterin.\nBu veri setindeki tüm biricik dilleri (language) gösterin.\nBu veri setindeki tüm biricik bölgeleri (region) gösterin.\nBu veri setindeki her bir biricik dilde kaç adet film vardır?\nBu veri setindeki her bir biricik bölgede kaç adet film vardır?\nBu veri setindeki attributes sütununu çıkarın (değişkene atayın).\nBu verideki sütunların veri tiplerini ekrana yazdırın.\nBu verinin ordering sütununu tam sayı haline getirin (değişkene atayın).\nBu verinin isOriginalTitle sütununu bool haline getirin (değişkene atayın).\nBu verinin etiketlerini titleId olacak şekilde gösterin (değişkene atayın).\nBu verinin etiketini titleId ve title olarak değiştirin (değişkene atayın).\nBu veriyi titleId sütununa göre sıralayın (değişkene atayın).\nBu verideki tüm \\N değerlerini pd.NA değerleri ile değiştirin (değişkene atamayın).\nBu verinin titleId ve title etiketlerini tekrar sütun haline getirin (değişkene atayın).\nBu verideki types sütunu içerisinde olan original verisine sahip satırları gösterin ve sonucu df2 değişkenine atayın.\nBu veride isOriginalTitle sütunu True olan satırları gösterin ve sonucu df2 ile karşılaştırın. Yani elde ettiğiniz veri ile df2 verisi aynı mı? Değilse hangi satırlar farklı?\n\n\n\nProblem 2\nTÜİK’in veri merkezinde bulunan “Hava Alanlarında Toplam Yolcu ve Yük Trafiği” verisini indirin. Bu veri dosyasında yani dosyayı bir office programında açıp herhangi bir değişiklik yapmayın!\nAşağıdaki soruları cevaplayın.\n\nBu excel dosyasını okuyun ve df değişkenine atayın. (Not: read_excel fonksiyonu ile okumak için xlrd kütüphanesini kurmanız gerekebilir. pip install xlrd komutu ile kurabilirsiniz.)\nVeri çerçevesini gösterin.\nVeri çerçevesi temizleyin. Bu temizlemeyi excel dosyasını açıp değil pandas ile yapın. Bu temizlemeyi aşağıdaki grafikleri çizebilmek için yapın:\n\nToplam Yolcu - Yıl grafiğini çizdirin. Aynı grafik üzeride iç hat yolcusu ve dış hat yolcusunun yıllara göre grafiği de olsun.\nToplam Yükün (Ton), iç hat yükünün (Ton) ve dış hat yükünün (Ton) yıllara göre grafiğini çizdirin.\n\n\n\n\nProblem 3\nBir veri çatısı (data frame) oluşturun ve aşağıdaki tablodaki verileri içine yerleştirin. Veri çatısının sütunları sırasıyla “Ad_Soyad”, “Yas”, “Cinsiyet”, “Meslek” olsun.\n\n\n\nAd_Soyad\nYas\nCinsiyet\nMeslek\n\n\n\n\nAli Yılmaz\n42\nErkek\nMühendis\n\n\nCanan Kaya\n35\nKadın\nDoktor\n\n\nEce Özer\n27\nKadın\nHukukçu\n\n\nFatma Yılmaz\n45\nKadın\nAvukat\n\n\nGamze Kaya\n32\nKadın\nMühendis\n\n\n\n\nVeri çatısının ilk 3 satırını yazdırın.\nVeri çatısının ad-soyad sütununu temelli olarak etikete (indexe) kaydedin, ve ekrana yazdırın.\nVeri çatısındaki kişilerin yaş ortalamasını hazır fonksiyon kullanarak hesaplayın ve ekrana yazdırın.\nYaşı 40’dan büyük olanların bilgilerini ekrana yazdırın.\n\n\n\nProblem 4\nBir fizik laboratuvarında, bir yayın esneklik sabiti ölçümü için deney yapılmıştır. Deney, bir dizi ağırlığın (\\(m_{1}\\), \\(m_{2}\\), \\(m_{3}\\), \\(\\dots\\)) yayın ucuna asılması ve her bir ağırlığın yayı uzatma miktarının ölçülmesiyle gerçekleştirilmiştir.\nVeriler, her bir ağırlığın yayın uzatma miktarı (kg biriminde) ve uygulanan kuvvetin (N biriminde) bir listesi olarak elde edilmiştir.\n\n\n\nKütle (kg)\nUzama, \\(\\Delta x\\) (m)\n\n\n\n\n0.1\n0.02\n\n\n0.2\n0.05\n\n\n0.3\n0.07\n\n\n0.4\n0.1\n\n\n0.5\n0.12\n\n\n\n\nBu verileri bir DataFrame’e kaydedin.\nHer kütle için yayın esneklik sabitini (\\(k\\) [N/m]) hesaplayın, (\\(k = F / \\Delta x\\)) ve DataFrame’e yeni sütun olarak ekleyin. (\\(g=9.81\\) \\(m/s^{2}\\))\nHer bir ağırlık için potansiyel enerjiyi hesaplayın (\\(E = 1/2 \\times k \\times x^{2}\\)) ve DataFrame’e yeni sütun olarak ekleyin.\nDataFrame’in son halinin ilk satırını ekrana yazdırın.\nDataFrame’in son halinin son satırını ekrana yazdırın.\nYatay eksende uzama (m), dikey eksende potansiyel enerji (J = N \\(\\times\\) m) olacak şekilde bir grafik oluşturun.\n\n\n\nProblem 5\nBu linkteki veri_bilgYont1_notlar.csv dosyasını indirin. Bu dosyada her bir öğrencinin ödevleri, quizleri, arasınav ve final notları bulunmaktadır. Bu dosyadaki veri kütüphanesini kullanarak aşağıdaki soruları cevaplayın.\n\nDosyayı pandas kütüphanesini kullanarak okuyun.\nVerinin ilk 5 satırını ekrana yazdırın.\nVerinin son 2 satırını ekrana yazdırın.\nVerinin sütunların isimlerini ekrana yazdırın.\n\nAşağıdaki işlemleri yapın ve değişkene atayın. Atadıktan sonra ilk 2 satırını ekrana yazdırın.\n\nEtiketleri ogrenci1, ogrenci2 … ogrenci14 gibi olacak şekilde değiştirin.\nHer bir öğrencinin ödevin ortalamasını bulun ve veri çatısında (data frame) bir sütun olarak kaydedin. Sütunun ismi OdevOrt olsun.\nHer bir öğrencinin quizlerinin ortalamasını bulun ve veri çatısında (data frame) bir sütun olarak kaydedin. Sütunun ismi QuizOrt olsun.\nHer bir öğrencinin dönem sonu ortalamasını bulun ve sütun ismi Ortalama olacak şekilde kaydedin. Dönem sonu ortalaması aşağıdaki gibi hesaplanır:\n\nQuizler %10\nÖdevler %20\nArasınav %30\nFinal %40\n\nHer bir öğrencinin harf sonu notunu, ortalamaya bakarak hesaplayın ve sütun ismi HarfNot olacak şekilde kaydedin. Harfli notlar aşağıdaki gibi hesaplanır:\n\n\n\n\nOrtalama\nHarf Notu\n\n\n\n\n90-100\nAA\n\n\n85-89\nBA\n\n\n80-84\nBB\n\n\n75-79\nCB\n\n\n70-74\nCC\n\n\n65-69\nDC\n\n\n60-64\nDD\n\n\n50-59\nEE\n\n\n0-49\nFF\n\n\n\n\nHer bir öğrencinin quizlerinin arasından en yüksek 5 notu seçin ve QuizOrtBoost sütunu olarak kaydedin. Her öğrencinin ortalamasını ve harf notunu QuizOrtBoost kullanarak hesaplayın.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Uygulama"
    ]
  },
  {
    "objectID": "icerik/izlence.html",
    "href": "icerik/izlence.html",
    "title": "İzlence",
    "section": "",
    "text": "Bu bölümde MSGSÜ Fizik Bölümü’nde verilen derslerin izlenceleri yer almaktadır.",
    "crumbs": [
      "**İçerik**",
      "İzlence"
    ]
  },
  {
    "objectID": "icerik/izlence.html#fiz366---fizikte-bilgisayarlı-yöntemler-ii",
    "href": "icerik/izlence.html#fiz366---fizikte-bilgisayarlı-yöntemler-ii",
    "title": "İzlence",
    "section": "FIZ366 - Fizikte Bilgisayarlı Yöntemler II",
    "text": "FIZ366 - Fizikte Bilgisayarlı Yöntemler II\n\n2023-2024 Bahar Dönemi\n\nÖğretim Üyesi: Taygun Bulmuş\nE-posta: taygun.bulmus@msgsu.edu.tr\nDers Gün ve Saatleri: Salı 09:00-12:00\nUygulama Gün ve Saatleri: Cuma 15:00-17:00 (MS Teams)\nNotlandımra: İki Vize (%20 + %20), Quizler ve Ödevler (%20), Final (%40)\n\nDers İçeriği:\n\nAdi Diferansiyel Denklemler - Başlangıç Değer Problemleri\nAdi Diferansiyel Denklemler - Sınır Değer Problemleri\nFourier Analizi\nPandas Kütüphanesi\nVeri İşleme ve Analizi\nTemel İstatistik ve Olasılık\n\n\n\n\n\n\n\nUyarı\n\n\n\nKonuların işleyiş sırası değişebilir. Dönem içerisinde konu eklenebilir verya çıkarılabilir.\n\n\nKaynaklar:\n\nBilgisayarlı Yöntemler Github Sitesi, https://bulmust.github.io/bilgisayarli-yontemler/\n\n\n\n\n\n\n\nNot\n\n\n\nKullanılacak kaynaklar, notların altına eklenecektir.",
    "crumbs": [
      "**İçerik**",
      "İzlence"
    ]
  },
  {
    "objectID": "icerik/izlence.html#fiz365---fizikte-bilgisayarlı-yöntemler-i",
    "href": "icerik/izlence.html#fiz365---fizikte-bilgisayarlı-yöntemler-i",
    "title": "İzlence",
    "section": "FIZ365 - Fizikte Bilgisayarlı Yöntemler I",
    "text": "FIZ365 - Fizikte Bilgisayarlı Yöntemler I\n\n2022-2023 Güz Dönemi\n\nÖğretim Üyesi: Taygun Bulmuş\nE-posta: taygun.bulmus@msgsu.edu.tr\nDers Gün ve Saatleri: Cuma 13:00-16:00\nUygulama Gün ve Saatleri: Cuma 16:00-18:00\nOfis Saatleri: Cuma 10:00-12:00\nNotlandımra: İki Vize (%20 + %20), Quizler (%10), Ödevler (%10), Final (%40)\n\nDers İçeriği:\n\nDersin Tanıtımı, Python ile Programlamaya Giriş\nTemel Python Programlama - I\nTemel Python Programlama - II\nNumpy-Scipy-Matplotlib\nArasınav - I\nDoğrusal Denklem Sistemleri - I\nDoğrusal Denklem Sistemleri - II\nİnterpolasyon\nEğri Uydurma\nArasınav - II\nKök Bulma\nSayısal Türev Alma\nSayısal İntegral Alma\nAdi Diferansiyel Denklemler\n\n\n\n\n\n\n\n\nUyarı\n\n\n\nKonuların işleyiş sırası değişebilir. Dönem içerisinde konu eklenebilir verya çıkarılabilir.\n\n\nKaynaklar:\n\nNumerical Methods in Engineering with Python 3, Jaan Kiusalaas, Cambridge University Press, 2013,\nIntroduction to Engineering and Scientific Computing with Python, David E. Clough, Steven C. Chapra, 1. Baskı, 2022,\nSayısal Analiz ve Mühendislik Uygulamaları, İrfan Karagöz, 5. Baskı, 2019.",
    "crumbs": [
      "**İçerik**",
      "İzlence"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html",
    "title": "pandas - Veri Manipülasyonu",
    "section": "",
    "text": "Şuana kadar öğrendiğimiz komutların bir listesinini yazalım.\n# Seriler\ns= pd.Series([100, 200, 300, 400, 500]\\\n    ,index= [\"Londra\", \"Paris\", \"Roma\", \"Berlin\", \"Oslo\"])\ns.index\ns.values\ns.name\n# Seri Satırı (index)\ns[\"Londra\"]\ns.Londra\ns.describe()\ns.max()\ns.min()\ns.std()\ns.mean()\ns.median()\ns.info()\ns.plot(kind= 'line'), # bar, barh, pie\nprint(\"---o---o---o---\")\n# DataFrame'ler\ndf= pd.DataFrame({\n    \"Şehir\": [\"Londra\", \"Paris\", \"Roma\", \"Berlin\", \"Oslo\"],\n    \"Nüfus\": [100, 200, 300, 400, 500],\n    \"Alan\": [1000, 2000, 3000, 4000, 5000]\n})\ndf.columns\ndf[\"Nüfus\"] #! Sütun İsmi\ndf[[\"Nüfus\",\"Şehir\"]]\ndf.Nüfus #! Türkçe karakter kullanma, Sütun ismi\ndf.loc[0] # Satır ismi (etiket, index) olmadığı için 0\ndf.loc[[0, 1]] # Satır ismi (etiket, index) olmadığı için 0,1\ndf.rename(columns= {\"Nüfus\" : \"Nüfuslar\"})\ndf.info()",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#pandas-modülü-tekrar",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#pandas-modülü-tekrar",
    "title": "pandas - Veri Manipülasyonu",
    "section": "",
    "text": "Şuana kadar öğrendiğimiz komutların bir listesinini yazalım.\n# Seriler\ns= pd.Series([100, 200, 300, 400, 500]\\\n    ,index= [\"Londra\", \"Paris\", \"Roma\", \"Berlin\", \"Oslo\"])\ns.index\ns.values\ns.name\n# Seri Satırı (index)\ns[\"Londra\"]\ns.Londra\ns.describe()\ns.max()\ns.min()\ns.std()\ns.mean()\ns.median()\ns.info()\ns.plot(kind= 'line'), # bar, barh, pie\nprint(\"---o---o---o---\")\n# DataFrame'ler\ndf= pd.DataFrame({\n    \"Şehir\": [\"Londra\", \"Paris\", \"Roma\", \"Berlin\", \"Oslo\"],\n    \"Nüfus\": [100, 200, 300, 400, 500],\n    \"Alan\": [1000, 2000, 3000, 4000, 5000]\n})\ndf.columns\ndf[\"Nüfus\"] #! Sütun İsmi\ndf[[\"Nüfus\",\"Şehir\"]]\ndf.Nüfus #! Türkçe karakter kullanma, Sütun ismi\ndf.loc[0] # Satır ismi (etiket, index) olmadığı için 0\ndf.loc[[0, 1]] # Satır ismi (etiket, index) olmadığı için 0,1\ndf.rename(columns= {\"Nüfus\" : \"Nüfuslar\"})\ndf.info()",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#veri-çekme",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#veri-çekme",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Veri Çekme",
    "text": "Veri Çekme\npandas modülü ile bir dosyadaki veriyi okuyabildiğimiz gibi bir internet sitesinden de veriyi çekebiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\nprint(df)\n\n     Rank        City            State Population Date of census/estimate\n0       1   London[2]   United Kingdom  8,615,246             1 June 2014\n1       2      Berlin          Germany  3,437,916             31 May 2014\n2       3      Madrid            Spain  3,165,235          1 January 2014\n3       4        Rome            Italy  2,872,086       30 September 2014\n4       5       Paris           France  2,273,305          1 January 2013\n..    ...         ...              ...        ...                     ...\n100   101        Bonn          Germany    309,869        31 December 2012\n101   102       Malmö           Sweden    309,105           31 March 2013\n102   103  Nottingham   United Kingdom    308,735            30 June 2012\n103   104    Katowice           Poland    308,269            30 June 2012\n104   105      Kaunas        Lithuania    306,888          1 January 2013\n\n[105 rows x 5 columns]",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#başlık-değiştirme",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#başlık-değiştirme",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Başlık Değiştirme",
    "text": "Başlık Değiştirme\nŞimdi df veri çerçevesinin “Rank” başlığını “Ranks” yapalım.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Sütunlar\nprint(df.columns)\n# Sütun ismi değiştirme\ndf= df.rename(columns={'Rank':'Ranks'})\nprint(df.columns)\n\nIndex(['Rank', 'City', 'State', 'Population', 'Date of census/estimate'], dtype='object')\nIndex(['Ranks', 'City', 'State', 'Population', 'Date of census/estimate'], dtype='object')\n\n\nAynı işlemi inplace=True ile de yapabiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\ndf.rename(columns={'Ranks':'Rank'}, inplace=True)\nprint(df.columns)\n\nIndex(['Rank', 'City', 'State', 'Population', 'Date of census/estimate'], dtype='object')\n\n\nInplace işlemi veri çerçevesi ile yapılan işlemlerin çoğunda bulunur. Her seferinde df=df. ... şeklinde yazmak yerine inplace=True yazabiliriz.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#başını-ve-sonunu-gösterme",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#başını-ve-sonunu-gösterme",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Başını ve Sonunu Gösterme",
    "text": "Başını ve Sonunu Gösterme\nÇok büyük veriye sahip veri çerçevesinin içeriğine göz atmak için head ve tail komutlarını kullanırız.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# ilk 5 satırı göster\nprint(df.head())\nprint(\"---o---o---o---\")\n# son 5 satırı göster\nprint(df.tail())\nprint(\"---o---o---o---\")\n# ilk 7 satırı göster\ndf.head(7)\n\n   Rank       City            State Population Date of census/estimate\n0     1  London[2]   United Kingdom  8,615,246             1 June 2014\n1     2     Berlin          Germany  3,437,916             31 May 2014\n2     3     Madrid            Spain  3,165,235          1 January 2014\n3     4       Rome            Italy  2,872,086       30 September 2014\n4     5      Paris           France  2,273,305          1 January 2013\n---o---o---o---\n     Rank        City            State Population Date of census/estimate\n100   101        Bonn          Germany    309,869        31 December 2012\n101   102       Malmö           Sweden    309,105           31 March 2013\n102   103  Nottingham   United Kingdom    308,735            30 June 2012\n103   104    Katowice           Poland    308,269            30 June 2012\n104   105      Kaunas        Lithuania    306,888          1 January 2013\n---o---o---o---\n\n\n\n\n\n\n\n\n\n\nRank\nCity\nState\nPopulation\nDate of census/estimate\n\n\n\n\n0\n1\nLondon[2]\nUnited Kingdom\n8,615,246\n1 June 2014\n\n\n1\n2\nBerlin\nGermany\n3,437,916\n31 May 2014\n\n\n2\n3\nMadrid\nSpain\n3,165,235\n1 January 2014\n\n\n3\n4\nRome\nItaly\n2,872,086\n30 September 2014\n\n\n4\n5\nParis\nFrance\n2,273,305\n1 January 2013\n\n\n5\n6\nBucharest\nRomania\n1,883,425\n20 October 2011\n\n\n6\n7\nVienna\nAustria\n1,794,770\n1 January 2015",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#satır-sütunlara-numpy-arrayi-gibi-erişim",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#satır-sütunlara-numpy-arrayi-gibi-erişim",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Satır Sütunlara numpy array’i gibi Erişim",
    "text": "Satır Sütunlara numpy array’i gibi Erişim\npandas veri çerçevesine numpy array’i gibi erişmek de mümkün. Bunun için iloc komutunu kullanırız.,\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# ilk 5 satırı göster\nprint(df.head())\nprint(\"---o---o---o---\")\n# mat1= np.array([[1,2],[3,4]])\n# mat1[1,0] -&gt; 3\nprint(df.iloc[2,3])\nprint(\"---o---o---o---\")\nprint(df.iloc[0:2,1:3])\n\n   Rank       City            State Population Date of census/estimate\n0     1  London[2]   United Kingdom  8,615,246             1 June 2014\n1     2     Berlin          Germany  3,437,916             31 May 2014\n2     3     Madrid            Spain  3,165,235          1 January 2014\n3     4       Rome            Italy  2,872,086       30 September 2014\n4     5      Paris           France  2,273,305          1 January 2013\n---o---o---o---\n3,165,235\n---o---o---o---\n        City            State\n0  London[2]   United Kingdom\n1     Berlin          Germany",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#boyut-öğrenme",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#boyut-öğrenme",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Boyut Öğrenme",
    "text": "Boyut Öğrenme\nTıpkı numpy’da olduğu gibi burada da shape komutu ile veri çerçevesinin boyutunu öğrenebiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Boyut göster\ndf.shape\n\n(105, 5)",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#yeni-sütun-ekleme-ve-silme",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#yeni-sütun-ekleme-ve-silme",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Yeni Sütun Ekleme ve Silme",
    "text": "Yeni Sütun Ekleme ve Silme\nVeri çerçevesinde yeni bir sütun eklemek için df[\"Yeni Sütun\"] şeklinde bir komut kullanırız.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# NumericPopulation sütunu ekleyelim. İçerisine Population sütununu kopyalayalım.\ndf[\"NumericPopulation\"]= df[\"Population\"]\nprint(df.head())\n\n   Rank       City            State Population Date of census/estimate  \\\n0     1  London[2]   United Kingdom  8,615,246             1 June 2014   \n1     2     Berlin          Germany  3,437,916             31 May 2014   \n2     3     Madrid            Spain  3,165,235          1 January 2014   \n3     4       Rome            Italy  2,872,086       30 September 2014   \n4     5      Paris           France  2,273,305          1 January 2013   \n\n  NumericPopulation  \n0         8,615,246  \n1         3,437,916  \n2         3,165,235  \n3         2,872,086  \n4         2,273,305  \n\n\nVeri çerçevesinden bir sütunuu silmek için df.drop(\"Sütun İsmi\", axis=1) komutunu veya df.pop(\"Sütun İsmi\"), bir satırı silmek için df.drop(\"İndex İsmi\", axis=0) komutunu kullanırız.\n\ndf.pop komutu veri çerçevesini değiştirirken df.drop komutu veri çerçevesini değiştirmez, değişikliği görmek için inplace=True eklememiz gerekir.\naxis=0 varsayılan değerdir. Bu yüzden axis=0 yazmamıza gerek yoktur.\n\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Sütun isimlerini göster\nprint(df.columns)\nprint(\"---o---o---o---\")\n# Population sütununu sil\ndf.drop(\"Population\", axis=1, inplace=True)\n#df.pop(\"Population\") # &lt;----- bu da aynı işi yapar\nprint(df.columns)\nprint(\"---o---o---o---\")\nprint(df.head())\nprint(\"---o---o---o---\")\nprint(df.drop(0, axis=0).head(3))\nprint(\"---o---o---o---\")\nprint(df.head())\n\nIndex(['Rank', 'City', 'State', 'Population', 'Date of census/estimate'], dtype='object')\n---o---o---o---\nIndex(['Rank', 'City', 'State', 'Date of census/estimate'], dtype='object')\n---o---o---o---\n   Rank       City            State Date of census/estimate\n0     1  London[2]   United Kingdom             1 June 2014\n1     2     Berlin          Germany             31 May 2014\n2     3     Madrid            Spain          1 January 2014\n3     4       Rome            Italy       30 September 2014\n4     5      Paris           France          1 January 2013\n---o---o---o---\n   Rank    City     State Date of census/estimate\n1     2  Berlin   Germany             31 May 2014\n2     3  Madrid     Spain          1 January 2014\n3     4    Rome     Italy       30 September 2014\n---o---o---o---\n   Rank       City            State Date of census/estimate\n0     1  London[2]   United Kingdom             1 June 2014\n1     2     Berlin          Germany             31 May 2014\n2     3     Madrid            Spain          1 January 2014\n3     4       Rome            Italy       30 September 2014\n4     5      Paris           France          1 January 2013",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#biricik-unique-değerler",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#biricik-unique-değerler",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Biricik (Unique) Değerler",
    "text": "Biricik (Unique) Değerler\nunique komutu ile bir sütunun içindeki değerlerin biricik (unique) değerlerini görebiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# State sütunundaki değerler\nprint(df[\"State\"].values)\nprint(\"---o---o---o---\")\n# State sütunundaki biricik değerler\nprint(df[\"State\"].unique())\n\n[' United Kingdom' ' Germany' ' Spain' ' Italy' ' France' ' Romania'\n ' Austria' ' Germany' ' Hungary' ' Poland' ' Spain' ' Germany' ' Italy'\n ' Bulgaria' ' Czech Republic' ' Belgium' ' United Kingdom' ' Germany'\n ' Italy' ' Sweden' ' Italy' ' France' ' Netherlands' ' Croatia' ' Spain'\n ' Poland' ' United Kingdom' ' Poland' ' Germany' ' Latvia' ' Spain'\n ' Italy' ' Spain' ' Greece' ' Poland' ' Netherlands' ' Finland'\n ' Germany' ' United Kingdom' ' Italy' ' Germany' ' Germany' ' Germany'\n ' Spain' ' Denmark' ' United Kingdom' ' Portugal' ' Poland' ' Germany'\n ' Lithuania' ' Germany' ' Germany' ' Sweden' ' Ireland' ' United Kingdom'\n ' Germany' ' Netherlands' ' United Kingdom' ' Belgium' ' United Kingdom'\n ' Germany' ' Germany' ' France' ' United Kingdom' ' Poland' ' France'\n ' Spain' ' Estonia' ' United Kingdom' 'Slovakia Slovak Republic'\n ' Poland' ' Spain' ' Italy' ' Spain' ' Italy' ' Czech Republic' ' Poland'\n ' Germany' ' Spain' ' United Kingdom' ' Poland' ' France' ' Germany'\n ' Bulgaria' ' Bulgaria' ' Spain' ' United Kingdom' ' Netherlands'\n ' Spain' ' Germany' ' United Kingdom' ' Denmark' ' Romania'\n ' United Kingdom' ' Italy' ' Greece' ' United Kingdom' ' Romania'\n ' Italy' ' Spain' ' Germany' ' Sweden' ' United Kingdom' ' Poland'\n ' Lithuania']\n---o---o---o---\n[' United Kingdom' ' Germany' ' Spain' ' Italy' ' France' ' Romania'\n ' Austria' ' Hungary' ' Poland' ' Bulgaria' ' Czech Republic' ' Belgium'\n ' Sweden' ' Netherlands' ' Croatia' ' Latvia' ' Greece' ' Finland'\n ' Denmark' ' Portugal' ' Lithuania' ' Ireland' ' Estonia'\n 'Slovakia Slovak Republic']",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#biricik-değerlerin-sayısı",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#biricik-değerlerin-sayısı",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Biricik Değerlerin Sayısı",
    "text": "Biricik Değerlerin Sayısı\nvalue_counts() komutu ile bir sütunun içindeki değerlerin biricik (unique) değerlerinin sayısını görebiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# State sütunundaki biricik değerlerin sayısı\nprint(df[\"State\"].value_counts())\n\nState\n Germany                    19\n United Kingdom             16\n Spain                      13\n Poland                     10\n Italy                      10\n France                      5\n Netherlands                 4\n Bulgaria                    3\n Sweden                      3\n Romania                     3\n Czech Republic              2\n Belgium                     2\n Greece                      2\n Denmark                     2\n Lithuania                   2\n Hungary                     1\n Austria                     1\n Croatia                     1\n Latvia                      1\n Finland                     1\n Portugal                    1\n Ireland                     1\n Estonia                     1\nSlovakia Slovak Republic     1\nName: count, dtype: int64",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#tekrar-eden-değerler",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#tekrar-eden-değerler",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Tekrar Eden Değerler",
    "text": "Tekrar Eden Değerler\nduplicated komutu ile bir sütunun içindeki değerlerin tekrarlanan değerlerini görebiliriz. Bu komutun sonucunda True ve False değerleri döner.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# State sütunundaki tekrar eden değerler\nprint(df[\"State\"].duplicated().head(8))\nprint(\"---o---o---o---\")\n# State sütunundaki ilk 8 değer\nprint(df.State.head(8))\n\n0    False\n1    False\n2    False\n3    False\n4    False\n5    False\n6    False\n7     True\nName: State, dtype: bool\n---o---o---o---\n0     United Kingdom\n1            Germany\n2              Spain\n3              Italy\n4             France\n5            Romania\n6            Austria\n7            Germany\nName: State, dtype: object",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#veri-manipülasyonu-ve-veri-temizleme",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#veri-manipülasyonu-ve-veri-temizleme",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Veri Manipülasyonu ve Veri Temizleme",
    "text": "Veri Manipülasyonu ve Veri Temizleme\nElimize geçen veride sistematik olarak değiştirmemiz gereken bazı durumlar olabilir. Bu tip veriye ham veri adı verilir. Ham veri içerisinde istenmeyen veya yanlış satırlar, yanlış yazılmış sütunlar olabilir. Bunun gibi kusurları temizlemek ve üzerine çalışılabilir bir hale getirmek için manipüle (oynama) yapmamız gerekir.\nBunun için df değişkenine tekrar bakalım.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# İlk 3 satırı göster\nprint(df.head(3))\nprint(\"---o---o---o---\")\n# Veri hakkında bilgi\nprint(df.info())\nprint(\"---o---o---o---\")\n# State sütunundaki ilk 3 değer\nprint(df[\"State\"].head(3).values)\n\n   Rank       City            State Population Date of census/estimate\n0     1  London[2]   United Kingdom  8,615,246             1 June 2014\n1     2     Berlin          Germany  3,437,916             31 May 2014\n2     3     Madrid            Spain  3,165,235          1 January 2014\n---o---o---o---\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 105 entries, 0 to 104\nData columns (total 5 columns):\n #   Column                   Non-Null Count  Dtype \n---  ------                   --------------  ----- \n 0   Rank                     105 non-null    int64 \n 1   City                     105 non-null    object\n 2   State                    105 non-null    object\n 3   Population               105 non-null    object\n 4   Date of census/estimate  105 non-null    object\ndtypes: int64(1), object(4)\nmemory usage: 4.2+ KB\nNone\n---o---o---o---\n[' United Kingdom' ' Germany' ' Spain']\n\n\nİlk bakışta görülen kusurlar şunlardır:\n\n0. indexe sahip olan satırda London [2] yazılmış.\nPopulation sütunu sayı olması gerekirken object olarak kaydedilmiş. Yani string olarak kaydedilmiş.\nState sütunundaki verilerin başında bir adet fazladan boşluk var.\n\nBu sorunları sırasıyla çözelim.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n## 1.\ndf.iloc[0,1]= \"London\"\nprint(df.loc[0])\nprint(\"---o---o---o---\")\n## 2.\n## Aşağıdaki komut çalışmıyor çünkü python virgüllü sayıları noktaya çeviremiyor.\n#df[\"Population\"]= df[\"Population\"].astype(float)\n# Tüm virgülleri kaldıralım ve float tipine çevirelim.\ndf[\"Population\"]=df.Population.apply(lambda x: int(x.replace(',','')))\n# str1='Naber Gizem'\n# print(str1.replace('G',''))\nprint(df.info())\nprint(\"---o---o---o---\")\nprint(df.head())\nprint(\"---o---o---o---\")\n## 3.\nprint(df[\"State\"].head(3).values)\nprint(\"---o---o---o---\")\n# strip() fonksiyonu stringin başındaki ve sonundaki boşlukları siler.\ndf.State= df.State.apply(lambda x: x.strip())\n# Göster\nprint(df[\"State\"].head(3).values)\n\nRank                                     1\nCity                                London\nState                       United Kingdom\nPopulation                       8,615,246\nDate of census/estimate        1 June 2014\nName: 0, dtype: object\n---o---o---o---\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 105 entries, 0 to 104\nData columns (total 5 columns):\n #   Column                   Non-Null Count  Dtype \n---  ------                   --------------  ----- \n 0   Rank                     105 non-null    int64 \n 1   City                     105 non-null    object\n 2   State                    105 non-null    object\n 3   Population               105 non-null    int64 \n 4   Date of census/estimate  105 non-null    object\ndtypes: int64(2), object(3)\nmemory usage: 4.2+ KB\nNone\n---o---o---o---\n   Rank    City            State  Population Date of census/estimate\n0     1  London   United Kingdom     8615246             1 June 2014\n1     2  Berlin          Germany     3437916             31 May 2014\n2     3  Madrid            Spain     3165235          1 January 2014\n3     4    Rome            Italy     2872086       30 September 2014\n4     5   Paris           France     2273305          1 January 2013\n---o---o---o---\n[' United Kingdom' ' Germany' ' Spain']\n---o---o---o---\n['United Kingdom' 'Germany' 'Spain']\n\n\nVeri çerçevesindeki verilerin ilk harflerini df.State.str.capitalize() ile büyük yapabiliriz.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#etiket-index-işlemleri",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#etiket-index-işlemleri",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Etiket (Index) İşlemleri",
    "text": "Etiket (Index) İşlemleri\nKullandığımız veri çerçevesinde etiket bulunmuyor. Tüm veri şehirler üzerine kurulu olduğu için şehirleri etiket olarak alabiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Etiket ismini City'nin değerleri olarak ata\ndf.index= df[\"City\"]\n# Göster\ndf.head()\n\n\n\n\n\n\n\n\n\nRank\nCity\nState\nPopulation\nDate of census/estimate\n\n\nCity\n\n\n\n\n\n\n\n\n\nLondon[2]\n1\nLondon[2]\nUnited Kingdom\n8,615,246\n1 June 2014\n\n\nBerlin\n2\nBerlin\nGermany\n3,437,916\n31 May 2014\n\n\nMadrid\n3\nMadrid\nSpain\n3,165,235\n1 January 2014\n\n\nRome\n4\nRome\nItaly\n2,872,086\n30 September 2014\n\n\nParis\n5\nParis\nFrance\n2,273,305\n1 January 2013\n\n\n\n\n\n\n\n\nBaşlıklara bakarsak etiket isminin de City olduğunu görebiliriz. Etiket ismi ile sütun ismi ayrışması adına etiket ismi alt satıra yazılmıştır.\nEtiketleri df.index ile de görebildiğimizi hatırlatalım.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Etiket ismini City'nin değerleri olarak ata\ndf.index= df[\"City\"]\n# Rank sütununu göster. Etiketler de gözükecek.\nprint(df.Rank.head())\nprint(\"---o---o---o---\")\n# Etiketleri göster ve listeye çevir\nprint(list(df.head().index))\n\nCity\nLondon[2]    1\nBerlin       2\nMadrid       3\nRome         4\nParis        5\nName: Rank, dtype: int64\n---o---o---o---\n['London[2]', 'Berlin', 'Madrid', 'Rome', 'Paris']\n\n\nEtiket grubunun ismini yani başlığını df.index.name ile görebiliriz/değiştirebiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Etiket ismini City'nin değerleri olarak ata\ndf.index= df[\"City\"]\n# Etiket isimlerini None yap\ndf.index.name= 'EtiketIsmi'\n#$ Etiket ismini sıfırla\n#df.index.name= None\n# Göster\ndf.head()\nprint(\"---o---o---o---\")\n# Tüm etiketleri göster\nprint(df.head().index)\n\n---o---o---o---\nIndex(['London[2]', 'Berlin', 'Madrid', 'Rome', 'Paris'], dtype='object', name='EtiketIsmi')\n\n\nreset_index() komutu ile etiketleri varsayılan numaralara geri döndürebiliriz. Bu komut etiketleri numaraya döndürürken, kayıtlı olan etiketleri de yeni bir sütun olarak ekler.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Etiket ismini City State sütunlarının değerlerinin toplamı olarak ata\ndf.index= df[\"City\"]+ \" \" + df[\"State\"]\n# Göstpd.Int16Dtype(er)\nprint(df.head())\n# Etiketleri sıfırla\ndf=df.reset_index()\nprint(\"---o---o---o---\")\nprint(df.head())\n\n                           Rank       City            State Population  \\\nLondon[2]  United Kingdom     1  London[2]   United Kingdom  8,615,246   \nBerlin  Germany               2     Berlin          Germany  3,437,916   \nMadrid  Spain                 3     Madrid            Spain  3,165,235   \nRome  Italy                   4       Rome            Italy  2,872,086   \nParis  France                 5      Paris           France  2,273,305   \n\n                          Date of census/estimate  \nLondon[2]  United Kingdom             1 June 2014  \nBerlin  Germany                       31 May 2014  \nMadrid  Spain                      1 January 2014  \nRome  Italy                     30 September 2014  \nParis  France                      1 January 2013  \n---o---o---o---\n                       index  Rank       City            State Population  \\\n0  London[2]  United Kingdom     1  London[2]   United Kingdom  8,615,246   \n1            Berlin  Germany     2     Berlin          Germany  3,437,916   \n2              Madrid  Spain     3     Madrid            Spain  3,165,235   \n3                Rome  Italy     4       Rome            Italy  2,872,086   \n4              Paris  France     5      Paris           France  2,273,305   \n\n  Date of census/estimate  \n0             1 June 2014  \n1             31 May 2014  \n2          1 January 2014  \n3       30 September 2014  \n4          1 January 2013",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#sıralama",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#sıralama",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Sıralama",
    "text": "Sıralama\nTüm veriyi etiket isimlerine göre sıralayabiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Etiket ismini City'nin değerleri olarak ata\ndf.index= df[\"City\"]\n# Göster\ndf.head()\nprint(\"---o---o---o---\")\n# Tüm veriyi etiket isimlerine göre sırala\ndf= df.sort_index()\n# Göster\ndf.head()\n\n---o---o---o---\n\n\n\n\n\n\n\n\n\n\nRank\nCity\nState\nPopulation\nDate of census/estimate\n\n\nCity\n\n\n\n\n\n\n\n\n\nAarhus\n92\nAarhus\nDenmark\n326,676\n1 October 2014\n\n\nAlicante\n86\nAlicante\nSpain\n334,678\n1 January 2012\n\n\nAmsterdam\n23\nAmsterdam\nNetherlands\n813,562\n31 May 2014\n\n\nAntwerp\n59\nAntwerp\nBelgium\n510,610\n1 January 2014\n\n\nAthens\n34\nAthens\nGreece\n664,046\n24 May 2011\n\n\n\n\n\n\n\n\nTüm veriyi belirlediğimiz sütuna göre sıralayabiliriz.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Etiket ismini City'nin değerleri olarak ata\ndf.index= df[\"City\"]\n# Göster\ndf.head()\nprint(\"---o---o---o---\")\n# Tüm veriyi belirlediğimiz sütuna, Rank süttununa göre sırala\ndf.sort_values(by=\"Rank\", ascending=False, inplace=True)\n# Göster\ndf.head()\n\n---o---o---o---\n\n\n\n\n\n\n\n\n\n\nRank\nCity\nState\nPopulation\nDate of census/estimate\n\n\nCity\n\n\n\n\n\n\n\n\n\nKaunas\n105\nKaunas\nLithuania\n306,888\n1 January 2013\n\n\nKatowice\n104\nKatowice\nPoland\n308,269\n30 June 2012\n\n\nNottingham\n103\nNottingham\nUnited Kingdom\n308,735\n30 June 2012\n\n\nMalmö\n102\nMalmö\nSweden\n309,105\n31 March 2013\n\n\nBonn\n101\nBonn\nGermany\n309,869\n31 December 2012",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#multi-index",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#multi-index",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Multi-Index",
    "text": "Multi-Index\nVeri çerçevesindeki veriyi gruplayabiliriz. Örneğin etiketlerde hem ülkeler, hem de o ülkelere ait olan şehirler olsun. Yani iki adet etiket olsun. set_index komutu ile etiketleri belirlerken iki sütun olarak girelim.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# 2 adet etiket kullan.\n# 1. City'nin değerleri\n# 2. State'nin değerleri\ndf.set_index([\"State\", \"City\"], inplace=True)\nprint(\"2 adet etiketli veri çerçevesi\")\nprint(df.head())\nprint(\"---o---o---o---\")\n# 2 etiketli dataframi 0. etikete göre sırala\nprint(\"2 adet etiketli veri çerçevesi, 0. etikete göre sırala\")\nprint(df.sort_index(level=0).head())\nprint(\"---o---o---o---\")\n# 2 etiketli dataframi 1. etikete göre sırala\nprint(\"2 adet etiketli veri çerçevesi, 1. etikete göre sırala\")\nprint(df.sort_index(level=1).head())\nprint(\"---o---o---o---\")\n# 2 etiketli dataframi 0. etikete göre sırala ve Sweden olanları göster\n\n2 adet etiketli veri çerçevesi\n                          Rank Population Date of census/estimate\nState          City                                              \nUnited Kingdom London[2]     1  8,615,246             1 June 2014\nGermany        Berlin        2  3,437,916             31 May 2014\nSpain          Madrid        3  3,165,235          1 January 2014\nItaly          Rome          4  2,872,086       30 September 2014\nFrance         Paris         5  2,273,305          1 January 2013\n---o---o---o---\n2 adet etiketli veri çerçevesi, 0. etikete göre sırala\n                       Rank Population Date of census/estimate\nState    City                                                 \nAustria  Vienna           7  1,794,770          1 January 2015\nBelgium  Antwerp         59    510,610          1 January 2014\n         Brussels[17]    16  1,175,831          1 January 2014\nBulgaria Plovdiv         84    341,041        31 December 2013\n         Sofia           14  1,291,895        14 December 2014\n---o---o---o---\n2 adet etiketli veri çerçevesi, 1. etikete göre sırala\n                       Rank Population Date of census/estimate\nState       City                                              \nDenmark     Aarhus       92    326,676          1 October 2014\nSpain       Alicante     86    334,678          1 January 2012\nNetherlands Amsterdam    23    813,562             31 May 2014\nBelgium     Antwerp      59    510,610          1 January 2014\nGreece      Athens       34    664,046             24 May 2011\n---o---o---o---\n\n\nİki adet etikete sahip veri çerçevesine erişmek için df.loc[\"Etiket1\", \"Etiket2\"] komutunu kullanırız.\n\nimport pandas as pd\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# 2 adet etiket kullan.\n# 1. City'nin değerleri\n# 2. State'nin değerleri\ndf.set_index([\"State\", \"City\"], inplace=True)\nprint(\"2 adet etiketli veri çerçevesi\")\nprint(df.head())\nprint(\"---o---o---o---\")\n# Germany olanı göster\nprint(\"Etiketi Germany olanı göster\")\n# Çalışmayan örnek:\n#print(df.loc[('Germany')])\nprint(df.loc[(' Germany')].head())\nprint(\"---o---o---o---\")\n# Germany, Berlin olanı göster\nprint(\"Etiketi Germany, Berlin olanları göster\")\nprint(df.loc[(' Germany', 'Berlin')])\n\n2 adet etiketli veri çerçevesi\n                          Rank Population Date of census/estimate\nState          City                                              \nUnited Kingdom London[2]     1  8,615,246             1 June 2014\nGermany        Berlin        2  3,437,916             31 May 2014\nSpain          Madrid        3  3,165,235          1 January 2014\nItaly          Rome          4  2,872,086       30 September 2014\nFrance         Paris         5  2,273,305          1 January 2013\n---o---o---o---\nEtiketi Germany olanı göster\n             Rank Population Date of census/estimate\nCity                                                \nBerlin          2  3,437,916             31 May 2014\nHamburg[10]     8  1,746,342        30 December 2013\nMunich         12  1,407,836        31 December 2013\nCologne        18  1,034,175        31 December 2013\nFrankfurt      29    701,350        31 December 2013\n---o---o---o---\nEtiketi Germany, Berlin olanları göster\nRank                                 2\nPopulation                   3,437,916\nDate of census/estimate    31 May 2014\nName: ( Germany, Berlin), dtype: object",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#toplama-işlemi",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#toplama-işlemi",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Toplama İşlemi",
    "text": "Toplama İşlemi\nVeri çerçevesindeki verileri df.sum() ile toplayabiliriz.\n\nimport pandas as pd\nimport numpy as np\n# Veri çekme\ndf= pd.read_csv('https://raw.githubusercontent.com/jrjohansson/numerical-python-book-code/master/european_cities.csv')\n# Population sütununu göster\nprint(df.Population.head())\nprint(\"---o---o---o---\")\n# Dtype göster\nprint(f\"Data tipi : {df.Population.dtype}\")\nprint(\"---o---o---o---\")\n# Population sütununu topla\nprint(df.Population.sum())\nprint(\"---o---o---o---\")\n# Tüm sütunları numpy ile topla\nprint(np.sum(df.Population.values))\n\n0    8,615,246\n1    3,437,916\n2    3,165,235\n3    2,872,086\n4    2,273,305\nName: Population, dtype: object\n---o---o---o---\nData tipi : object\n---o---o---o---\n8,615,2463,437,9163,165,2352,872,0862,273,3051,883,4251,794,7701,746,3421,744,6651,729,1191,602,3861,407,8361,332,5161,291,8951,246,7801,175,8311,092,3301,034,175989,845909,976898,095852,516813,562790,017786,424760,700757,655709,757701,350701,185696,676677,015666,058664,046632,432616,528605,523604,297596,550594,774593,682575,944569,884566,913559,440557,382547,631547,161546,451537,152531,562530,754528,014527,612524,619514,137510,909510,772510,610495,360495,121486,816484,344469,690460,354441,802441,354434,810432,451417,389409,211407,648384,202382,296377,207378,327362,286362,213351,629348,493348,120343,304342,885341,041335,819334,678331,606330,772328,841328,314327,627326,676324,576323,132322,751322,240320,229319,279315,576311,501309,869309,105308,735308,269306,888\n---o---o---o---\n8,615,2463,437,9163,165,2352,872,0862,273,3051,883,4251,794,7701,746,3421,744,6651,729,1191,602,3861,407,8361,332,5161,291,8951,246,7801,175,8311,092,3301,034,175989,845909,976898,095852,516813,562790,017786,424760,700757,655709,757701,350701,185696,676677,015666,058664,046632,432616,528605,523604,297596,550594,774593,682575,944569,884566,913559,440557,382547,631547,161546,451537,152531,562530,754528,014527,612524,619514,137510,909510,772510,610495,360495,121486,816484,344469,690460,354441,802441,354434,810432,451417,389409,211407,648384,202382,296377,207378,327362,286362,213351,629348,493348,120343,304342,885341,041335,819334,678331,606330,772328,841328,314327,627326,676324,576323,132322,751322,240320,229319,279315,576311,501309,869309,105308,735308,269306,888",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#neler-öğrendik",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#neler-öğrendik",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Neler Öğrendik?",
    "text": "Neler Öğrendik?\n# Seriler\ns= pd.Series()\ns.index\ns.values\ns.name\ns[\"Londra\"]\ns.Londra\ns.describe()\ns.max()\ns.min()\ns.std()\ns.mean()\ns.median()\ns.plot(kind= 'line')\ns.plot(kind= 'bar')\ns.plot(kind= 'barh')\ns.plot(kind= 'pie')\n# ----------------\ndf= pd.DataFrame()\ndf.columns\ndf[\"Nüfus\"] #! Sütunun İsmi\ndf.Nüfus #! Türkçe karakter kullanma, Sütunun ismi\ndf.loc[\"Londra\"] # Satır ismi\ndf.loc[[\"Londra\", \"Roma\"]]\ndf.rename(columns= {\"Nüfus\" : \"Nüfuslar\"})\ndf.info()\n# ----------------\ndf= pd.read_csv()\ndf.head()\ndf.tail()\ndf.loc[\"Etiket İsmi\"]\ndf.iloc[0]\ndf.iloc[1, 2]\ndf.shape\ndf[\"Yeni Sütun\"]\ndf[\"Sütun İsmi\"].unique()\ndf[\"Sütun İsmi\"].value_counts()\ndf[\"Sütun İsmi\"].duplicated()\ndf.drop(\"Sütun İsmi\", axis=1)\ndf.pop(\"Sütun İsmi\")\ndf.drop(\"Etiket İsmi\", axis=0)\ndf.Population.apply(lambda x: int(x.replace(',','')))\ndf.State.str.capitalize()\ndf.index.name\ndf.sort_index()\ndf.sort_values(by=\"Sütun İsmi\", ascending=True)\ndf.set_index([\"State\", \"City\"]).sort_index(level=0)\ndf.set_index([\"State\", \"City\"]).sort_index(level=1)\ndf.sum()",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#problemler",
    "href": "icerik/konular/veri-analizi/pandas-veri-manipulasyonu.html#problemler",
    "title": "pandas - Veri Manipülasyonu",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nhttps://www.kaggle.com/datasets/prithusharma1/all-nobel-laureates-1901-present sitesine gidin ve nobel ödülü almış kişiler ile ilgili veriyi indirin. Direkt indirmek için tıklayınız.\nVerileri pandas paketi ile okuyun.\nCinsiyetler sütununda (Gender) biricik (unique) değerleri bulun. Bunları bir diziye (array) atayın.\nBulduğunuz biricik değerlerden “Gender” sütununda kaç adet olduğunu bulun.\nÖdüllerin toplam cinsiyet (Gender) bar grafiğini çizdirin. plt.bar()\n“Birth_Country_Code” sütununda biricik değerleri bulmadan önce dropna() komutu ile nan değerlerini silin.\nÖdül alan kişilerin doğduğu ülkelerin (“Birth_Country_Code”) toplam sayısını gösteren bir bar grafiği çizdirin.\n\n\n\nProblem 2\n\nhttps://www.kaggle.com/datasets/abhinand05/daily-sun-spot-data-1818-to-2019 sitesine gidin ve Güneş lekesi verilerini indirin. Direkt indirmek için tıklayınız.\nVerileri pandas paketi ile okuyun.\nİlk sütunu (“Unnamed: 0”) silin.\n“Number of Sunspots” başlığındaki tüm \\(-1\\) olan terimleri np.nan ile değiştirin.\nYeni bir sütun oluşturun. Bu sütunun adı “Year-Month-Day” olsun. Bu sütuna yılları, ayları ve günleri içeren bir dize (string) yazın. Örneğin, “1818-01-01” gibi. Bunu yapabilmek için dize (string) tipine geçmeniz gerekmektedir. Örneğin df[\"Day\"].astype(str).\nGünlere göre kaç adet güneş lekesi olduğunu (“Number of Sunspots”) gösteren bir grafik çizdirin. Yatay eksende bir şey olmasın.\nYeni bir veri çatısı (dataframe) oluşturun. Bu veri çatısının etiketleri (indices) yıllar, sütunu ise o yıldaki toplam güneş lekesi sayısı olsun. df.groupby(\"Hangi sütunu gruplayacak\")[\"&lt;Hangi sütuna göre gruplanacak&gt;\"].sum() komutu ile gruplayabilirsiniz.\nYeni oluşturduğunuz veri çatısını çizdirin. Yaklaşık her 11 senede bir güneş lekesi sayısının arttığını gözlemleyebilirsiniz. Buna Solar döngü (Solar cycle) denir.",
    "crumbs": [
      "**Konular**",
      "Veri Analizi",
      "pandas - Veri Manipülasyonu"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler.html",
    "title": "Adi Diferansiyel Denklemler",
    "section": "",
    "text": "Aşağıdaki gibi bir adet diferansiyel denklem veya denklem sistemimiz olsun.\n\\[\n\\begin{equation}\n    \\frac{d}{dx}y(x) = F(x,y)\n\\end{equation}\n\\]\n\nBu denklemi çözmek demek sağ ve sol tarafın integralini almak demektir.\nBu denklemi çözmek demek sayısal olarak \\(y(x)\\) fonksiyonunu bulmak demektir. Yani istenilen bir x değeri için \\(y(x)\\) fonksiyonunun değerini elde ederiz.\n\\(y(x)\\) ve \\(F(x,y)\\) birer vektör olabilir. Örneğin \\(\\vec{y}(x) = (y_{1}(x), y_{2}(x))\\).\nİkinci dereceden diferansiyel denklemleri çözmek için denklemi iki adet birinci dereceden diferansiyel denkleme indirgeme yapmamız gerekmektedir.\n\n\\[\n\\begin{align*}\n    \\frac{d^{2}}{dx^{2}}y(x) =& F(x,y)\\\\\n    \\frac{d}{dx}y(x) =& v(x,y) \\qquad \\text{ve} \\qquad \\frac{d}{dx}v(x) = F(x,y)\n\\end{align*}\n\\]\n\nÇözüme başlamak için fonksiyonun başlangıçtaki değerine ihtiyacınız vardır; Başlangıç Değer Problemi, BDP (IVP)\nÇözümün sınırlarında hangi değerler aldığını bilerek de fonksiyonu elde edebiliriz; Sınır Değer Problemi, SDP (BVP)\n\n\n\n\nBaşlangıç değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(0)=0 \\text{.}\n\\]\n\nSınır değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(\\pi)=0 \\text{.}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler.html#adi-diferansiyel-denklemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler.html#adi-diferansiyel-denklemler",
    "title": "Adi Diferansiyel Denklemler",
    "section": "",
    "text": "Aşağıdaki gibi bir adet diferansiyel denklem veya denklem sistemimiz olsun.\n\\[\n\\begin{equation}\n    \\frac{d}{dx}y(x) = F(x,y)\n\\end{equation}\n\\]\n\nBu denklemi çözmek demek sağ ve sol tarafın integralini almak demektir.\nBu denklemi çözmek demek sayısal olarak \\(y(x)\\) fonksiyonunu bulmak demektir. Yani istenilen bir x değeri için \\(y(x)\\) fonksiyonunun değerini elde ederiz.\n\\(y(x)\\) ve \\(F(x,y)\\) birer vektör olabilir. Örneğin \\(\\vec{y}(x) = (y_{1}(x), y_{2}(x))\\).\nİkinci dereceden diferansiyel denklemleri çözmek için denklemi iki adet birinci dereceden diferansiyel denkleme indirgeme yapmamız gerekmektedir.\n\n\\[\n\\begin{align*}\n    \\frac{d^{2}}{dx^{2}}y(x) =& F(x,y)\\\\\n    \\frac{d}{dx}y(x) =& v(x,y) \\qquad \\text{ve} \\qquad \\frac{d}{dx}v(x) = F(x,y)\n\\end{align*}\n\\]\n\nÇözüme başlamak için fonksiyonun başlangıçtaki değerine ihtiyacınız vardır; Başlangıç Değer Problemi, BDP (IVP)\nÇözümün sınırlarında hangi değerler aldığını bilerek de fonksiyonu elde edebiliriz; Sınır Değer Problemi, SDP (BVP)\n\n\n\n\nBaşlangıç değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(0)=0 \\text{.}\n\\]\n\nSınır değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(\\pi)=0 \\text{.}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html",
    "href": "icerik/konular/istatistik/scipy-stats.html",
    "title": "scipy - stats",
    "section": "",
    "text": "Yaklaşık 13 kesiklik ve 98 sürekli dağılım scipy.stats modülünde bulunmaktadır. Daha ayrıntılı bilgi için scipy.stats dokümantasyonuna bakabilirsiniz.\nRastgele değişkenler classları için aşağıdaki örneği inceleyelim.\nfrom scipy import stats\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Normal Dağılım\nX= stats.norm(1, 0.5) # ortalama 1, standart sapma 0.5 olan normal dağılım\n\n# X bir obje\nprint(X)\n\n# X'in ortalama ve standart sapması\nprint(f\"\\nX ortalama: {X.mean()}, X standart sapma: {X.std()}\")\n\n# X'in medianı\nprint(f\"\\nX median: {X.median()}, Varyansı: {X.var()}\")\n\n# X dağılımının istatistiği, Birinci değer ortalaması, ikinci değer varyansı\nprint(f\"X.stats(): {X.stats()}\")\n\n# Pdf ve Cdf Fonksiyonları\nprint(f\"\\nPdf(x=0, x=1, x=2): {X.pdf([0,1,2])}\")\nprint(f\"\\nCDF(x=0, x=1, x=2): {X.cdf([0,1,2])}\")\n\n# PDF Fonksiyonunu çizelim\nx = np.linspace(-2, 4, 100)\nplt.title(\"Normal Dağılım\")\nplt.plot(x, X.pdf(x))\nplt.ylabel(\"PDF\")\nplt.show()\nplt.close()\n\n# CDF Fonksiyonunu çizelim\nx = np.linspace(-2, 4, 100)\nplt.title(\"Normal Dağılım\")\nplt.plot(x, X.cdf(x))\nplt.ylabel(\"CDF\")\nplt.show()\nplt.close()\n\n&lt;scipy.stats._distn_infrastructure.rv_continuous_frozen object at 0x7f2214aad720&gt;\n\nX ortalama: 1.0, X standart sapma: 0.5\n\nX median: 1.0, Varyansı: 0.25\nX.stats(): (1.0, 0.25)\n\nPdf(x=0, x=1, x=2): [0.10798193 0.79788456 0.10798193]\n\nCDF(x=0, x=1, x=2): [0.02275013 0.5        0.97724987]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#güven-aralığı-confidence-interval",
    "href": "icerik/konular/istatistik/scipy-stats.html#güven-aralığı-confidence-interval",
    "title": "scipy - stats",
    "section": "Güven Aralığı (Confidence Interval)",
    "text": "Güven Aralığı (Confidence Interval)\nGüven aralığı, bir parametrenin (genellikle bir ortalama veya oran) bilinmeyen gerçek değerinin bir tahmin aralığıdır. Bu tahmin aralığı, örneklem büyüklüğü, standart sapma ve güven seviyesi gibi faktörlere bağlı olarak hesaplanır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#alıştırma-1",
    "href": "icerik/konular/istatistik/scipy-stats.html#alıştırma-1",
    "title": "scipy - stats",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nÖrneğin, bir makinenin parçalarının ortalama uzunluğunu tahmin edelim. Makine parçalarının uzunluğunu normal dağılıma sahip olduğunu varsayalım.\n100 parçalı bir örneklemimiz olsun. Parçaların dağılımının ortalaması ile makinenin gerçek uzunluğunun tahminini yapabiliriz. Ancak, bu tek bir tahminin güvenilirliği hakkında bir fikir vermez. Bu nedenle, bir güven aralığı belirleyerek gerçek uzunluğun bu aralıkta olma olasılığını hesaplayabiliriz.\nÖrneklem ortalaması 7 cm ve standart sapma 0.5 cm olsun. Güven seviyesini %95 olarak belirlediğimizde, bir normal dağılım tablosu kullanarak ortalama uzunluğun %95 güven seviyesinde bulunabileceği aralığı hesaplayabiliriz.\n\nÖrneklemin büyüklüğüne (\\(n=100\\)), standart sapmasına (\\(\\sigma=0.5\\)) ve güven seviyesine (\\(\\alpha=0.05\\), %95 güven indeksi) ihtiyacımız var.\nZ-tablosu kullanarak, güven seviyesine karşılık gelen z-puanını bulun. Örneğin, %95 güven seviyesine karşılık gelen z-puanı 1.96’dır.\n\nZ-tablosu genellikle, standart normal dağılımın kuyruk altındaki alanını bulmak için kullanılır. Örneğin, bir z-değeri verildiğinde, z-tablosu kullanılarak, z-değerinin solundaki kuyruk altındaki alanın yüzdesi belirlenebilir.\nZ-tablosu, matematiksel hesaplama yapmadan kuyruk altındaki alanların bulunmasına yardımcı olduğu için çok kullanışlı bir araçtır. Ancak, tablonun doğru kullanılması için, normal dağılım varsayımı ve z-değerinin doğru hesaplanması gereklidir.\n\nÖrneklem ortalamasının standart hatasını hesaplayın.\n\nStandart hata, \\(\\sigma/\\sqrt{n} = 0.05\\) formülüyle hesaplanır.\nGüven aralığı, $ {x} z /$ formülüyle hesaplanır. Bu durumda, güven aralığı \\(7 \\pm 1.96 \\times (0.05) = 6.9, 7.1\\) olarak hesaplanır.\n\nBu hesaplama sonucu, güven aralığı (6.9 cm, 7.1 cm) olarak bulunur. Bu makine parçalarının gerçek uzunluğunu %95 güven seviyesinde bu aralıkta bulabileceği anlamına gelir.\n\nUzunluk = \\(7 \\pm 0.1\\)\n\nfrom scipy import stats\nX= stats.norm(7, 0.5) # ortalama 7, standart sapma 0.5 olan normal dağılım\n\n# interval ile 0.95 yüzdelikteki güven aralıklarını bulalım.\nprint(f\"%95 güven aralığı min: {X.interval(0.95)[0]}\")\nprint(f\"%95 güven aralığı max: {X.interval(0.95)[1]}\")\nprint(f\"Yani ortalama ort(X) = 7 ± {X.interval(0.95)[1]-X.interval(0.95)[0]}\")\nprint(\"-\"*20)\n# interval ile 0.999 yüzdelikteki güven aralıklarını bulalım.\nprint(f\"%95 güven aralığı min: {X.interval(0.999)[0]}\")\nprint(f\"%95 güven aralığı max: {X.interval(0.999)[1]}\")\nprint(f\"Yani ortalama ort(X) = 7 ± {X.interval(0.999)[1]-X.interval(0.999)[0]}\")\n\n%95 güven aralığı min: 6.020018007729973\n%95 güven aralığı max: 7.979981992270027\nYani ortalama ort(X) = 7 ± 1.9599639845400532\n--------------------\n%95 güven aralığı min: 5.354736634254053\n%95 güven aralığı max: 8.645263365745963\nYani ortalama ort(X) = 7 ± 3.2905267314919104",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#alıştırma-2",
    "href": "icerik/konular/istatistik/scipy-stats.html#alıştırma-2",
    "title": "scipy - stats",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\nŞimdi öğrendiğimiz tüm bu fonksiyonları Normal, Maxwell ve Poission dağılımları üzerinde görelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n# Büyük grafik çiz fonksiyonu\ndef plot_rv_distribution(X, axes=None):\n    #Plot the PDF or PMF, CDF, SF and PPF of a given random variable X\n    \n    # Aralıkları bul\n    x_min_999, x_max_999 = X.interval(0.999) \n    x_min_95, x_max_95 = X.interval(0.95)\n    # Aralıkların dizisini oluştur\n    x999 = np.linspace(x_min_999, x_max_999, 1000)\n    x95 = np.linspace(x_min_95, x_max_95, 1000)\n    # Eğer pdf çiziyorsan\n    if hasattr(X.dist, \"pdf\"):\n        axes[0].plot(x999, X.pdf(x999), label=\"PDF\")\n        axes[0].fill_between(x95, X.pdf(x95), alpha=0.25) # 0.95 güven aralığını tara\n    else: # Eğer pmf çiziyorsan\n        x999_int = np.unique(x999.astype(int))\n        axes[0].bar(x999_int, X.pmf(x999_int), label=\"PMF\")\n    # CDF Grafiği\n    axes[1].plot(x999, X.cdf(x999), label=\"CDF\")\n    # SF Grafiği (Aynı CDF Grafiğinde)\n    axes[1].plot(x999, X.sf(x999), label=\"SF (1-CDF))\")\n    # PPF Grafiği\n    axes[2].plot(x999, X.ppf(x999), label=\"PPF (Quantile Func.)\")\n    for ax in axes:\n        ax.legend()\n\n# -----\nfig, axes = plt.subplots(3, 3)\n# -----\nX = stats.norm() # Normal dağılım\nX2= stats.maxwell() # Maxwell dağılımı #X = stats.f(2, 50) # F dağılımı\nX3 = stats.poisson(5) # Poisson dağılımı\n\n# Plot\nplot_rv_distribution(X, axes=axes[0, :])\naxes[0, 0].set_ylabel(\"Normal dist.\")\nplot_rv_distribution(X2, axes=axes[1, :])\naxes[1, 0].set_ylabel(\"Maxwell dist.\")\nplot_rv_distribution(X3, axes=axes[2, :])\naxes[2, 0].set_ylabel(\"Poisson dist.\")\n\nText(0, 0.5, 'Poisson dist.')",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#dağılıma-değer-atama-sampling",
    "href": "icerik/konular/istatistik/scipy-stats.html#dağılıma-değer-atama-sampling",
    "title": "scipy - stats",
    "section": "Dağılıma Değer Atama (Sampling)",
    "text": "Dağılıma Değer Atama (Sampling)\nObje olarak elde edilen dağılımlara ait değişkenlere rastgele sayı ataması yapabiliriz. Bunun için oluşturduğumuz dağılım objesinin rvs() fonksiyonunu kullanırız.\n\nSürekli dağılımlar için rv_continuous classını kullanılır.\nSüüreksiz dağılımlar için rv_discrete classını kullanılır.\nHer iki classı kullanarak rastgele değer ataması (random sampling) yapabiliriz.\n\n\nfrom scipy import stats\n\n# Normal Dağılım Objesi Oluştur\nX= stats.norm(1, 0.5)\n\n# Normal dağılım objesine rastgele 5 değer atama\nprint(f\"Rastgele 5 sayı atama:\\n {X.rvs(5)}\")\n\nRastgele 5 sayı atama:\n [ 0.90614197 -0.12013938  0.9348654   0.78594835  0.87283753]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#alıştırma-3",
    "href": "icerik/konular/istatistik/scipy-stats.html#alıştırma-3",
    "title": "scipy - stats",
    "section": "Alıştırma 3",
    "text": "Alıştırma 3\nÖğrencinin t dağılım, chi-kare dağılım ve eksponansiyel dağılım üzerindeki rastgele örneklemeyi inceleyelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\n\n# Büyük grafik çiz fonksiyonu\ndef plot_dist_samples(X, X_samples, yLabel=None, ax=None):\n# Plot the PDF and histogram of samples of a continuous \n    if ax is None:\n        fig, ax = plt.subplots(1, 1)\n\n    x_lim = X.interval(.99)\n    \n    x = np.linspace(*x_lim, num=100)\n    \n    ax.plot(x, X.pdf(x), label=\"PDF\", lw=3)\n    ax.hist(X_samples, label=\"samples\", density=True, bins=75) # normed is deprecated\n    ax.set_xlim(*x_lim)\n    ax.legend()\n\n    if yLabel:\n        ax.set_ylabel(yLabel)\n    return ax\n\nfig, axes = plt.subplots(3,1)\nN = 2000\n# Student's t distribution\nX = stats.t(7.0)\nplot_dist_samples(X, X.rvs(N), \"Student's t dist.\", ax=axes[0])\n# The chisquared distribution\nX = stats.chi2(5.0)\nplot_dist_samples(X, X.rvs(N), r\"$\\chi^2$ dist.\", ax=axes[1])\n# The exponential distribution\nX = stats.expon(0.5)\nplot_dist_samples(X, X.rvs(N), \"exponential dist.\", ax=axes[2])\nplt.show()",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#fitting-uydurma",
    "href": "icerik/konular/istatistik/scipy-stats.html#fitting-uydurma",
    "title": "scipy - stats",
    "section": "Fitting (Uydurma)",
    "text": "Fitting (Uydurma)\n\nBir dağılımın veriye uydurulması (fitting) veriye en uygun dağılımı bulmaktır.\nscipy.stats modülü, veriye en uygun dağılımı bulmak için fit() fonksiyonunu kullanır.\nfit() fonksiyonu, veriye en uygun dağılımı bulmak için maksimum olabilirlik yöntemini kullanır.\n\n\nfrom scipy import stats\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Maxwell dağılımı\nX = stats.maxwell() # X = stats.chi2(df=5)\n# 0.99 güven aralığını bul\nx_lim = X.interval(.99)\n# 0.99 guven araliginda toplam 100 sayı oluştur\nx = np.linspace(*x_lim, num=100)\n# Rastgele 1000 sayiyi X dagiliminda oluştur\nX_samples = X.rvs(1000)\n# Her sayiya kucuk bir gurultu (distortion) ekleme\n#X_samples = X_samples + np.random.rand(len(X_samples)) * 0.1\n# Fit etme\nparams = stats.maxwell.fit(X_samples)\nprint(f\"Fit edilmiş parametreler: {params}\")\n# Parametreleri kullanarak yeni bir dağılım oluşturma\nX_fitted = stats.maxwell(*params)\n\n# Plot\nfig, ax = plt.subplots(2, 1)\nax[0].plot(x, X.pdf(x), label=\"Veri\")\nax[0].plot(x, X_fitted.pdf(x), label=\"Fit edilmiş dağılım\", lw=3)\nax[0].legend()\nax[0].set_title(\"Fit edilmiş Maxwell dağılımın PDF'i\")\nax[0].set_ylabel(\"PDF\")\nax[1].set_title(\"Hata Miktarı\")\nax[1].plot(x, np.abs(X.pdf(x) - X_fitted.pdf(x)), label=\"Hata\", lw=3)\nax[1].set_ylabel(\"Mutlak Fark\")\nax[1].legend()\n# Grid\nax[0].grid()\nax[1].grid()\n\nplt.show()\n\nFit edilmiş parametreler: (0.044673669997958604, 0.9855923110046889)",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#percent-point-function-ppf",
    "href": "icerik/konular/istatistik/scipy-stats.html#percent-point-function-ppf",
    "title": "scipy - stats",
    "section": "Percent point function (PPF)",
    "text": "Percent point function (PPF)\nPPF bir olasılık dağılımının ters fonksiyonudur. PPF, bir olasılık dağılımının verilen bir olasılık seviyesindeki (örneğin, %95) kritik değerini hesaplamak için kullanılır. Bundan dolayı diğer adı kuantil fonksiyonu (quantile function)dur.\nPPF, kümülatif dağılım fonksiyonunun (CDF) tersidir. CDF, bir olasılık dağılımının belirli bir değere veya daha azına sahip olma olasılığını gösterirken, PPF, belirli bir olasılık seviyesindeki kritik değeri gösterir.\nPPF, istatistiksel analizlerde ve hipotez testlerinde yaygın olarak kullanılır. PPF kullanarak, belirli bir güven seviyesi için kritik değerleri belirlemek ve bu değerleri kullanarak hipotez testlerini yapmak mümkündür.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#survival-function-sf",
    "href": "icerik/konular/istatistik/scipy-stats.html#survival-function-sf",
    "title": "scipy - stats",
    "section": "Survival Function (SF)",
    "text": "Survival Function (SF)\nSurvival function, bir olayın (örneğin ölüm, arıza, başarısızlık vb.) belirli bir zaman noktasına kadar gerçekleşmeme olasılığını gösteren bir olasılık dağılım fonksiyonudur. Diğer bir deyişle, survival function, bir bireyin, bir cihazın veya bir sistemin belirli bir zamana kadar hayatta kalma olasılığını gösterir.\n\n\n\nSurvival Function  [1]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#problemler",
    "href": "icerik/konular/istatistik/scipy-stats.html#problemler",
    "title": "scipy - stats",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nYakın bir galakside süpernova meydana geldiğini düşünün. Bu süpernovadan Dünya’ya nötrino parçacıkları gelecektir.\nNötrinolar, kütleli (neredeyse sıfır) ve spin 1/2 parçacıklardır.\nDünya’daki nötrino gözlem evleri süpernovadan gelen nötrinoları enerjilerine göre gözlemlemiştir. Bu gözlemler neutrinoCount.csv dosyasında verilmiştir. Bu dosyayı indirmek için tıklayınız.\nBu dosyadaki ilk sütun gelen nötrinoların enerjileri, ikinci sütun ise bu enerjilerdeki nötrinoların sayısıdır.\n\n\nNötrinolar hangi istatistiksel dağılımı takip eder?\nneutrinoCount.csv dosyasını okuyun.\nNötrinoların ortalama enerjisini ve standart sapmasını bulun.\nneutrinoCount.csv dosyasındaki veri normalize midir? Değil ise normalize edin.\nGelen nötrinoların enerjiye göre sayılarının grafiğini çizdirin.\nGelen nötrino sayılarını 1’e normalize edin.\nAşağıdaki normalize edilmiş Fermi-Dirac dağılımını kullanarak nötrinoların sıcaklığını \\(2-10\\) MeV arasında arayın.\n\n\\[f(E) = \\frac{1}{1.803 T^{3}} \\frac{E^{2}}{1+\\exp(E/T)}\\]\n\n\nProblem 2\n\nStandart sapması 5 olan ve ortalaması 35 olan bir normal dağılıma sahip 1000 elemanlı bir dizi oluşturun. scipy.stats.norm.\nBu dizinin histogramını çizdirin. Histogramı çizmeden önce ürettiğiniz objeye rastgele sayılar atamanız gerekecektir. Bunun için rvs(10000) komutunu kullanabilirsiniz. Bin sayısını 100 alabilirsiniz.\nBu dizinin beklenen değerini ekrana yazdırın.\nBu dizinin varyansını ekrana yazdırın.\nBu dizinin standart sapmasını ekrana yazdırın.\n\\(40\\)’ın gelme olasılığını bulun.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/scipy-stats.html#kaynaklar",
    "href": "icerik/konular/istatistik/scipy-stats.html#kaynaklar",
    "title": "scipy - stats",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Python: Scientific Computing and Data, Science Applications with Numpy, SciPy and Matplotlib, Robert Johansson, Apress, İkinci Basım, 2019, syf 451",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "scipy - stats"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html",
    "href": "icerik/konular/istatistik/temel-kavramlar.html",
    "title": "Temel Kavramlar",
    "section": "",
    "text": "İstatistiksel analizler için gerekli modüller: scipy.stats, scipy.optimize, numpy. Yardımcı modüller ise matplotlib.pyplot, pandas, seaborn.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#kullanılacak-modüller",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#kullanılacak-modüller",
    "title": "Temel Kavramlar",
    "section": "",
    "text": "İstatistiksel analizler için gerekli modüller: scipy.stats, scipy.optimize, numpy. Yardımcı modüller ise matplotlib.pyplot, pandas, seaborn.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#istatistikteki-tanımlar",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#istatistikteki-tanımlar",
    "title": "Temel Kavramlar",
    "section": "İstatistikteki Tanımlar",
    "text": "İstatistikteki Tanımlar\n\nPopülasyon (Population): Bir nesnenin tüm özelliklerini belirlemek için seçilen örneklerdir.\nÖrneklem (Sample): Bir nesnenin özelliklerini belirlemek için seçilen örneklerdir.\nBelirsizlik (Uncertainty): Örneklem veya popülasyonun özelliklerini belirlemek için kullanılan örneklerin sayısının yetersiz olmasıdır.\nVeri (Data): Bir araştırma veya analiz için toplanan sayısal veya kategorik bilgilerdir.\nOrtalama (Mean) : Veri setinin tüm değerlerinin toplamının, veri setindeki eleman sayısına bölünmesiyle elde edilir.\nMedyan veya Ortanca Değer (Median): Veri setindeki değerlerin ortalamasına göre sıralandıktan sonra ortadaki değerdir.\nMod veya Tepe Değer (Mod): Veri setindeki en sık tekrar eden değerdir.\nVaryans (Variance) : Veri setindeki değerlerin ortalama değere ne kadar dağıldığını ölçen bir istatistiksel ölçüdür.\nStandart Sapma (Standard Deviation): Veri setindeki değerlerin ortalama değerden ne kadar sapma gösterdiğini gösteren bir ölçüdür.\nÇeyrekler (Quartiles): Veri setindeki değerlerin sıralanmasından sonra ortadaki değer orta çeyreklik, orta çeyreklik ile en küçük değerin ortasındaki değer alt çeyreklik (%25), orta çeyreklik ile en büyük değerin ortasındaki değer üst çeyreklik (%75) olarak tanımlanır.\nMinimum ve maksimum değer (Minimum and Maximum): Veri setindeki en küçük ve en büyük değerlerdir.\n\n\nDağılımlar\nDağılımları anlamak için aşağıdaki karakteristik özelliklere bakabiliriz.\n\nMerkezi eğilim (Central tendency): Dağılımın bir merkezi var mı?\nModlar: En sık tekrar eden değerler dağılımda nasıl gözüküyor?\nYayılım (Spread): Dağılımın merkezden uzağa doğru nasıl yayılmış? Simetrik mi?\nKuyruklar (Tails): Dağılımın kuyruklarında nasıl bir dağılım var?\nAykırılar (Outliers): Dağılımın kuyruklarında “aykırı” değerler var mı? Veriyi nasıl etkiliyorlar?\n\nOrtalama değer (aritmetik ortalama) aşağıdaki formül ile hesaplanır.\n\\[\n\\overline{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n\\]\n\n\nVaryans\nVaryansın formülü aşağıdaki gibidir.\n\\[\ns^{2} = \\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\overline{x})^{2}\n\\]\n\nVaryansın karekökü ise standart sapmadır.\nÖrneklem uzayı kullanılıyorsa, payda \\(n-1\\), popülasyon kullanılıyorsa payda \\(n\\) olmalıdır.\n\nÖrneğin bir veri setinde ortalama hamilelik süresi \\(38.6\\) olsun. Bu değerin standart sapması \\(2.7\\) olarak elde edilsin. Bu da demek oluyor ki gebelik süresi \\(38.6 \\mp 2.7\\) şeklinde söyleyebiliriz.\nHistogramlar, veri setlerinin dağılımlarını görselleştirmek için kullanılır. Histogram ile yapılan görsellerde, veri setlerinin merkezi eğillerini, modunu, yayılımını ve kuyruklarını görebiliriz. Ayrıca histogramlar, veri setlerindeki aykırı değerleri belirlemek için de kullanılır.\n\n\nEfektif Boyut\nBir popülasyonda veya örneklemde, iki değişken arasındaki ilişkinin gücünü vermek için Cohen’in d değeri tanımlanır. Ayrıntılı bilgi için referanslara bakın.\n\\[\nd = \\frac{\\overline{x}_1 - \\overline{x}_2}{s_{havuz}}\n\\]\nBurada \\(\\overline{x}_1\\) birinci grubun ortalaması, \\(\\overline{x}_2\\) ikinci grubun ortalaması ve \\(s_{havuz}\\) ise grupların ortak havuz standart sapmasıdır (pooled standard deviation). \\(s_{havuz}\\) aşağıdaki gibi tanımlanır.\n\\[\ns_{havuz}= \\sqrt{\\frac{n_1s_1^2 + n_2s_2^2}{n_1 + n_2}}\n\\]\nBurada \\(n1\\) ve \\(n2\\) grupların örneklem sayısı, \\(s1\\) ve \\(s2\\) grupların standart sapmasıdır.\n\n\n\nCohen’in d değeri",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#alıştırma-1",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#alıştırma-1",
    "title": "Temel Kavramlar",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBir araştırmada seçimlerdeki oy dağılımı tahmin edilmek istenmektedir. Toplamda 1000 kişi oy vereceğini düşünelim. Anket şirketi de 100 kişiye sormuş. Bu 100 kişinin oy dağılımı şu şekilde:\n\n\n\nA Partisi\nB Partisi\nC Partisi\nD Partisi\nKararsız\n\n\n\n\n30\n15\n40\n10\n5\n\n\n\n\nÇözüm\n\nimport pandas as pd\nimport numpy as np\n# Veri seti\ndf= pd.Series({'A Parisi':30,\n               'B Partisi':15,\n               'C Partisi':40,\n               'D Partisi':10,\n               'Kararsız':5})\n# Çiz\ndf.plot(kind='bar', title='Parti Seçimlerine Göre Oy Dağılımı', ylabel='Oy Sayısı')\n# Pandas açıklama\nprint(df.describe())\n\ncount     5.00000\nmean     20.00000\nstd      14.57738\nmin       5.00000\n25%      10.00000\n50%      15.00000\n75%      30.00000\nmax      40.00000\ndtype: float64\n\n\n\n\n\n\n\n\n\nYukarıdaki tanımlara doğrultusunda alıştırmayı tekrar ele alalım.\n\nPopülasyon: 1000 (Tüm nüfus)\nÖrneklem: 100 (Anket yapılan kişi sayısı)\nÖrneklem Adeti: 1 (Kaç kere anket yapıldığı, 1 şirket)\nBelirsizlik: 900 (Kime oy vereceği bilinmeyen kişi sayısı)\nVeri: 100\n\n30 A Partisi, 15 B Partisi, 40 C Partisi, 10 D Partisi, 5 Kararsız\n\nOrtalama: 20\n\n30 + 15 + 40 + 10 + 5 = 100 / 5 = 20\n\nMedyan (Ortanca Değer): 15 (B Partisi)\n\n40, 30, 15, 10, 5 sıralandığında ortanca değer 15\n\nMod (Tepe Değer): En sık tekrar eden değer yok.\nVaryans \\(\\sigma^{2}\\): 170.0\n\n\\((|30-20|^{2} + |15-20|^{2} + |40-20|^{2} + |10-20|^{2} + |5-20|^{2})/5 = 170.0\\)\n\n\nStandart Sapma: 13.0\n\n\\(\\sqrt{(|30-20|^{2} + |15-20|^{2} + |40-20|^{2} + |10-20|^{2} + |5-20|^{2})/5} = 13.0\\)\n\nÇeyrekler: 10, 15, 30\n\n40, 30, 15, 10, 5 sıralandığında\n\nAlt Çeyreklik: 10 (%25)\nOrtanca çeyreklik: 15 (%50)\nÜst Çeyreklik: 30 (%75)\n\n\nMinimum ve Maksimum değer: 5 ve 40\n\nEğer veriler ortalama değerden farkları az olursa standart sapma ve varyanas değerleri küçük olur.\n\nimport numpy as np\n\n# Veri: 21,22,20,18,19\nprint(\"Veri: 21,22,20,18,19\")\nprint(f\"Varyans (Veri-Ortalamaya-Yakın): {(1**2 + 2**2 +2**2 +1**2)/5}\")\nprint(f\"Standart Sapma (Veri-Ortalamaya-Yakın): {np.sqrt((1**2 + 2**2 +2**2 +1**2)/5)}\")\nprint(\"-\"*20)\n# Veri: 30,15,40,10,5  \nprint(\"Veri: 30,15,40,10,5\")\nprint(f\"Varyans: {(10**2 + 5**2 +20**2 +10**2+ 15**2)/5}\")\nprint(f\"Standart Sapma: {np.sqrt((10**2 + 5**2 +20**2 +10**2+ 15**2)/5)}\")\n\nVeri: 21,22,20,18,19\nVaryans (Veri-Ortalamaya-Yakın): 2.0\nStandart Sapma (Veri-Ortalamaya-Yakın): 1.4142135623730951\n--------------------\nVeri: 30,15,40,10,5\nVaryans: 170.0\nStandart Sapma: 13.038404810405298\n\n\npandas içerisinde describe() fonksiyonu ile belirlenen değerleri numpy paketi ile de belirleyebiliriz.\n\nimport numpy as np\nveri= np.array([30., 15., 40., 10., 5.])\nprint(\"Veri: 30,15,40,10,5\")\nprint(f\"Ortalama: {veri.mean()}\")\nprint(f\"Varyans: {veri.var()}\")\nprint(f\"Standart Sapma: {veri.std()}\")\nprint(f\"Medyan: {np.median(veri)}\")\nprint(f\"Minimum ve Maksimum: {veri.min()} ve {veri.max()}\")\nprint(f\"Çeyrekler: {np.percentile(veri, [25, 50, 75])}\")\n\nVeri: 30,15,40,10,5\nOrtalama: 20.0\nVaryans: 170.0\nStandart Sapma: 13.038404810405298\nMedyan: 15.0\nMinimum ve Maksimum: 5.0 ve 40.0\nÇeyrekler: [10. 15. 30.]\n\n\n\n\n\n\n\n\nUyarı\n\n\n\nPandas’ın verdiği standart sapma ile tanımdan elde ettiğimiz standart sapma değerleri farklıdır. Bunun sebebi pandas’ın yansız (unbiased) yaklaşımı kullanmasıdır. Daha ayrıntılı bilgi için  [1] numaralı kaynağa bakınız.\n\n\n\nimport pandas as pd\nimport numpy as np\n# Veri\ndf= pd.Series([30, 15, 40, 10, 5])\nveriNP= np.array([30, 15, 40, 10, 5])\nprint(f\"Standart Sapma, Pandas: df.std()= {df.std()}\")\nprint(f\"Standart Sapma, Numpy: veriNP.std()= {veriNP.std()}\")\n\nStandart Sapma, Pandas: df.std()= 14.577379737113251\nStandart Sapma, Numpy: veriNP.std()= 13.038404810405298\n\n\nBurada pandas ile numpy modüllerinin standart sapma (varyans) değerleri, varsayılan özellikler kullanıldığında aynı sonucu vermez. Bunun sebebi istatistikte “yanlı/yansız (biased/unbiased)” olarak bilinen iki farklı yaklaşım olmasıdır. Bu iki yaklaşımın farklılıkları için aşağıdaki linkleri inceleyebilirsiniz.\n\nwhat-is-the-difference-between-bias-and-variance\norneklemin-standart-sapmasinin-hesaplanmasi\nNeden standart sapma hesaplanırken n-1 yapılır?\n\nnumpy yanlı yaklaşımı (\\(n\\)’e bölme) kullanırken pandas yansız yaklaşımı (\\(n-1\\)’e bölme) kullanmaktadır.\nTL;DR\n\nPopülasyon üzerinden hesap yapmak istiyorsanız yanlı yaklaşımı, df.std(ddof=0) veya np.std() kullanın.\nÖrneklem üzerinden hesap yapmak istiyorsanız yansız yaklaşımı df.std() veya np.std(ddof=1) kullanın.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#rastgele-sayılar",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#rastgele-sayılar",
    "title": "Temel Kavramlar",
    "section": "Rastgele Sayılar",
    "text": "Rastgele Sayılar\nÖnce numpy modülü içerisindeki random paketi ile rastgele sayılar üretelim.\n\nnp.random.rand(N): \\([0,1)\\) arasında düzgün olarak  (uniformly) N boyutlu rastgele sayı üretir.\nnp.random.randn(): \\(N(0,1)\\) arasında standart normal dağılımlı  olarak (standard normal distribution) rastgele sayı üretir.\nnp.random.randint(a,b): \\([a,b)\\) arasında düzgün olarak  (uniformly) rastgele sayı üretir.\n\n\nimport numpy as np\nprint(f\"5 Boyutlu düzgün dağılımlı rastgele sayılar: {np.random.rand(5)}\")\nprint(f\"5 Boyutlu normal dağılımlı rastgele sayılar: {np.random.randn(5)}\")\nprint(f\"5 boyutlu 0 ile 10 arasında rastgele tam sayılar: {np.random.randint(0, 10, 5)}\")\n\n5 Boyutlu düzgün dağılımlı rastgele sayılar: [0.85808143 0.25037791 0.85272373 0.41590993 0.79257133]\n5 Boyutlu normal dağılımlı rastgele sayılar: [-1.57748868 -0.15485959 -0.51745458 -0.70111466  0.50142587]\n5 boyutlu 0 ile 10 arasında rastgele tam sayılar: [3 9 5 4 0]\n\n\nStandart normal dağılımı rastgele sayı üreteci 0’ın ortasında ve 1’in standart sapması olan bir dağılım oluşturur. Bu dağılımın özelliklerini görmek için aşağıdaki kodu çalıştırın.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 1000 tane rastgele sayı üret\n#x = np.random.randn(1000)\nx = np.random.randn(1_000_000)\n\n# Histogram çiz\nplt.hist(x, bins=40)\nplt.show()\nplt.close()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Rastgele sayı üret [0,1)\nprint(np.random.rand())\nprint(\"-\"*20)\n# Rastgele 5 tane sayı üret [0,1)\nprint(np.random.rand(5))\nprint(\"-\"*20)\n# Rastgele 2x4 matris üret [0,1)\nprint(np.random.rand(2, 4))\nprint(\"-\"*20)\n# Rastgele Normal dağılımlı sayı üret\nprint(np.random.randn(10))\nprint(\"-\"*20)\n# Rastgele tam sayı üret [0,10)\nprint(np.random.randint(0, 10))\nprint(\"-\"*20)\n# Rastgele 5 tane tam sayı üret\nprint(np.random.randint(0, 10, 5))\n# print(np.random.randint(low=0, high=10, size=5))\nprint(\"-\"*20)\n# Rastgele 2x4 matris üret [0,10)\nprint(np.random.randint(0, 10, (2, 4) ))\n#print(np.random.randint(low=0, high=10, size=(2,4)))\n\n# Çiz\nfig, axes = plt.subplots(3,1)\naxes[0].hist(np.random.rand(10_000))\naxes[0].set_title(\"rand(10_000)\")\naxes[1].hist(np.random.randn(10_000))\naxes[1].set_title(\"randn(10_000)\")\naxes[2].hist(np.random.randint(low=1, high=10, size=10_000), bins=9, align='left')\naxes[2].set_title(\"randint(low=1, high=10, size=10_000)\")\nplt.tight_layout()\n\n0.08996093256788107\n--------------------\n[0.18365249 0.49711245 0.49711082 0.11194676 0.38784789]\n--------------------\n[[0.28772841 0.58610905 0.00958808 0.94982884]\n [0.35503727 0.11171392 0.97924085 0.86424644]]\n--------------------\n[-0.7909025   1.38532895 -0.70664529  0.49370587  1.01832728  0.61730387\n  0.49390439 -1.78326325 -1.29758843  0.22121763]\n--------------------\n9\n--------------------\n[3 3 4 0 5]\n--------------------\n[[0 5 2 8]\n [6 7 6 4]]\n\n\n\n\n\n\n\n\n\nİlerleyen bölümlerde belli bir array’den rastgele bir eleman seçmek isteyeceğiz. Bunun için np.random.choice() özelliğini kullanacağız. Eğer replace=False özelliği ile kullanırsak seçilen eleman tekrar seçilemez. Varsayılan özellik replace=True’dur.\n\nimport numpy as np\n# 0 ile 4 arasında 3 tane rastgele sayı seç\nprint(np.random.choice(5, 3))\n# Aynı işi np.random.randint(0,5,3) de yapar\nprint(\"--\"*20+\"1\")\n# 0.1, 0, 0.3, 0.6, 0 olasılıkları ile 3 tane rastgele sayı seç.\n# Yani 0.1 olasılıkla 0, \n#      0 olasılıkla 1, \n#      0.3 olasılıkla 2, \n#      0.6 olasılıkla 3, \n#      0 olasılıkla 4\nprint(np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0]))\nprint(\"--\"*20)\n# Tekrar seçim yapmadan 3 tane rastgele sayı seç\nprint(np.random.choice(5, 3, replace=False))\n# Aynı işi np.random.permutation(np.arange(5))[:3] de yapar\nprint(\"--\"*20)\n# Harfler arasından 2 tane rastgele isim seç\nharfler = ['A', 'B', 'C', 'Ç' ,'D', 'E', 'F', 'G', 'Ğ' , 'H']\nprint(np.random.choice(harfler, 2))\nprint(np.random.choice(harfler, 2, replace=False))\n\n[0 3 1]\n----------------------------------------1\n[0 2 3]\n----------------------------------------\n[0 4 3]\n----------------------------------------\n['G' 'G']\n['Ğ' 'C']\n\n\nRastgele sayı seçiminde çekirdek (seed) seçimi de önemli bir faktördür çünkü rastgelelik bir çekirdek üzerinden oluşur. Aynı çekirdek seçilir ise “aynı rastgelelik” kullanarak sayılar/seçimler oluşturulur.\nBizim çalışacağımız problemlerde çekirdek seçimi önemli olmayacaktır ancak oyun, simülasyon gibi problemlerde çekirdek seçimi önemli olabilir.\n\n\n\nTerraria Seed\n\n\n\n\n\nMinecraft Seed\n\n\nÇekirdek seçimi için np.random.seed() fonksiyonunu kullanılır.\nBelirlenen bir çekirdek üzerine seçimler yapmak için aşağıdaki gibi bir rastgele durum belirlenir.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Oyun Haritası 42 çekirdek kullan\ncekirdekSayisi= 42\ncekirdek= np.random.RandomState(cekirdekSayisi)\n# 2 boyutlu bir harita olacak şekilde çizdir\nplt.imshow(cekirdek.rand(8,8), cmap='gray', interpolation='nearest')\nplt.show()\nplt.close()\nprint(f\"4 adet rastgele sayı: {cekirdek.rand(4)}\")\nprint(\"-\"*20)\nprint(f\"4 adet rastgele sayı: {cekirdek.rand(4)}\")\n\n\n\n\n\n\n\n\n4 adet rastgele sayı: [0.28093451 0.54269608 0.14092422 0.80219698]\n--------------------\n4 adet rastgele sayı: [0.07455064 0.98688694 0.77224477 0.19871568]\n\n\nYukarıdaki programı tekrar çalıştırdığımızda aynı sonuçları alırız. Çünkü çekirdek aynıdır.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Oyun Haritası 42 çekirdek kullan\ncekirdekSayisi= 42\ncekirdek= np.random.RandomState(cekirdekSayisi)\n# 2 boyutlu bir harita olacak şekilde çizdir\nplt.imshow(cekirdek.rand(8,8), cmap='gray', interpolation='nearest')\nplt.show()\nplt.close()\nprint(f\"4 adet rastgele sayı: {cekirdek.rand(4)}\")\nprint(\"-\"*20)\nprint(f\"4 adet rastgele sayı: {cekirdek.rand(4)}\")\n\n\n\n\n\n\n\n\n4 adet rastgele sayı: [0.28093451 0.54269608 0.14092422 0.80219698]\n--------------------\n4 adet rastgele sayı: [0.07455064 0.98688694 0.77224477 0.19871568]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#rastgele-değişkenler-ve-dağılımlar",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#rastgele-değişkenler-ve-dağılımlar",
    "title": "Temel Kavramlar",
    "section": "Rastgele Değişkenler ve Dağılımlar",
    "text": "Rastgele Değişkenler ve Dağılımlar\nPopülasyondan rastgele seçilen örneklem üzerinden yapılan istatistiksel incelemelerde, örneklem dağılımının popülasyon dağılımına yakın olması istenir. Bu ve benzeri konular için matematikte olasılık teorisi bulunmaktadır.\n\nÖrnek Uzayı (Sample Space): Bir deneyin tüm olası sonuçlarının bir kümesidir.\n\nÖrnek uzaydaki tüm elemanlar için bir olasılık değeri vardır.\n\nOlasılık Dağılımı (Probability Distribution): Bir deneyin tüm olası sonuçlarının olasılıklarının bir dağılımıdır.\nRastgele Değişken (Random Variables): Bir deneyin sonucu olarak elde edilen değerlerdir.\n\nRastgele değişkenlerin birbirinden bağımsız olması gerekir.\n\n\nÖrneğin\n\nBir paranın örnek uzayı \\(\\{Yazı,Tura\\}\\)’dır.\nRastgele değerleri \\(\\{0,1\\}\\)’dir.\n\nİstatistiksel işlemler kullanmak için rastgele değişkenlerin olasılık dağılımlarına ihtiyacımız vardır.\nRastgele değişkenler alacağı olası değerler ile karakterize edilir ve bu değerler de olasılık dağılımına göre belirlenir.\nEn temelde iki çeşit dağılım vardır. 1. Kesikli Dağılımlar, Tam Sayılar (Discrete Distributions) 2. Sürekli Dağılımlar, Gerçel Sayılar (Continuous Distributions)\nscipy.stats modülü içerisindeki rv_discrete ve rv_continuous sınıfları ile dağılımların özelliklerine ulaşabiliriz. Bu paketteki metotlar ve açıklamaları için dokümantasyon sayfasına veya Numerical Python kitabında tablo 13-1’e bakabilirsiniz.\nBazı dağılımlar:\n\nUniform Dağılım (Uniform Distribution): \\(U(a,b)\\)\nStandart Normal Dağılımı (Standard Normal Distribution): \\(N(0,1)\\)\nNormal Dağılım (Normal Distribution): \\(N(\\mu,\\sigma^2)\\)\nÜstel Dağılım (Exponential Distribution): \\(Exp(\\lambda)\\)\nFermi-Dirac Dağılımı (Fermi-Dirac Distribution): \\(FD(\\mu,\\beta)\\)\nBose-Einstein Dağılımı (Bose-Einstein Distribution): \\(BE(\\mu,\\beta)\\)\nBinom Dağılımı (Binomial Distribution): \\(B(n,p)\\)\nPoisson Dağılımı (Poisson Distribution): \\(P(\\lambda)\\)\nGamma Dağılımı (Gamma Distribution): \\(Gamma(\\alpha,\\beta)\\)\nBeta Dağılımı (Beta Distribution): \\(Beta(\\alpha,\\beta)\\)\nChi-Square Dağılımı (Chi-Square Distribution): \\(\\chi^2(n)\\)",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#alıştırma-2",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#alıştırma-2",
    "title": "Temel Kavramlar",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\nOrtalama değeri 1 olan ve standart sapması 0.5 olan bir normal dağılım üretelim.\n\nÇözüm\n\nimport scipy.stats as stats\n\nX= stats.norm(1, 0.5)\nprint(f\"Ortalama: {X.mean()}\")\nprint(f\"Median: {X.median()}\")\nprint(f\"Standart Sapma: {X.std()}\")\nprint(f\"Varyans: {X.var()}\")\n\nOrtalama: 1.0\nMedian: 1.0\nStandart Sapma: 0.5\nVaryans: 0.25",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#histogramlar",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#histogramlar",
    "title": "Temel Kavramlar",
    "section": "Histogramlar",
    "text": "Histogramlar\nHistogram denildiğinde verinin dağılımdan ve frekansından bahsetmemiz gerekir.\nÖrneğin:\n\n\\(1\\), \\(2\\), \\(3\\), \\(4\\), \\(5\\), \\(6\\) sayıları verimiz olsun. Bu verinin dağılımı tam sayılar arasında eşit olasılıkla dağılmıştır. Yani her sayının gelme olasılığı aynıdır. Bu verinin frekansı yani tekrarlanma sayısı da aynıdır. Çünkü her sayı birer kez tekrar edilmiştir.\n\\(1\\), \\(3\\), \\(3\\), \\(3\\), \\(4\\), \\(6\\) sayıları verimiz olsun. Bu verinin dağılımı tam sayılar arasında eşit olasılıkla dağılmamıştır. Yani her sayının gelme olasılığı aynı değildir. \\(1\\), \\(4\\) ve \\(6\\) sayılarının gelme olasılığı \\(1/6\\), \\(3\\) sayısının gelme olasılığı \\(3/6\\)’dır. Bu verinin frekansı yani tekrarlanma sayısı da aynı değildir. Çünkü \\(3\\) sayısı 3 kez tekrar edilmiştir.\n\nBu iki örneğin histogramlarını çizelim.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# Veri\nseri1= pd.Series([1,2,3,4,5,6,7,8,9,10])\nseri2= pd.Series([1,1.5,2,2,3,3,3,4,4,5,6,7,8,9,10])\n# Çiz\nfig, axs= plt.subplots(2,1)\nseri1.plot(kind=\"hist\", ax=axs[0], title=\"seri1\", bins=5)\nseri2.plot(kind=\"hist\", ax=axs[1], title=\"seri2\", bins=11)\n\n\n\n\n\n\n\n\nBins: Yatay eksendeki sütun sayısı.\nÖrneğin: 1,2,3,4,5 verisi var ise bin=5 yapıldığında sütunların arası hiç gözükmez, çünkü yatay eksende 1 değerinin üstünde sütun olur, 2 değerinin üstünde sütun olur vs. bin=11 yapıldığında ise kabaca 0.5 üzerinde ve 1 üzerinde sütun çizilmeye çalışılır.\nAşağıdaki linklerden bin sayısı en iyi nasıl seçilir hakkında bilgi alabilirsiniz.\n\nBin sayısı en iyi nasıl seçilir?\nBin arası nasıl ayrılır?\n\nPython ile veri analizinde collections paketi de kullanılır.\n\nfrom collections import Counter\nimport pandas as pd\n# Veri\ndf_p= [1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 8, 9]\n# Collections paketinde bulunan Counter fonksiyonu\ndf_pCounter= Counter(df_p)\nprint(f\"Veri: {df_p}\")\nprint(f\"Counter :{df_pCounter}\")\nprint(f\"Counter tipi: {type(df_pCounter)}\")\nprint(f\"8'in frekansı {df_pCounter[8]}\")\nprint(f\"3'in frekansı {df_pCounter[3]}\")\nprint(\"-\"*20)\n# Pandas\ndS= pd.Series(df_p)\nprint(f\"Veri: {dS}\")\nprint(f\"Serinin tipi: {type(dS)}\")\nprint(f\"Tüm frekanslar\\n{dS.value_counts()}\")\nprint(f\"8'in frekansı {dS.value_counts()[8]}\")\n\nVeri: [1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 8, 9]\nCounter :Counter({8: 4, 4: 2, 1: 1, 2: 1, 3: 1, 5: 1, 6: 1, 7: 1, 9: 1})\nCounter tipi: &lt;class 'collections.Counter'&gt;\n8'in frekansı 4\n3'in frekansı 1\n--------------------\nVeri: 0     1\n1     2\n2     3\n3     4\n4     4\n5     5\n6     6\n7     7\n8     8\n9     8\n10    8\n11    8\n12    9\ndtype: int64\nSerinin tipi: &lt;class 'pandas.core.series.Series'&gt;\nTüm frekanslar\n8    4\n4    2\n1    1\n2    1\n3    1\n5    1\n6    1\n7    1\n9    1\nName: count, dtype: int64\n8'in frekansı 4",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#problemler",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#problemler",
    "title": "Temel Kavramlar",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n100 adet parayı 1000 kere atan ve np.random.rand() fonksiyonu kullanan bir betik dosyası yazın. Her atıldığında 100 tane paranın kaç tanesi tura geldiğini kaydedin ve sonucu histogram grafiği olarak çizdirin.\n\n\nProblem 2\nUygulama 1 ile verilen betik dosyasını np.random.choice() fonksiyonu kullanarak yapın.\n\n\nProblem 3\n100 adet zarı 1000 kere atan ve np.random.choice() fonksiyonunu kullanan bir betik dosyası yazın. Her atıldığında 100 tane zarın kaç tanesinin 6 geldiğini, kaç tanesinin 5 geldiğini vs. kaydedin ve sonucu histogram grafiği olarak çizdirin.\n\n\nProblem 4\nAşağıdaki linkte bulunan excel dosyasını indirin.\nStandart Solar Spectrumu Linki. Eğer bu link çalışmazsa github reposunda bulunan dosyayı da indirebilirsiniz.\n\nBu excel dosyasındaki verileri temizleyin.\n\nBaşlıkları sadece Wavelength (nm), Extraterrestrial W*m-2*nm-1, Global tilt  W*m-2*nm-1, Direct+circumsolar W*m-2*nm-1 kalsın.\nTüm diğer verileri silin.\nTüm tablar (sheets) silin.\nTüm veriyi float tipine çevirin.\n\nTemizlediğiniz veriyi okuyun ve Wavelength (nm) sütununu x ekseni olacak şekilde tüm kolonların grafiklerini aynı figürde çizdirin.\nExtraterrestrial W*m-2*nm-1 en yüksek değerini bulun.\nEn yüksek değerin kaç Kelvin olduğunu bulun. (Wien’s Öteleme Kanunu)\nEn yüksek değerin kaç Celsius olduğunu bulun.\nGörünür ışığın spektrumunu yukarıda çizdiğiniz grafikte gösterin.\n\nKaynak: Solar Spectrum\n\n\nProblem 5\n\n600 adet parayı 1000 kere atan bir algoritma oluşturun. 600 adet parnın kaçı tura geldiğini hesaplasın. Bunu 1000 kere yapacak şekilde mofiye edin. 600 tane para atıldığında kaç tanesinin tura geldiğini gösteren bir histogram çizdirin.\nAynı işlemi bu sefer bir zaın 3 gelmesi için yapın. Yani, 600 adet zarı 1000 kere attığınızda, 600 zarın kaç defa 3 geldiğini hesaplayan bir program yazın. 600 tane zar atıldığında kaç tanesinin 3 geldiğini gösteren bir histogram çizdirin.\n600 adet zarı ve 600 adet parayı aynı anda yani beraber 1000 kere atıldığında, kaçında 3 ve tura geldiğini hesaplayan bir program yazın. 600 tane para ve zar atıldığında kaç tanesi 3 ve tura geldiğini gösteren bir histogram çizdirin.\n\n\nNot: 2. sorunun verisini kullanabilirsiniz.\nİpucu: Dağılımının \\(600\\times(1/2)\\times(1/6)=50\\) etrafında olması beklenir.\n\n\nAşağıdaki adımları yapın.\n\n1200 adet (birinci zarı 600 kere ikinci zarı 600 kere düşünün) zarı 1000 kere atıp, ikili toplamları kaç kere 7 geldiğini ve kaç kere 12 geldiğini hesaplayan bir program yazın. 1200 tane zar atıldığında ikili toplamları kaç kere 7 ve kaç kere 12 geldiğini gösteren histogramları aynı figürde çizdirin.\nToplamı 7 ve 12 gelen dağılımlar için aşağıdaki değerleri hesaplayın.\n\nOrtalama değer\nMod (en çok tekrar eden değer)\nStandart sapma, Varyans\nMedyan\nMaksimum ve Minimum değer\n\nİki dağılım için efektif boyutu, Cohen’in d değerini hesaplayın.\n\n\n\nİpucu: Algoritmayı şöyle yazabilirsiniz. İki ayrı zarı attım ve toplamları 7 geldi. Bunu 600 kere tekrarladım ve kaydettim. Bu işlemi 1000 kere daha yaptım.\nİpucu2: 7’nin dağılımının \\(600\\times(1/6)=100\\) etrafında olması beklenir. (1+6, 2+5, 3+4, 4+3, 5+2, 6+1)\nİpucu3: 12’nin dağılımının \\(600\\times(1/36)=16.7\\) etrafında olması beklenir.\nİpucu4:\n\n\\[\nd = \\frac{\\overline{x}_1 - \\overline{x}_2}{s_{havuz}}\n\\]\n\\[\ns_{havuz}= \\sqrt{\\frac{n_1s_1^2 + n_2s_2^2}{n_1 + n_2}}\n\\]",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/temel-kavramlar.html#kaynaklar",
    "href": "icerik/konular/istatistik/temel-kavramlar.html#kaynaklar",
    "title": "Temel Kavramlar",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Python: Scientific Computing and Data, Science Applications with Numpy, SciPy and Matplotlib, Robert Johansson, Apress, İkinci Basım, 2019, syf 443\nhttps://www.mathsisfun.com/data/\nWikipedia: Efektif Boyut, Cohen’s d\nCohen D’nin tanımı ve grafik",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Temel Kavramlar"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html",
    "title": "Uygulama - thinkstat2",
    "section": "",
    "text": "Bu bölümde thinkstats2 kitabındaki bazı alıştırmaları çözeceğiz.\nThinkstats2 kitabına şu linkten ulaşabilirsiniz: https://greenteapress.com/thinkstats2/thinkstats2.pdf\nUygulamaları ise github sayfasından ulaşabilirsiniz. https://github.com/AllenDowney/ThinkStats2",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#istatistiksel-bakış-açısı",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#istatistiksel-bakış-açısı",
    "title": "Uygulama - thinkstat2",
    "section": "İstatistiksel Bakış Açısı",
    "text": "İstatistiksel Bakış Açısı\n\nAnekdot: “İlk çocuklar için hamilelik süresi daha uzundur.”\n\n\nData Toplama (Data collection): Amerikan toplumu için çocuk doğum yaş verisini toplayalım.\nAçıklayıcı İstatistikler (Descriptive Statistics): Veriyi temel olarak açıklayan istatistiksel kavramlara bakalım.\nVeri Analizi Açıklama (Exploratory Data Analysis): Veriyi daha iyi anlamak için tekrarlara, farklılıklara veya diğer özelliklere bakalım.\nTahmin (Estimation): Veriye göre bir model kuralım ve genel nüfus hakkında tahminde bulunalım.\nHipotez Testi (Hypothesis Testing): Açığa çıkan etkileri, örneğin iki grup arasındaki farkı test edelim. Bu etkilerin olma olasılıklarını hesaplayalım.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#amerika-aile-büyüme-oranları",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#amerika-aile-büyüme-oranları",
    "title": "Uygulama - thinkstat2",
    "section": "Amerika Aile Büyüme Oranları",
    "text": "Amerika Aile Büyüme Oranları\n\nVeri’nin alındığı site: National Survey of Family Growth (NSFG)\nKullanacağımız veri, bir örneklem alarak yani Amerika’daki nüfusun bir kısmını seçerek elde edilmiş veridir.\nCycle 6 verisi kullanılacaktır. Burada cycle kelimesi sürekli alınan bir çalışmadaki her bir örneklem anlamına gelir. Bu çalışmadaki toplanan veri Ocak 2002- Mart 2003 yılları arasında alınmıştır.\nAmacımız: Amerika’daki annelerin hamilelik sürelerine bakacağız. İlk kez doğum yapan annelerin hamilelik süreleri daha uzun mu daha kısa mı belirleyeceğiz.\nKodkitabı (codebook): NSFG6 Codebook",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#veriyi-içeri-aktarma",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#veriyi-içeri-aktarma",
    "title": "Uygulama - thinkstat2",
    "section": "Veriyi İçeri aktarma",
    "text": "Veriyi İçeri aktarma\n\nveri_thinkStats2_2002FemPreg.dat.gz dosyası sıkıştırılmış, hamilelik veri dosyasıdır. Her bir satıra kayıt (record) adı verilmektedir.\nveri_thinkStats2_2002FemPreg.dct dosyası da veri dosyasının “dictionary” formatındaki halidir. Kabaca söylemek gerekirse verinin açıklamalarını içermektedir. Bu ve bunun gibi dict dosyaları ileride kullanılacaktır.\n\n\n\n\n\n\n\nDikkat\n\n\n\nBu kitapta kullanılan fonksiyonlardan bir class oluşturulmuştur. Ancak kod kısmı eski olduğu için bazı kısımlarını yenileyeceğiz ve kendimiz yazacağız.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#data-çerçeveleri",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#data-çerçeveleri",
    "title": "Uygulama - thinkstat2",
    "section": "Data Çerçeveleri",
    "text": "Data Çerçeveleri\nBu kitapta pandas paketi ile hazır olarak yazılmış fonksiyonlar kullanılarak yeni fonksiyonlar/class’lar tanımlanmıştır.\n\nDeğişkenler\nveri_thinkStats2_2002FemPreg.dct dosyası içerisinde 244 adet değişken vardır. Kitapta kullanılacak olan bazıları şunlardır:\n\ncaseid: Her bir kayıt (respondent) için bir benzersiz numara.\nprglngth: Hamilelik süresi (hafta)\noutcome: Doğum sonucu (1= sağlıklı doğum)\npregordr: Hamilelik sırası veya seri numarası: İlk hamilelik için 1, ikinci hamilelik için 2, vb.\nbirthord: Sağlıklı doğan çocuğun seri numarası: İlk doğan için 1, ikinci doğan için 2, vb.\nbirthwgt_lb ve birthwgt_oz: Doğum ağırlığı (pound) ve ağırlığın ons kısmı.\n\n1 oz = 28.34952 g (Ounce)\n1 lb = 0.45359237 kg (Pound)\n\nagepreg: Hamilelikteki yaş (yıl)\nfinalwgt: Her bir kayıt için ağırlıklandırılmış (weighted) nüfus sayısı. Bu ağırlıklandırma, Amerika’daki nüfusun dağılımını yansıtmaktadır.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#thinkstats2-modülü",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#thinkstats2-modülü",
    "title": "Uygulama - thinkstat2",
    "section": "thinkstats2 Modülü",
    "text": "thinkstats2 Modülü\nBu bölümde başkasının yazdığı thinkstats2 modülünü kullanacağız. Bu modülün içeriğine bu linkten erişebilirsiniz.\nBu modülü bilgisayarınıza indirin. Eğer klasör olarak indirdiyseniz aşağıdaki gibi import edebilirsiniz.\n\n# ============================\n# thinkStats2 ile ilgili modülleri içeri aktarmak için gereken kod\nfrom sys import path \nfrom os import getcwd\nfrom os.path import join\nPWD = getcwd()\n# Insert modules path\npath.insert(0, join(PWD, \"thinkStats2\"))\n# ============================\n\nimport thinkstats2\n\nEğer dosyaları ayrı ayrı indirdiyseniz, dosyaları çalışacağınız scriptin içerisine almanız yeterli olacaktır.\n\nHistogramların thinkstats Paketindeki Temsili\nthinkstats2 paketinin içerisinde histogram oluşturucu (constructor) vardır.\n\n# ============================\n# thinkStats2 ile ilgili modülleri içeri aktarmak için gereken kod\nfrom sys import path \nfrom os import getcwd\nfrom os.path import join\nPWD = getcwd()\n# Insert modules path\npath.insert(0, join(PWD, \"thinkStats2\"))\n# ============================\n\nimport thinkstats2\n\n# Historgram oluşturucu. Veri: [1,2,2,3,5]\nhist= thinkstats2.Hist([1,2,2,3,5])\nprint(f\"hist objesi: {hist}\")\nprint(f\"hist objesindeki 2'nin frekansı: {hist.Freq(2)}\")\nprint(f\"hist objesinin ikinci elemanı: {hist[2]}\")\nprint(f\"hist objesindeki 4'nin frekansı: {hist.Freq(4)}\")\nprint(f\"hist objesinin dördüncü elemanı: {hist[4]}\")\nprint(f\"hist objesinin değerleri: {hist.Values()}\")\nprint(\"-\"*20)\n# Hist objesinin elemanlarına erişmek\nfor it in sorted(hist.Values()):\n    print(f\"hist[{it}] = {hist[it]}\")\nprint(\"-\"*20)\nfor val, freq in hist.Items():\n    print(f\"hist[{val}] = {freq}\")\nprint(\"-\"*20)\n\nhist objesi: Hist({1: 1, 2: 2, 3: 1, 5: 1})\nhist objesindeki 2'nin frekansı: 2\nhist objesinin ikinci elemanı: 2\nhist objesindeki 4'nin frekansı: 0\nhist objesinin dördüncü elemanı: 0\nhist objesinin değerleri: dict_keys([1, 2, 3, 5])\n--------------------\nhist[1] = 1\nhist[2] = 2\nhist[3] = 1\nhist[5] = 1\n--------------------\nhist[1] = 1\nhist[2] = 2\nhist[3] = 1\nhist[5] = 1\n--------------------\n\n\n\n\nHistogramların thinkstats Kullanarak Çizimi\npandas paketinde histogram çizimine eşdeğer olarak thinkplot paketinde de histogram çizim fonksiyonu vardır. thinkplot paketinin içeriğine bu linkten erişebilirsiniz.\nAyrıntılı bilgi için: http://greenteapress.com/thinkstats2/thinkplot.html\n\n# ============================\n# thinkStats2 ile ilgili modülleri içeri aktarmak için gereken kod\nfrom sys import path \nfrom os import getcwd\nfrom os.path import join\nPWD = getcwd()\n# Insert modules path\npath.insert(0, join(PWD, \"thinkStats2\"))\n# ============================\n\nimport pandas as pd\nimport thinkstats2\nimport thinkplot\n# Historgram oluşturucu. Veri: [1,2,2,3,5]\nhist= thinkstats2.Hist([1,2,2,3,5])\n# Histogram çizimi\nthinkplot.Hist(hist)\n# Histogram çizimini göster\nthinkplot.Show(xlabel=\"Değer\", ylabel=\"Frekans\")\n# Aynı işlemi pandas ile yapalım\ndS= pd.Series([1,2,2,3,5])\n# Histogram çizimi\ndS.plot(kind='hist', xlabel=\"Değer\", ylabel=\"Frekans\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNSFG (National Survey of Family Growth) Değişkenleri\n2002 Yılında sağlık doğan çocukların ağırlıklarını veren histogram grafiğini çizelim. Bunun için nsfg modülünü kullanacağız.nsfg paketinin içeriğine bu linkten erişebilirsiniz.\n\n# ============================\n# thinkStats2 ile ilgili modülleri içeri aktarmak için gereken kod\nfrom sys import path \nfrom os import getcwd, pardir\nfrom os.path import join, abspath\nPWD = getcwd()\n# Insert modules path\npath.insert(0, join(PWD, \"thinkStats2\"))\n# ============================\n\n# ============================\n# thinksStats2 dizini\nthinkStats_dir= join(PWD, \"thinkStats2\")\n# ============================\n\n# ============================\n# Verilerin olduğu dizin\n# 3 üst dizine çık\nveri_dir = join(abspath(join(\\\n    PWD, pardir, pardir, pardir))\\\n        , 'veri')\n# ============================\n\n# Modüller\nimport nsfg\nimport thinkplot\nimport thinkstats2\n\n# Veriyi nsfg.ReadFemPreg() fonksiyonu ile oku\npreg= nsfg.ReadFemPreg(dct_file=join(veri_dir,\\\n    'veri_thinkStats2_2002FemPreg.dct'),\\\n    dat_file=join(veri_dir,\\\n        'veri_thinkStats2_2002FemPreg.dat.gz'))\n# Kitapta bu adım aşağıdaki gibi verilmiştir.\n# preg = nsfg.ReadFemPreg()\n\n# preg[preg.outcome==1] =&gt; preg.outcome sütunundaki sadece 1 olan değerleri seç.\n# Değişken \"outcome: 1= live birth, Yani sağlıklı doğum\nlive= preg[preg.outcome==1]\n\n# Aynı işlemi pandas ile yapmak isterseniz aşağıdaki gibi bir kod yazabilirsiniz.\n#import pandas as pd \n#a= pd.Series([1,2,3,4,5])\n#print(a)\n#print(a[1])\n#print(a[a &gt; 3])\n\n# # Histogram oluşturucu\nhist = thinkstats2.Hist(live.birthwgt_lb, label='Ağırlık (lb)')\n# # Histogram çizimi (thinkplot)\nthinkplot.Hist(hist)\nthinkplot.Show(xlabel='pounds', ylabel='Frekans')\n\n\n\n\n\n\n\n\n&lt;Figure size 768x576 with 0 Axes&gt;\n\n\nYukarıdaki grafikten de görüleceği sağlıklı doğan çocukların büyük bir çoğunluğu 7 pound (3.175 kg) ağırlığında doğmaktadır. Burada en sık tekrar eden veri (mod, ortanca değer) yani en yüksek frekansa sahip olan veri 7’dir. Bu değere mod adı verilir.\nBu histogramın şekli normal dağılım şeklindedir. Bu dağılımın bir diğer adı da Gauss dağılımı’dır. Bu dağılımın bazı özellikleri:\n\nOrtanca değer mod değerine eşittir.\nMod değerinin solunda ve sağında eşit olasılıkla dağılmış veriler vardır yani simetriktir.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#aykırı-değerler-outliers",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#aykırı-değerler-outliers",
    "title": "Uygulama - thinkstat2",
    "section": "Aykırı Değerler (Outliers)",
    "text": "Aykırı Değerler (Outliers)\nBazen verilerin dağılımında aykırı (outlier) değerler ortaya çıkar. Bu aykırı değerler veri toplanmasında veya çeşitli sebeplerden dolayı veri çatımızda olmuş olabilir. Bu değerleri analiz yaparken çıkartmamız gerekecektir.\nÖrneğin:\nHamilelik süre verisinde 10 haftadan düşük değerleri atmamız gerekecektir. Bu değer prglngth değişkeni ile verilir.\n\n# ============================\n# thinkStats2 ile ilgili modülleri içeri aktarmak için gereken kod\nfrom sys import path \nfrom os import getcwd, pardir\nfrom os.path import join, abspath\nPWD = getcwd()\n# Insert modules path\npath.insert(0, join(PWD, \"thinkStats2\"))\n# ============================\n\n# ============================\n# thinksStats2 dizini\nthinkStats_dir= join(PWD, \"thinkStats2\")\n# ============================\n\n# ============================\n# Verilerin olduğu dizin\n# 3 üst dizine çık\nveri_dir = join(abspath(join(\\\n    PWD, pardir, pardir, pardir))\\\n        , 'veri')\n# ============================\n\nimport nsfg\nimport thinkplot\nimport thinkstats2\n# Oku\npreg= nsfg.ReadFemPreg(dct_file=join(veri_dir,\\\n    'veri_thinkStats2_2002FemPreg.dct'),\\\n    dat_file=join(veri_dir,\\\n        'veri_thinkStats2_2002FemPreg.dat.gz'))\n\n# Sağlıklı doğumları seç\nlive= preg[preg.outcome==1]\n\n# Histogram oluşturucu\nhist = thinkstats2.Hist(live.prglngth, label='Aykırı Değerli')\n# Histogram çizimi\nthinkplot.Hist(hist)\nthinkplot.Show(xlabel='Hafta', ylabel='Frekans')\n\n# Aykırı değerleri çıkartıp tekrar çizdirme\n# live.prglngth[live.prglngth &gt; 10] =&gt; 10 haftadan büyük olanları seç\nhist2 = thinkstats2.Hist(live.prglngth[live.prglngth &gt; 10], label='Aykırı Değersiz')\n# Histogram çizimi\nthinkplot.Hist(hist2)\nthinkplot.Show(xlabel='Hafta', ylabel='Frekans')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;Figure size 768x576 with 0 Axes&gt;",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#ilk-bebekler",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#ilk-bebekler",
    "title": "Uygulama - thinkstat2",
    "section": "İlk Bebekler",
    "text": "İlk Bebekler\nBu bölüme başlarken ilk anektodumuzdan hatırlayalım:\n\n“İlk çocuklar için hamilelik süresi daha uzundur.”\n\nBu anektodun doğruluğunu görmek için annelerin gebelik sürelerine bakmamız gerekecek. İlk ve ikinci (sonrası) bebekler için kaç hafta gebelik süresi olduğunun histogramını çizelim. Bebeklerin aile içerisinde kaçıncı olduklarını birthord değişkeni ile verilir. Eğer birthord = 1 ise ilk bebektir.\n\n# ============================\n# thinkStats2 ile ilgili modülleri içeri aktarmak için gereken kod\nfrom sys import path \nfrom os import getcwd, pardir\nfrom os.path import join, abspath\nPWD = getcwd()\n# Insert modules path\npath.insert(0, join(PWD, \"thinkStats2\"))\n# ============================\n\n# ============================\n# thinksStats2 dizini\nthinkStats_dir= join(PWD, \"thinkStats2\")\n# ============================\n\n# ============================\n# Verilerin olduğu dizin\n# 3 üst dizine çık\nveri_dir = join(abspath(join(\\\n    PWD, pardir, pardir, pardir))\\\n        , 'veri')\n# ============================\n\nimport nsfg\nimport thinkplot\nimport thinkstats2\n# Oku\npreg= nsfg.ReadFemPreg(dct_file=join(veri_dir,\\\n    'veri_thinkStats2_2002FemPreg.dct'),\\\n    dat_file=join(veri_dir,\\\n        'veri_thinkStats2_2002FemPreg.dat.gz'))\n# Sağlıklı doğumları seç\nlive= preg[preg.outcome==1]\n\n# İlk bebekler\nilkBebekler= live[live.birthord==1]\n\n# Sonraki bebekler\nsonrakiBebekler= live[live.birthord!=1] # Referanslara bakın.\n\n# Histogram oluşturucu, ilk bebekler\nilkHist= thinkstats2.Hist(ilkBebekler.prglngth, label='İlk Bebek')\n# Histogram oluşturucu, sonraki bebekler\nsonrakiHist= thinkstats2.Hist(sonrakiBebekler.prglngth, label='Sonraki Bebekler')\n\n# Histogram çiziminde dekorasyon\nwidth = 0.45 # barların arasına boşluk bırakmak için. Varsayılan 0.9\nthinkplot.PrePlot(2) # 2 tane çizim yapılacak (aynı grafikte)\nthinkplot.Hist(ilkHist, align='right', width=width) # Sağdaki çizim\nthinkplot.Hist(sonrakiHist, align='left', width=width) # Soldaki çizim\nthinkplot.Show(xlabel='Hafta', ylabel='Frekans', xlim=[27, 46])\n\n# Ekrana yazdır\nprint(f\"İlk bebeğin gebelik süre ortalaması       : {ilkBebekler.prglngth.mean()}\")\nprint(f\"Sonraki bebeklerin gebelik süre ortalaması: {sonrakiBebekler.prglngth.mean()}\")\nprint(\"-\"*20)\nprint(f\"İlk bebeğin gebelik süresi, standat sapma        : {ilkBebekler.prglngth.std(ddof=0)}\")\nprint(f\"Sonraki bebeklerin gebelik süresi, standat sapma : {sonrakiBebekler.prglngth.std(ddof=0)}\")\nprint(\"-\"*20)\nprint(f\"İlk bebeğin gebelik süre verisinin boyutu       : {ilkBebekler.prglngth.size}\")\nprint(f\"Sonraki bebeklerin gebelik süre verisinin boyutu: {sonrakiBebekler.prglngth.size}\")\n\n\n\n\n\n\n\n\nİlk bebeğin gebelik süre ortalaması       : 38.60095173351461\nSonraki bebeklerin gebelik süre ortalaması: 38.52291446673706\n--------------------\nİlk bebeğin gebelik süresi, standat sapma        : 2.791585069824391\nSonraki bebeklerin gebelik süresi, standat sapma : 2.6155761106844744\n--------------------\nİlk bebeğin gebelik süre verisinin boyutu       : 4413\nSonraki bebeklerin gebelik süre verisinin boyutu: 4735\n\n\n&lt;Figure size 768x576 with 0 Axes&gt;\n\n\n\nİstatistiksel olarak, gebelik süresi ile kaçıncı doğum yapıldığı arasında bir doğrudan ilişki yoktur?\n\n\n\n\n\n\n\nUyarı\n\n\n\nKitapta “mean” olarak yukarıdaki değerden bahsedilme, “average” ise merkezi eğilimdeki mod olarak ifade edilmektedir. Biz bu iki kavram için şimdilik “ortalama” ve “mod” terimlerini kullanacağız.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#problemler",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#problemler",
    "title": "Uygulama - thinkstat2",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nYeni doğan sağlıklı bebeklerin ağırlıklarının (pounds biriminde, birthwgt_lb) dağılımını inceledik. Aşağıdaki işlemleri yapın ve ilgili soruları cevaplayın.\n\nAynı işlemi doğumun ounce kısmı için yapın (birthwgt_oz değişkeni ile.) Bu kısımı virgülden sonraki kısım olarak düşünebilirsiniz.\n\nDağılım için beklentiniz (estimation) nedir? Neden?\nBazı değerlerin frekansı neden daha fazla?\n\nAynı işlemi kilogram biriminde yapın (dönüşüm yaparak değişkeni ile.)\nDoğum yapan annelerin yaşlarını, yani agepreg değişkeni ile elde ettiğiniz dağılımı çizdirin.\n\nDağılım tipi nedir?\nAtadığınız değişkenin tipini type() ekrana yazdırın.\nBu dağılımın modu nedir?\nBu dağılımın medyanı nedir?\nBu dağılım simetrik mi?\nEn genç ve en yaşlı annelerin yaşları nedir?\n\nDoğum sürelerini, yani prglngth değişkeni ile elde ettiğiniz dağılımı çizdirin.\n\nDağılım tipi nedir?\nBu dağılımın modu nedir?\nBu dağılımın medyanı nedir?\nEn uzun ve en kısa doğum süreleri nedir?\n21 haftadan küçük değerleri ve 45 haftadan büyük değerleri aykırı değer olarak kabul edin. Bu aykırı değerlerin sayısı nedir?\nAykırı değerlerin toplam veriye oranı nedir?\nSadece aykırı değerleri çizdirin.",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik/uygulama-thinkstat2.html#kaynaklar",
    "href": "icerik/konular/istatistik/uygulama-thinkstat2.html#kaynaklar",
    "title": "Uygulama - thinkstat2",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nThink Stats: Probability and Statistics for Programmers, Allen B. Downey, Franklin W. Olin, Green Tea Press, 2014\nThink Stats: Github\nPython’da “!=” , “is not” gibi operatörlerin farkı",
    "crumbs": [
      "**Konular**",
      "İstatistik",
      "Uygulama - thinkstat2"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi.html",
    "href": "icerik/konular/fourier-analizi.html",
    "title": "Fourier Analizi",
    "section": "",
    "text": "Fourier analizi, matematik ve mühendislikte temel bir rol oynayan güçlü bir araçtır. İsmini 18. yüzyıl Fransız matematikçisi Joseph Fourier’den alan bu analiz yöntemi, karmaşık dalgaları basit sinüzoidal bileşenlere ayırarak, doğrusal olmayan sistemlerin incelenmesinde ve sinyal işlemede kullanılır. Başlangıçta ısı iletimi problemlerini çözmek için geliştirilmiş olmasına rağmen, günümüzde birçok disiplinde geniş bir uygulama alanı bulmuştur. Ses, görüntü ve veri işleme gibi alanlarda sıklıkla kullanılan Fourier analizi, bir sinyalin frekans bileşenlerini ayrıştırarak, karmaşıklığı anlamamıza ve sistemleri daha iyi anlamamıza olanak tanır.\nFourier dönüşümü, bir sinyalin zaman alanındaki işaretini frekans alanına dönüştürmek için integral hesabını kullanır. Bu dönüşüm, sürekli zamanlı sinyaller için integral formunda ifade edilirken, aynı prensibi kullanarak, dijital sinyaller için de uygulanabilir.\nFourier analizi, ses işleme, görüntü işleme, telekomünikasyon, sinyal işleme ve birçok fiziksel ve mühendislik uygulamasında yaygın olarak kullanılır. Örneğin, bir ses dosyasının frekans içeriğini analiz ederek, hangi frekanslardaki seslerin baskın olduğunu belirleyebiliriz. Benzer şekilde, bir elektrik devresinin frekans tepkisi incelenebilir veya bir görüntünün frekans bileşenleri üzerinde işlem yapılabilir. Bu şekilde, Fourier analizi, karmaşık sistemlerin anlaşılmasına ve işlenmesine olanak sağlar.  [1]",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi.html#fourier-analizi",
    "href": "icerik/konular/fourier-analizi.html#fourier-analizi",
    "title": "Fourier Analizi",
    "section": "",
    "text": "Fourier analizi, matematik ve mühendislikte temel bir rol oynayan güçlü bir araçtır. İsmini 18. yüzyıl Fransız matematikçisi Joseph Fourier’den alan bu analiz yöntemi, karmaşık dalgaları basit sinüzoidal bileşenlere ayırarak, doğrusal olmayan sistemlerin incelenmesinde ve sinyal işlemede kullanılır. Başlangıçta ısı iletimi problemlerini çözmek için geliştirilmiş olmasına rağmen, günümüzde birçok disiplinde geniş bir uygulama alanı bulmuştur. Ses, görüntü ve veri işleme gibi alanlarda sıklıkla kullanılan Fourier analizi, bir sinyalin frekans bileşenlerini ayrıştırarak, karmaşıklığı anlamamıza ve sistemleri daha iyi anlamamıza olanak tanır.\nFourier dönüşümü, bir sinyalin zaman alanındaki işaretini frekans alanına dönüştürmek için integral hesabını kullanır. Bu dönüşüm, sürekli zamanlı sinyaller için integral formunda ifade edilirken, aynı prensibi kullanarak, dijital sinyaller için de uygulanabilir.\nFourier analizi, ses işleme, görüntü işleme, telekomünikasyon, sinyal işleme ve birçok fiziksel ve mühendislik uygulamasında yaygın olarak kullanılır. Örneğin, bir ses dosyasının frekans içeriğini analiz ederek, hangi frekanslardaki seslerin baskın olduğunu belirleyebiliriz. Benzer şekilde, bir elektrik devresinin frekans tepkisi incelenebilir veya bir görüntünün frekans bileşenleri üzerinde işlem yapılabilir. Bu şekilde, Fourier analizi, karmaşık sistemlerin anlaşılmasına ve işlenmesine olanak sağlar.  [1]",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik.html",
    "href": "icerik/konular/istatistik.html",
    "title": "İstatistik",
    "section": "",
    "text": "Bu bölümde, fizikte veri analizinin temel aracı olan istatistiksel kavramları inceleyeceğiz. İstatistik, verileri toplayıp düzenlemeyi, analiz etmeyi ve yorumlamayı içeren bir bilim dalıdır. Deneylerden, gözlemlerden veya simülasyonlardan elde edilen verileri kullanarak, fiziksel sistemlerin davranışları hakkında bilgi edinmek ve tahminlerde bulunmak için kullanılır.\n\n\nİstatistik, verileri sayısal olarak özetler ve grafikler ile sunarak, kalıpları ve eğilimleri ortaya çıkarmayı amaçlar. Ortalama, standart sapma, frekans dağılımları gibi kavramlar, verilerin genel özelliklerini anlamamıza yardımcı olur. Korelasyon ve regresyon gibi istatistiksel yöntemler ise, iki veya daha fazla değişken arasındaki ilişkileri incelememizi sağlar.\n\n\n\nİstatistik, fizikte birçok farklı alanda kullanılır. Örneğin, deneysel verilerin analizinde, hataların hesaplanmasında, teorik modellerin doğrulanmasında, yeni materyallerin geliştirilmesinde ve fiziksel sistemlerin davranışlarının tahmin edilmesinde kullanılır. Fizikte istatistik kullanımıyla ilgili bazı örnekler şunlardır:\n\nParçacık Fiziği: Deneysel verilerden temel parçacıkların özelliklerini ve etkileşimlerini anlamak için istatistiksel yöntemler kullanılır.\nKozmoloji: Evrenin genişlemesini ve oluşumunu incelemek için büyük miktarda gökbilim verisi istatistiksel olarak analiz edilir.\nYoğun Madde Fiziği: Malzemelerin iletkenlik, manyetizma ve süperiletkenlik gibi özelliklerini incelemek için istatistiksel mekanik kullanılır.\nİstatistiksel Termodinamik: Sistemlerin termal dengedeki davranışlarını istatistiksel yöntemler kullanarak incelemek için kullanılır.\nSinyal İşleme: Deneysel verilerden gürültüyü ayıklamak ve sinyallerin özelliklerini belirlemek için istatistiksel yöntemler kullanılır.\n\nBazı kaynaklar aşağıda listelenmiştir.\n\narxiv.org, Statistical Mechanics hakkında yazılan tüm makaleler\nBrief Review of Statistical Mechanics\nStatistical Mechanics by Konstantin K. Likharev",
    "crumbs": [
      "**Konular**",
      "İstatistik"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik.html#istatistik-fizikte-verileri-anlamak-ve-yorumlamak",
    "href": "icerik/konular/istatistik.html#istatistik-fizikte-verileri-anlamak-ve-yorumlamak",
    "title": "İstatistik",
    "section": "",
    "text": "Bu bölümde, fizikte veri analizinin temel aracı olan istatistiksel kavramları inceleyeceğiz. İstatistik, verileri toplayıp düzenlemeyi, analiz etmeyi ve yorumlamayı içeren bir bilim dalıdır. Deneylerden, gözlemlerden veya simülasyonlardan elde edilen verileri kullanarak, fiziksel sistemlerin davranışları hakkında bilgi edinmek ve tahminlerde bulunmak için kullanılır.\n\n\nİstatistik, verileri sayısal olarak özetler ve grafikler ile sunarak, kalıpları ve eğilimleri ortaya çıkarmayı amaçlar. Ortalama, standart sapma, frekans dağılımları gibi kavramlar, verilerin genel özelliklerini anlamamıza yardımcı olur. Korelasyon ve regresyon gibi istatistiksel yöntemler ise, iki veya daha fazla değişken arasındaki ilişkileri incelememizi sağlar.\n\n\n\nİstatistik, fizikte birçok farklı alanda kullanılır. Örneğin, deneysel verilerin analizinde, hataların hesaplanmasında, teorik modellerin doğrulanmasında, yeni materyallerin geliştirilmesinde ve fiziksel sistemlerin davranışlarının tahmin edilmesinde kullanılır. Fizikte istatistik kullanımıyla ilgili bazı örnekler şunlardır:\n\nParçacık Fiziği: Deneysel verilerden temel parçacıkların özelliklerini ve etkileşimlerini anlamak için istatistiksel yöntemler kullanılır.\nKozmoloji: Evrenin genişlemesini ve oluşumunu incelemek için büyük miktarda gökbilim verisi istatistiksel olarak analiz edilir.\nYoğun Madde Fiziği: Malzemelerin iletkenlik, manyetizma ve süperiletkenlik gibi özelliklerini incelemek için istatistiksel mekanik kullanılır.\nİstatistiksel Termodinamik: Sistemlerin termal dengedeki davranışlarını istatistiksel yöntemler kullanarak incelemek için kullanılır.\nSinyal İşleme: Deneysel verilerden gürültüyü ayıklamak ve sinyallerin özelliklerini belirlemek için istatistiksel yöntemler kullanılır.\n\nBazı kaynaklar aşağıda listelenmiştir.\n\narxiv.org, Statistical Mechanics hakkında yazılan tüm makaleler\nBrief Review of Statistical Mechanics\nStatistical Mechanics by Konstantin K. Likharev",
    "crumbs": [
      "**Konular**",
      "İstatistik"
    ]
  },
  {
    "objectID": "icerik/konular/istatistik.html#programlama-dilleri-ve-istatistiksel-analizler",
    "href": "icerik/konular/istatistik.html#programlama-dilleri-ve-istatistiksel-analizler",
    "title": "İstatistik",
    "section": "Programlama Dilleri ve İstatistiksel Analizler",
    "text": "Programlama Dilleri ve İstatistiksel Analizler\nPython ve R programlama dilleri, istatistiksel analizler için yaygın olarak kullanılan iki programlama dilidir. Bu diller, veri okumanıza ve temizlemenize, istatistiksel testler yapmanıza, grafikler oluşturmanıza ve karmaşık modeller kurmanıza olanak tanır. Python ve R’de istatistiksel analizler için kullanılan birçok paket mevcuttur. Bunlardan en popülerleri şunlardır.\n\nPython: NumPy, SciPy, Pandas, Matplotlib, Seaborn\nR: base, ggplot2, dplyr, tidyverse\n\nBu içerik Google Gemini 1.0 Pro model kullanılarak üretilmiştir [1].",
    "crumbs": [
      "**Konular**",
      "İstatistik"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html",
    "title": "SDP - Atış Yöntemi",
    "section": "",
    "text": "Aşağıdaki denklemi çözelim.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y(b)=\\beta \\text{.}\n\\]\nBu denklemi başlangıç değer problemine çevirmeye çalışalım.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y'(a)=u \\text{.}\n\\]\nBulmamız gereken değer \\(u\\) değeridir. Bu değeri tahmin edeceğiz. Buradan diferansiyel denklemi tıpkı başlangıç değer problemi gibi \\(a\\)’dan \\(b\\)’ye kadar çözeceğiz. Bulduğumuz çözümün son noktasındaki değerde yani \\(y_{cozum}(b)\\), \\(\\beta\\)’yu bulana kadar bu işleme devam edeceğiz.\nSistematik bir tahmin yürütme mekanizması kurmamız lazım. Bunun için \\(y(b)\\), \\(u\\)’nun bir fonksiyonu olsun tanımlaması yapalım.\n\\[\ny(b)= \\theta(u) \\text{.}\n\\]\nBuradan \\(u\\) değerini bulmak için yukarıda verilen denklemin kökünü bulmamız lazım.\n\\[\n\\theta(u)- \\beta \\equiv r(u) = 0 \\text{.}\n\\]\nBuradaki \\(r(u)\\) fonksiyonuna artık fonksiyon (residual function) denir. Bu fonksiyonun kökü \\(u\\) değeridir. \\(u\\) değerini biliyorsak sınır değer probleminden çevirdiğimiz başlangıç değer problemini çözebiliriz.\nArtık fonksiyonunun kökü \\(u\\) değerini verecek. Kök bulmak için Ridder’in yöntemi kullanabiliriz. (Bisection veya Newton-Raphson yöntemleri değil.)\n\n\n\nİkinci dereceden diferansiyel denklemimiz var. \\(y''=f(x,y(x),y')(x)\\).\nÇözüm kümesinin sınır değerlerini biliyoruz. \\(y(a)=\\alpha\\), \\(y(b)=\\beta\\).\nBizim çözebildiğimiz denklem tipinde başlangıç koşulları \\(y(a)=\\alpha\\) ve \\(y'(a)=u\\) şeklinde olmalı.\n\\(u\\) değerini tahmin edelim.\nTahmin ettiğimiz \\(u\\) değerini kullanarak \\(y''=f(x,y(x),y'(x))\\) denklemini \\(b\\) noktasına kadar çözelim.\nElde ettiğimiz çözümün \\(b\\)’deki değeri \\(y(b)=\\beta\\) değerini veriyor mu? Eğer vermiyorsa \\(u\\) değerini değiştirerek tekrar deneyelim.\n\\(u\\)’nun bu değişimi sanki bir fonksiyon gibi olsun. Yukarıda bahsettiğimiz \\(\\theta(u)\\) fonksiyonu budur.\n\\(\\theta(u)\\) fonksiyonu \\(\\beta\\)’ya eşit olursa \\(u\\) değerini bulduk demektir. Yani \\(\\theta(u)- \\beta = 0\\) denkleminin kökünü bulmaya çalışıyoruz.\n\\(y(b)=\\beta\\) değerine yeteri kadar yaklaştı ise \\(u\\) değerini yani başlangıç koşulunu yani \\(y(x)\\) fonksiyonunu bulduk demektir.\nDenklem çözüldü.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#atış-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#atış-yöntemi",
    "title": "SDP - Atış Yöntemi",
    "section": "",
    "text": "Aşağıdaki denklemi çözelim.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y(b)=\\beta \\text{.}\n\\]\nBu denklemi başlangıç değer problemine çevirmeye çalışalım.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y'(a)=u \\text{.}\n\\]\nBulmamız gereken değer \\(u\\) değeridir. Bu değeri tahmin edeceğiz. Buradan diferansiyel denklemi tıpkı başlangıç değer problemi gibi \\(a\\)’dan \\(b\\)’ye kadar çözeceğiz. Bulduğumuz çözümün son noktasındaki değerde yani \\(y_{cozum}(b)\\), \\(\\beta\\)’yu bulana kadar bu işleme devam edeceğiz.\nSistematik bir tahmin yürütme mekanizması kurmamız lazım. Bunun için \\(y(b)\\), \\(u\\)’nun bir fonksiyonu olsun tanımlaması yapalım.\n\\[\ny(b)= \\theta(u) \\text{.}\n\\]\nBuradan \\(u\\) değerini bulmak için yukarıda verilen denklemin kökünü bulmamız lazım.\n\\[\n\\theta(u)- \\beta \\equiv r(u) = 0 \\text{.}\n\\]\nBuradaki \\(r(u)\\) fonksiyonuna artık fonksiyon (residual function) denir. Bu fonksiyonun kökü \\(u\\) değeridir. \\(u\\) değerini biliyorsak sınır değer probleminden çevirdiğimiz başlangıç değer problemini çözebiliriz.\nArtık fonksiyonunun kökü \\(u\\) değerini verecek. Kök bulmak için Ridder’in yöntemi kullanabiliriz. (Bisection veya Newton-Raphson yöntemleri değil.)\n\n\n\nİkinci dereceden diferansiyel denklemimiz var. \\(y''=f(x,y(x),y')(x)\\).\nÇözüm kümesinin sınır değerlerini biliyoruz. \\(y(a)=\\alpha\\), \\(y(b)=\\beta\\).\nBizim çözebildiğimiz denklem tipinde başlangıç koşulları \\(y(a)=\\alpha\\) ve \\(y'(a)=u\\) şeklinde olmalı.\n\\(u\\) değerini tahmin edelim.\nTahmin ettiğimiz \\(u\\) değerini kullanarak \\(y''=f(x,y(x),y'(x))\\) denklemini \\(b\\) noktasına kadar çözelim.\nElde ettiğimiz çözümün \\(b\\)’deki değeri \\(y(b)=\\beta\\) değerini veriyor mu? Eğer vermiyorsa \\(u\\) değerini değiştirerek tekrar deneyelim.\n\\(u\\)’nun bu değişimi sanki bir fonksiyon gibi olsun. Yukarıda bahsettiğimiz \\(\\theta(u)\\) fonksiyonu budur.\n\\(\\theta(u)\\) fonksiyonu \\(\\beta\\)’ya eşit olursa \\(u\\) değerini bulduk demektir. Yani \\(\\theta(u)- \\beta = 0\\) denkleminin kökünü bulmaya çalışıyoruz.\n\\(y(b)=\\beta\\) değerine yeteri kadar yaklaştı ise \\(u\\) değerini yani başlangıç koşulunu yani \\(y(x)\\) fonksiyonunu bulduk demektir.\nDenklem çözüldü.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#alıştırma-1",
    "title": "SDP - Atış Yöntemi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nAşağıda verilen difarensiyel denklemi atış yöntemi ile çözelim. \\[\ny''(t) = -g, \\qquad y(0)=0, \\qquad y(5)=50 \\text{.}\n\\]\n\nÇözüm\nÇözüm adımlarından dördüncü olan ile başlayalım. \\(u\\) değerini tahmin edelim. \\(u=25\\) olsun. Bu değerle denklemi çözelim. Çözeceğimiz denklem aşağıdaki gibi olacak.\n\\[\ny''(t) = -g, \\qquad y(0)=0, \\qquad y'(5)=25 \\text{.}\n\\]\nBu denklemin çözümü\n\\[\n\\begin{align*}\n    y'(t)&= -gt + C_{1} \\text{,} \\qquad y'(5)=25 \\text{ ,} \\\\\n         &= -gt + 25 \\text{ ,} \\\\\n     y(x)&= -\\frac{gt^2}{2} + 25t + C_{2} \\text{,} \\qquad y(0)=0 \\text{,} \\\\\n         &= -\\frac{gt^2}{2} + 25t \\text{.}\n\\end{align*}\n\\]\nŞimdi tahminimiz doğru mu deneyelim. Yani \\(y(t=5)\\) değeri \\(50\\) mi olacak?\n\\[\ny(t=5)= -\\frac{10\\times 25}{2} + 25\\times 5 = 0 \\ne 50 \\text{.}\n\\]\nYanlış! Farklı bir \\(u\\) değeri almamız gerekecek. Aynı işlemi \\(u=40\\) ile tekrarlayalım. Sonuç:\n\\[\ny(t)=-\\frac{gt^2}{2} + 40t\n\\]\nOlacak denersek eğer \\(y(5)=75\\) olacak ve yanlış olacak.\nTeker teker denemek yerine \\(u\\) değeri sanki bir fonksiyonmuş gibi davranalım.\n\\[\n\\theta(u) - 50 = 0\\text{.}\n\\]\nO halde \\(\\theta(u)\\) fonksiyonu başlangıç değer probleminin çözümüne bağlı. Bunu bir fonksiyon gibi tanımlayıp kökünü bulalım. Bu fonksiyon kodda şöyle tanımlanacak. u değeri girdi olacak. Bu u değerine göre başlangıç değer problemini çözecek. Çözümün son değeri \\(y(5)\\) değeri olacak. Bu değer ile \\(50\\) değeri arasındaki farkı döndürecek. Bu farkın kökünü bulmak için scipy.optimize.ridder(fonksiyon, kok_araligi_baslangic, kok_araligi_bitis) fonksiyonunu kullanacağız.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.integrate as scInteg\nimport scipy.optimize as scOpt\n# Diff. Denk:\n# y'' = -10 , y(0)=0 , y(5)=50\n# Fonksiyon:\ndef fonk_SDP(t, y):\n    # y[0]= y\n    # y[1]= v\n    return np.array([y[1], -10])\n# Başlangıç Koşulları\nt0=0.0\ntSon=5.0\ny0= 0.0  # y(0) = 0\nySon= 50. # y(5) = 50\n# v(0) = u (Bilmiyoruz)\n# Theta fonksiyonu:\ndef thetaFonk(u):\n    #solve_ivp(fonksiyon, t_span, y0)\n    # t_span=[t0, tStop] (y(0) ve y(1) değerini biliyoruz.)\n    cozum = scInteg.solve_ivp(fonk_SDP, [t0, tSon], [y0, u])\n    \n    # İkinci derece diferansiyel denklemin çözümü\n    # cozum.y[0] = y(t)\n    # cozum.y[1] = v(t)\n    yCozum = cozum.y[0]\n    # yCozum bir array. Son elemanı yani y(t=5) değeri bizim için önemli.\n    # Bu da yCozum[-1] ile alınır.\n    # Eğer bulduğumuz yCozum[-1] değeri ySon değerine eşitse u değerini bulduk demektir.\n    return yCozum[-1]- ySon\n# ---------------------------\n# Theta fonksiyonunun içerini şöyle düşünelim.\n# Polinom tipi bir g(x)=x^2+4x+4 fonksiyonu olsun. Bunun kökünü şöyle bulurduk.\n'''\ndef g(x):\n    return x**2 + 4*x + 4\n\n# Kökünü 0 ile 10 arasında bul.\nx0, = scOpt.ridder(g, 0, 10)\n'''\n# ---------------------------\n# theta fonksiyonunun kökünü bulalım.\nthetaU_kok_v0= scOpt.ridder(thetaFonk, 0, 50)\n# Olması gereken başlangıç değeri:\nprint(f\"v0= {thetaU_kok_v0} m/s\")\n# Deneyelim. Gerçekten v0 bu değerdeyken y(5)= 50 oluyor mu?\ncozum= scInteg.solve_ivp(fonk_SDP, [t0, tSon], [y0, thetaU_kok_v0])\n# Son değerleri karşılaştıralım.\nprint(f\"y(t=5) Bulduğumuz Çözüm: {cozum.y[0][-1]:.1f} m\")\nprint(f\"y(t=5) Gerçek Değer    : {ySon} m\")\n\nv0= 35.000000000001016 m/s\ny(t=5) Bulduğumuz Çözüm: 50.0 m\ny(t=5) Gerçek Değer    : 50.0 m\n\n\nPython ile ne yaptık?\n\nSanki başlangıç değer problemi çözer gibi fonksiyon tanımladık.\nBaşlangıç koşullarını tanımladık. İkinci başlangıç değeri yani \\(y(b)\\) değerini tanımlamadık.\nAyrı bir fonksiyon ile başlangıç değer problemini çözdük. Bu fonksiyonun girdi değeri u, dönüş dğeri ise verilen \\(y(b)\\) değeri ile çözümün son değerinin farkıdır.\nBaşlangıç değer çözücü denklemi scipy.optimize.ridder(fonksiyon, kok_araligi_baslangic, kok_araligi_bitis) ile çözdük.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#problemler",
    "title": "SDP - Atış Yöntemi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAşağıdaki denklemi atış yöntemi ile çözün.\n\\[\ny''(t)=t, \\quad y(0)=1, \\quad y(3)=9\n\\]\n\nElde ettiğiniz çözümü yani \\(y(t)\\) fonksiyonunu çizdirin.\nBu denklemi analitik olarak çözün ve çözümü de çizdirin.\n\n\n\nProblem 2\nAşağıdaki diferansiyel denklemi atış yöntemini kullanarak çözün. Adım aralığını \\(h=0.05\\) alın. Analitik sonuçla karşılaştırın.\n\\[\ny''(t) = t^{3}+t+5, \\quad y(0)=1, \\quad y(6)=545.8\n\\]\n\n\nProblem 3\n\nAşağıdaki diferansiyel denklemi atış (shooting) yöntemini kullanarak çözün.\nÇözümün grafiğini çizdirin. Sayısal çözüm noktalarını kırmızı nokta olarak belirleyin.\n\n\\[\n\\frac{d^{2}y(x)}{dx^{2}}+ \\frac{dy(x)}{dx} = -4 \\text{ ,}\n\\]\nSınır koşulları: \\(y(0)=0\\), \\(y(3)=9\\).\nBu soruyu çözerken kökü \\(-30\\) ile \\(30\\) arasında arayın.\n\nAşağıda verilen analitik çözümü de aynı grafikte çizdirin.\n\n\\[\ny(x) = \\frac{\\left(-4x + 21e^{3 - x} + e^{3}(4x - 21)\\right)}{1 - e^3} \\text{ .}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#kaynaklar",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#kaynaklar",
    "title": "SDP - Atış Yöntemi",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Methods in Engineering with Python 3, Jaan Kiusalaas, Cambridge University Press, 2013, Syf:293\nPython Programming and Numerical Methods: A Guide for Engineers and Scientists, Qingkai Kong & Timmy Siauw & Alexandre Bayen, 2020, chapter23.02-The-Shooting-Method",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html",
    "title": "BDP - Euler Yöntemi",
    "section": "",
    "text": "Euler yöntemi diferansiyel denklem çözümü için kullanılan en basit yöntemdir.\nAlternatif isimleri Euler-Cauchy veya nokta-eğim (point-slope) yöntemidir.\nKabaca türevin tanımını kullanır.\n\n\\[\ny'(x)= \\frac{y(x+h)-y(x)}{h}\n\\]\nÇözüm olarak Taylor serisini kullanacağız. \\[\ny(x+h)=y(x)+h\\times y'(x)+\\cdot\n\\]\n\nAmacımız başlangıç koşulundan itibaren adım adım \\(y(x)\\) fonksiyonunu bulmaktır. \\(x\\) noktasından \\(x+h\\) noktasına ilerlediğimiz için bu yöntem “ileri adım” yöntemidir.\n\n\n\n\n\n\n\nNot\n\n\n\nAlternatif olarak her (x+h) noktası için integral de alabiliriz ancak diferansiyel denklem çözerken sayısal integral alma yöntemleri kullanmak sakıncalıdır.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#başlangıç-değer-problemi---euler-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#başlangıç-değer-problemi---euler-yöntemi",
    "title": "BDP - Euler Yöntemi",
    "section": "",
    "text": "Euler yöntemi diferansiyel denklem çözümü için kullanılan en basit yöntemdir.\nAlternatif isimleri Euler-Cauchy veya nokta-eğim (point-slope) yöntemidir.\nKabaca türevin tanımını kullanır.\n\n\\[\ny'(x)= \\frac{y(x+h)-y(x)}{h}\n\\]\nÇözüm olarak Taylor serisini kullanacağız. \\[\ny(x+h)=y(x)+h\\times y'(x)+\\cdot\n\\]\n\nAmacımız başlangıç koşulundan itibaren adım adım \\(y(x)\\) fonksiyonunu bulmaktır. \\(x\\) noktasından \\(x+h\\) noktasına ilerlediğimiz için bu yöntem “ileri adım” yöntemidir.\n\n\n\n\n\n\n\nNot\n\n\n\nAlternatif olarak her (x+h) noktası için integral de alabiliriz ancak diferansiyel denklem çözerken sayısal integral alma yöntemleri kullanmak sakıncalıdır.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#hata-analizi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#hata-analizi",
    "title": "BDP - Euler Yöntemi",
    "section": "Hata Analizi",
    "text": "Hata Analizi\nBir uygulamada Taylor serisi kullanılırsa hata analizi aşağıdaki gibi yapılır. Farz edelim ki \\(f(x+h)\\) fonksiyonunu \\(f(x)\\) etrafında seriye açıyoruz ve \\(n\\)’nci dereceden terimden sonrasını atıyoruz. \\(E_{n}\\) terimi ise kestiğimiz terimden sonraki terimler yani hata terimi olarak tanımlansın.\n\\[\nf(x+h)=f(x)+f'(x)h+\\frac{f''(x)}{2!}h^2+\\cdots+\\frac{f^{(n)}(x)}{n!}h^n+E_{n}\n\\]\nHata terimi \\(E_{n}\\)’e kesme hatası (truncation error) adı verilir. Bu hatanın en büyük değeri Taylor teoreminden bulunabilir.\n\\[\nE_{n}=f^{n+1}(\\xi)\\frac{h^{n+1}}{(n+1)!}\n\\]\nBurada \\(\\xi\\), \\(x\\) ile \\(x+h\\) arasında bir değerdir. Bu değer ulaşılabilir değilse kesme hatasını belirleyen terim \\(h\\) adım aralığı olacaktır. Yani\n\\[\nE_{n}=\\mathcal{O}(h^{n+1})\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yöntemi-ile-çözümde-hata-analizi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yöntemi-ile-çözümde-hata-analizi",
    "title": "BDP - Euler Yöntemi",
    "section": "Euler Yöntemi ile Çözümde Hata Analizi",
    "text": "Euler Yöntemi ile Çözümde Hata Analizi\nEuler yöntemi kullanılırken her bir adımdaki kesme hatası \\(\\mathcal{O}(h^2)\\)’dir çünkü ikinci dereceden türev terimlerini ihmal ediyoruz. Her \\(h\\) adımda bu hata üst üste binecektir. Yani denklem \\(n\\) adımda çözülüyorsa kesme hatası da \\(n\\) kere tekrarlanacaktır.\n\\[\nE_{acc}=nE_{2}=\\frac{x_{n}-x_{0}}{h}E_{2}=O(h)\n\\]\nEuler yöntemi ile diferansiyel denklem çözümünde kesme hata payı \\(h\\) adım aralığı ile orantılı olacaktır.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-geometrik-tasviri",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-geometrik-tasviri",
    "title": "BDP - Euler Yöntemi",
    "section": "Euler Yönteminin Geometrik Tasviri",
    "text": "Euler Yönteminin Geometrik Tasviri\nBasitlik için çözmek istediğimiz \\(y(x)\\) fonksiyonu tek değişkene bağlı olsun. Bu fonksiyonun \\(x\\) ve \\(x+h\\) arasındaki değişimi aşağıdaki gibi olur  [1].\n\\[\ny(x+h)=y(x)+h\\times y'(x)\n\\]\nBuradan şu sonuç çıkarılabilir. Bulmak istediğimiz \\(y(x+h)\\) terimi, \\(y(x)\\) terimine ve o noktadaki eğiminin (türevinin) adım aralığı kadar katının toplamına eşittir.\n\n\n\nEuler Yönteminin Geometrik Tasviri",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-kodlanması",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-kodlanması",
    "title": "BDP - Euler Yöntemi",
    "section": "Euler Yönteminin Kodlanması",
    "text": "Euler Yönteminin Kodlanması\nadd_coz_euler adlı fonksiyon bilYonMod.py modülünde tanımlıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_euler fonksiyonunu inceleyiniz.\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nadd_coz_euler(fonk_y_x, xBaslangic, xBitis, yBaslangic, adimSayisi) fonksiyonunu çağırırken diferansiyel denklemin (\\(y'(x)=f(y,x)\\)) sağ tarafında yer alan ve çözmeniz gereken fonksiyonda, \\(f(y,x)\\), önce y ardından x tanımlanmalıdır. Yani kodda fonksiyon \\(f(y,x)\\) şeklinde yazılmalıdır. Burada \\(y\\) değişkeni \\(y(x)\\) olarak tanımlanır, \\(x\\) ise bağımsız değişkendir.\n\n\nAşağıdaki diferansiyel denklemi çözen bir örneği inceleyelim.\n\\[\n\\frac{d}{dx}y(x) = x, \\quad y(0)=1, \\quad x=[0, 1], \\quad n=10000\n\\]\nÇözüm aşağıdaki gibi olacaktır.\n\\[\ny(x)=1+\\frac{x^{2}}{2}\n\\]\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_y_x(y, x):\n    return x\n# Başlangıç koşulları\nx0 = 0\ny0 = 1\nxSon = 1\nn = 10\n# Çöz\nxTum, yTum = bym.add_coz_euler(fonk_y_x, x0, xSon, y0, n)\n# Çiz\nplt.plot(xTum, yTum, 'o-', color='r', label='Euler')\nplt.plot(xTum, 1+(xTum**2)/2, 'k', label='Analitik')\nplt.xlabel('$x$')\nplt.ylabel('$y(x)$')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#alıştırma-1",
    "title": "BDP - Euler Yöntemi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nEuler yöntemi ile aşağıdaki diferansiyel denklemi çözün ve analitik çözüm ile karşılaştırın.\n\\[\ny' + 4y = x^{2}, \\quad y(0)=1, \\quad x=[0, 0.03], \\quad n=10\n\\]\nAnalitik çözüm:\n\\[\ny(x)=\\frac{31}{32}e^{-4x} + \\frac{1}{4}x^{2}- \\frac{1}{8}x + \\frac{1}{32}\n\\]\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_y_x(y, x):\n    return -4*y + x**2\n# Başlangıç koşulları\nx0 = 0\ny0 = 1\nxSon = 0.03\nn = 10\n# Çöz\nxTum, yTum = bym.add_coz_euler(fonk_y_x, x0, xSon, y0, n)\n# Analitik çözüm\nyAnalitik=(31/32)*np.exp(-4*xTum) + (1/4)*(xTum**2) - (1/8)*xTum + (1/32)\n# Çiz\nplt.plot(xTum, yTum, 'o-', color='r', label='Euler')\nplt.plot(xTum, yAnalitik, 'k', label='Analitik')\nplt.xlabel('$x$')\nplt.ylabel('$y(x)$')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#problemler",
    "title": "BDP - Euler Yöntemi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nBasit bir RC devresi ele alalım. Bu devrede voltaj kaynağı olmasın, kondansatör \\(t=0\\) s’de \\(V_{0}=10\\) V gerilime sahip olsun. Devrede \\(R=220\\) k \\(\\Omega\\) direnci ve \\(C=10\\) \\(\\mu\\) F kondansatörü olsun. Devre bu haldeyken devreyi tamamlayalım. Devrenin voltajı-zaman grafiğini Euler yöntemi kullanarak çiziniz.\n\n\\[\nC\\frac{dV}{dt}+\\frac{V}{R}=0\n\\]\nAnalitik çözüm: \\(V(t) = V_{0}e^{-t/RC}\\)\n\n\nProblem 2\nThoryum-234’ün yarılanma ömrü \\(\\tau=24.1\\) gündür. \\(N_{0}=150\\) g saf Thoryum-234 izotopu \\(100\\) gün bekletilmektedir. İçerisinde kalan içerisinde kalan Thoryum-234 miktarı-zaman grafiğini Euler metodu kullanarak çiziniz.\n\\[\n\\frac{dN}{dt}= -\\frac{\\ln 2}{\\tau}N\n\\]\nAnalitik çözüm: \\(N(t) = N_{0}e^{-t(\\ln 2/\\tau)}\\)",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html",
    "title": "BDP - Denklem Sistemleri",
    "section": "",
    "text": "Adi diferansiyel denklem sistemlerini çözmek için Euler yöntemini vektör haline getirip kullanabiliriz. Bunun için bilYonMod.py modülündende tanımlanan add_coz_euler_sistem(fonk_yVek_x, xBaslangic, xBitis, yBaslangic_vek, adimSayisi) fonksiyonunu kullanılmalıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_euler_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#bdp---denklem-sistemleri",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#bdp---denklem-sistemleri",
    "title": "BDP - Denklem Sistemleri",
    "section": "",
    "text": "Adi diferansiyel denklem sistemlerini çözmek için Euler yöntemini vektör haline getirip kullanabiliriz. Bunun için bilYonMod.py modülündende tanımlanan add_coz_euler_sistem(fonk_yVek_x, xBaslangic, xBitis, yBaslangic_vek, adimSayisi) fonksiyonunu kullanılmalıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_euler_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#euler-yönteminin-denklem-sistemleri-için-uygulanması",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#euler-yönteminin-denklem-sistemleri-için-uygulanması",
    "title": "BDP - Denklem Sistemleri",
    "section": "Euler Yönteminin Denklem Sistemleri İçin Uygulanması",
    "text": "Euler Yönteminin Denklem Sistemleri İçin Uygulanması\nÖrneğin aşağıdaki denklem sistemini ele alalım. Denklem sisteminde iki adet birbirinden bağımsız diferansiyel denklem olsun. Bu denklemleri, bilgisayar açısından daha ekonomik olması adına birlikte çözülmelidir. (Az döngü, vektörleştirme, paralelleştirme, …)\n\\[\n\\begin{align*}\n    \\frac{d}{dx}y(x) &= x \\\\\n    \\frac{d}{dx}v(x) &= x^{2}\n\\end{align*}\n\\]\nDenklem sistemi vektör haline getirilirse aşağıdaki gibi olur.\n\\[\n\\begin{align*}\n    \\vec{y}'(x) &= \\begin{bmatrix} y'(x,v) \\\\ v'(x,y) \\end{bmatrix} = \\begin{bmatrix} x \\\\ x^{2} \\end{bmatrix}\n\\end{align*}\n\\]\nBaşlangıç koşulları \\(y(0)=1\\) ve \\(v(0)=1\\) olsun. Çözüm aralığını \\(x=0\\) ile \\(x=10\\) arasında bulmaya çalışalım, \\(x=[0,10]\\). Çözüm adım sayısı \\(n=100\\) olsun.\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_yVek_x(yVek, x):\n    y = yVek[0]\n    v = yVek[1]\n    dydx = x\n    dvdx = x**2\n    return np.array([dydx, dvdx])\n# Başlangıç koşulları\ny0 = 1\nv0 = 1\nx0 = 0\nxSon = 10\nn = 100\n# Çöz\n# xTum, yTum_Vek= add_coz_euler_sistem(fonk_yVek_x, xBaslangic, xBitis, yBaslangic_vek, adimSayisi)\n# yTum_Vek[0] =&gt; y(x)\n# yTum_Vek[1] =&gt; v(x)\nxTum, yTum_Vek = bym.add_coz_euler_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Analitik çözüm\nyAnalitik = xTum**2/2 + 1\nvAnalitik = xTum**3/3 + 1\n# Çiz\nplt.plot(xTum, yTum_Vek[0], 'o-', color='red', label='y(x)')\nplt.plot(xTum, yAnalitik, label='y(x) analitik', color='black', linestyle='--')\nplt.plot(xTum, yTum_Vek[1], 'o-',label='v(x)', color='blue')\nplt.plot(xTum, vAnalitik, label='v(x) analitik', color='cyan', linestyle='--')\nplt.xlabel('x')\nplt.ylabel('y(x), v(x)')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#alıştırma-1",
    "title": "BDP - Denklem Sistemleri",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBirbirine bağlı iki adet diferansiyel denklemi çözmek için Euler yöntemini kullanınız.\nDenklem sistemi aşağıdaki gibidir.\n\\[\n\\begin{align*}\n\\frac{d}{dx}y(v,x) &= v(x) \\\\\n\\frac{d}{dx}v(x) &= x\n\\end{align*}\n\\]\nDenklem sistemi vektör haline getirilirse:\n\\[\n\\begin{align*}\n\\vec{y}'(x) &= \\begin{bmatrix} y'(v,x) \\\\ v'(x) \\end{bmatrix} = \\begin{bmatrix} v(x) \\\\ x \\end{bmatrix}\n\\end{align*}\n\\]\nBu durumda sağ taraftaki vektör fonksiyonu aşağıdaki gibi tanımlanır.\n\ndef fonk_yVek_x(yVek, x):\n    # İlk çözülmesi gereken denklem y'(v,x) = v(x). \n    # fonk_yVek_x fonksiyonu girdi olarak (yVek,x) alacak. Bu yVek vektörünün\n    # ilk elemanı y'(x) 'in sağ tarafı olmalı. dydx diyelim.\n    # dydx &lt;= yVek[0]\n    dydx = yVek[1]\n    # İkinci çözülmesi gereken denklem v'(y,x) = x.\n    # fonk_yVek_x fonksiyonu girdi olarak (yVek,x) alacak. Bu yVek vektörünün\n    # ikinci elemanı v'(x) 'in sağ tarafı olmalı. dvdx diyelim.\n    # dvdx &lt;= yVek[1] \n    # dvdx = x\n    # Sonuç olarak da [dydx, dvdx] vektörünü döndürmeli.\n    return np.array([dydx, x])\n\nBaşlangıç koşulları \\(y(0)=1\\) ve \\(v(0)=0\\) olsun. Çözüm aralığı \\(x=0\\) ile \\(x=10\\) arasında olsun. Çözüm adım sayısı \\(n=100\\) olsun.\nAnalitik çözümü elde ederken önce \\(v(x)\\)’i çözmek gerekir. \\(v(x)=\\frac{x^2}{2}\\) olur. Bu durumda \\(y(x)=\\frac{x^3}{6}+1\\) olur.\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_yVek_x(yVek, x):\n    dydx = yVek[1]\n    return np.array([dydx, x])\n# Başlangıç koşulları\ny0 = 1\nv0 = 0\nx0 = 0\nxSon = 10\nn = 100\n# Çöz\nxTum, yTum_Vek = bym.add_coz_euler_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Analitik çözüm\nyAnalitik = xTum**3/6 + 1\nvAnalitik = xTum**2/2\n# Çiz\nfig, ax = plt.subplots(1, 2)\n# Sol grafik\nax[0].plot(xTum, yTum_Vek[0], 'o-', label='y(x)', color='red')\nax[0].plot(xTum, yAnalitik, label='y(x) analitik', color='black', linestyle='--')\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\nax[0].legend()\n# Sağ grafik\nax[1].plot(xTum, yTum_Vek[1], 'o-', label='v(x)', color='blue')\nax[1].plot(xTum, vAnalitik, label='v(x) analitik', color='cyan', linestyle='--')\nax[1].set_xlabel('x')\nax[1].set_ylabel('v(x)')\nax[1].legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#problemler",
    "title": "BDP - Denklem Sistemleri",
    "section": "Problemler",
    "text": "Problemler\n\nProblemi 1\nLorenz atraktörünün denklemini Euler yöntemiyle çözünüz. Sabitler için \\(\\rho=28\\), \\(\\sigma=10\\) ve \\(\\beta=8/3\\) alınız. Başlangıç koşullarını: \\(x_{0}=1\\), \\(y_{0}=1\\) ve \\(z_{0}=1\\) olarak alınız. En iyi sonucu görebilmek için \\(t=0-10\\) aralığında ve \\(n= 1000\\) adımda yapınız. 3 boyutlu grafik çizilirse ünlü şekil ortaya çıkacaktır.\n\\[\n\\frac{dx}{dt}=\\sigma(y-x)\n\\]\n\\[\n\\frac{dy}{dt}=x(\\rho-z)-y\n\\]\n\\[\n\\frac{dz}{dt}=xy-\\beta z\n\\]\n\n\nProblem 2\nLotka-Volterra Modelini Euler yöntemiyle çözünüz. Sabitler için \\(a=1.5\\), \\(b=1\\), \\(c=3\\) ve \\(d=1\\) alınız. Başlangıç koşulu olarak 10 tavşan (\\(x_{0}\\)) ve 5 vaşak (\\(y_{0}\\)) alınız. En iyi sonucu görebilmek için \\(t=0-20\\) aralığında ve \\(n= 1000\\) adımda yapınız. Bu model av-avcı popülasyonunu veya tavşan-vaşak popülasyonu simülasyonudur.\n\\[\n\\frac{dx}{dt}=ax-bxy\n\\]\n\\[\n\\frac{dy}{dt}=-cy+dxy\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "",
    "text": "Sonlu farklar yöntemini kullanarak sınır değer problemine ait diferansiyel denklem çözeceğiz. Bunun için Taylor açılımını kullanacağız. Taylor açılımında birinci türevi orta noktayı kullanarak yazalım.\n\\[\ny'_{i} = \\frac{y_{i+1}-y_{i-1}}{2h}\n\\]\nFarz edelim ki bu fonksiyonu \\(g_{i}\\) için yazmışız.\n\\[\ng'_{i} = \\frac{g_{i+1}-g_{i-1}}{2h}\n\\]\nBu \\(g_{i}\\) fonksiyonu \\(y'_{i}\\) fonksiyonuna eşit olsun. Yani \\(g_{i}=y'_{i}\\) olur. Bu durumda\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{y'_{i+1}-y'_{i-1}}{2h} \\\\\n            &= \\frac{1}{2h}\\left(\\frac{y_{i+2}-y_{i}}{2h}-\\frac{y_{i}-y_{i-2}}{2h}\\right)\n\\end{align*}\n\\]\nBiraz düzenleyelim.\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{1}{4h^2}\\left(y_{i+2}-y_{i}-y_{i}+y_{i-2}\\right) \\\\\n            &= \\frac{y_{i+2}-2y_{i}+y_{i-2}}{4h^2}\n\\end{align*}\n\\]\nEğer adım aralığını yarıya indirirsek yani \\(h \\rightarrow h/2\\) yaparsak \\(y_{i+2}\\) noktasından \\(y_{i+1}\\) noktasına gelebiliriz. Benzer şekilde \\(y_{i-2}\\) noktasından \\(y_{i-1}\\) noktasına geliriz. O halde ikinci türeve ait olan denklem şöyle olur.\n\n\n\n\n\n\nNot\n\n\n\nBu işlem sadece sabit adım aralığı için geçerlidir.\n\n\n\\[\ny''_{i} = \\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\nBu denklemi kullanarak sınır değer problemlerini çözeceğiz. Yukarıdaki bağıntı, diferansiyel denklemi cebirsel denklem sistemine dönüştürür.\n\\[\ny''_{i} = f\\left(x,y_{i},\\frac{y_{i+1}-y_{i-1}}{2h}\\right)=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yöntemi",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "",
    "text": "Sonlu farklar yöntemini kullanarak sınır değer problemine ait diferansiyel denklem çözeceğiz. Bunun için Taylor açılımını kullanacağız. Taylor açılımında birinci türevi orta noktayı kullanarak yazalım.\n\\[\ny'_{i} = \\frac{y_{i+1}-y_{i-1}}{2h}\n\\]\nFarz edelim ki bu fonksiyonu \\(g_{i}\\) için yazmışız.\n\\[\ng'_{i} = \\frac{g_{i+1}-g_{i-1}}{2h}\n\\]\nBu \\(g_{i}\\) fonksiyonu \\(y'_{i}\\) fonksiyonuna eşit olsun. Yani \\(g_{i}=y'_{i}\\) olur. Bu durumda\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{y'_{i+1}-y'_{i-1}}{2h} \\\\\n            &= \\frac{1}{2h}\\left(\\frac{y_{i+2}-y_{i}}{2h}-\\frac{y_{i}-y_{i-2}}{2h}\\right)\n\\end{align*}\n\\]\nBiraz düzenleyelim.\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{1}{4h^2}\\left(y_{i+2}-y_{i}-y_{i}+y_{i-2}\\right) \\\\\n            &= \\frac{y_{i+2}-2y_{i}+y_{i-2}}{4h^2}\n\\end{align*}\n\\]\nEğer adım aralığını yarıya indirirsek yani \\(h \\rightarrow h/2\\) yaparsak \\(y_{i+2}\\) noktasından \\(y_{i+1}\\) noktasına gelebiliriz. Benzer şekilde \\(y_{i-2}\\) noktasından \\(y_{i-1}\\) noktasına geliriz. O halde ikinci türeve ait olan denklem şöyle olur.\n\n\n\n\n\n\nNot\n\n\n\nBu işlem sadece sabit adım aralığı için geçerlidir.\n\n\n\\[\ny''_{i} = \\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\nBu denklemi kullanarak sınır değer problemlerini çözeceğiz. Yukarıdaki bağıntı, diferansiyel denklemi cebirsel denklem sistemine dönüştürür.\n\\[\ny''_{i} = f\\left(x,y_{i},\\frac{y_{i+1}-y_{i-1}}{2h}\\right)=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#alıştırma-1",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nAşağıdaki denklemi adım adım çözelim.\n\\[\ny''(t)=t, \\quad y(0)=1, \\quad y(3)=9\n\\]\n\nÇözüm (Elle)\nAdım aralığı \\(h=1\\) olsun. Çözeceğimiz \\(t\\)’nin değerleri \\(0, 1, 2, 3\\) olacaktır. Bu değerlerden \\(y\\) değerlerini bulalım.\n\\[\ny''(t)=t=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\nÇözüme \\(y(0)\\)’dan başlayalım. Bunun için \\(y(0) \\equiv y_{i-1}\\) almamız gerekecektir. Aksi taktirde köşe noktalar için denklemi çözemeyiz.\nAşağıdaki tabloyu \\(h=1\\) için yazalım.\n\n\n\n\\(y_{0}\\)\n\\(y_{1}\\)\n\\(y_{2}\\)\n\\(y_{3}\\)\n\n\n\n\n\\(y(0)\\)\n\\(y(0+h)\\)\n\\(y(0+2h)\\)\n\\(y(0+3h)\\)\n\n\n\\(y(t=0)\\)\n\\(y(t=1)\\)\n\\(y(t=2)\\)\n\\(y(t=3)\\)\n\n\n1\n?\n?\n9\n\n\n\nÖrneğin aşağıdaki tabloyu da \\(h=0.5\\) için yazalım.\n\n\n\n\n\n\n\n\n\n\n\n\n\\(y_{0}\\)\n\\(y_{1}\\)\n\\(y_{2}\\)\n\\(y_{3}\\)\n\\(y_{4}\\)\n\\(y_{5}\\)\n\\(y_{6}\\)\n\n\n\n\n\\(y(0)\\)\n\\(y(0.5)\\)\n\\(y(1)\\)\n\\(y(1.5)\\)\n\\(y(2)\\)\n\\(y(2.5)\\)\n\\(y(3)\\)\n\n\n1\n?\n?\n?\n?\n?\n9\n\n\n\nŞimdi yukarıdaki elde ettiğimiz denklemi yazalım.\n\\[\ny''(t)=t=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\n\\(i=1\\) olmalı. Bundan dolayı \\(t\\) ilk değil bir sonraki adımından yani \\(t+h=0+0.5\\)’den itibaren başlatmalıyız. \\[\n0.5 = \\frac{y_{2}-2y_{1}+y_{0}}{h^2}\n\\]\nBu denklemi \\(h=0.5\\) için adım adım yazalım.\n\\[\n\\begin{align*}\n    0.5\\times (0.5)^{2} =& y_{2}-2y_{1}+y_{0}\\\\\n    1\\times (0.5)^{2} =& y_{3}-2y_{2}+y_{1}\\\\\n    1.5\\times (0.5)^{2} =& y_{4}-2y_{3}+y_{2}\\\\\n    2\\times (0.5)^{2} =& y_{5}-2y_{4}+y_{3}\\\\\n    2.5\\times (0.5)^{2} =& y_{6}-2y_{5}+y_{4}\n\\end{align*}\n\\]\nYukarıdaki denklemleri matris şeklinde yazalım. Yazarken \\(y_{0}=1\\) ve \\(y_{6}=9\\) yazacağız.\n\\[\n\\begin{align*}\n-0.875 =& y_{2}-2y_{1}\\\\\n0.25 =& y_{3}-2y_{2}+y_{1}\\\\\n0.375 =& y_{4}-2y_{3}+y_{2}\\\\\n0.5 =& y_{5}-2y_{4}+y_{3}\\\\\n-8.375 =& -2y_{5}+y_{4}\n\\end{align*}\n\\]\nMatris şeklinde yazalım.\n\\[\n\\begin{bmatrix}\n    -2 & 1 & 0 & 0 & 0\\\\\n    1 & -2 & 1 & 0 & 0\\\\\n    0 & 1 & -2 & 1 & 0\\\\\n    0 & 0 & 1 & -2 & 1\\\\\n    0 & 0 & 0 & 1 & -2\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n    y_{1}\\\\\n    y_{2}\\\\\n    y_{3}\\\\\n    y_{4}\\\\\n    y_{5}\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\n    -0.875\\\\\n    0.25\\\\\n    0.375\\\\\n    0.5\\\\\n    -8.375    \n\\end{bmatrix}\n\\]\nBu denklemi çözmeyi biliyoruz. Denklemi çözdüğümüzde \\(y_{1}, y_{2}, y_{3}, y_{4}, y_{5}\\) değerlerini bulmuş oluruz.\n\n\nÇözüm (Kod)\n\nimport numpy as np\nfrom scipy.linalg import solve\nimport matplotlib.pyplot as plt\n# Katsayı Matrisi\ncoefMat= np.array([\\\n      [-2, 1, 0, 0, 0]\\\n    , [ 1,-2, 1, 0, 0]\\\n    , [ 0, 1,-2, 1, 0]\\\n    , [ 0, 0, 1,-2, 1]\\\n    , [ 0, 0, 0, 1,-2]])\n# Sonuç Matrisi\nsolMat= np.array([-0.875,0.25,0.375,0.5,-8.375])\n# Doğrusal Denklemi Çöz\nsolution=solve(coefMat, solMat)\n# Başlangıç Değeri\ny0= 1.\n# Çözümü Başına Ekle\nsolution=np.insert(solution, 0, y0)\n# Bitiş Değeri\nySon= 9.\n# Çözümü Sonuna Ekle\nsolution=np.append(solution, ySon)\n# Çözmek istediğimiz t değerleri\nt= np.linspace(0, 3, 7)\n# Çiz\nplt.plot(t, solution, 'o-', label='Sonlu Farklar')\n# --------------------------------------------\n# Analitik Çözüm\n# y''= t y(0)=1 y(3)=9\n# y'= t^2/2  + C1\n# y= t^3/6  + C1 t + C2\n# y(0)=1 =&gt; C2=1\n# y(3)=9 =&gt; 9=27/6 + 3C1 + 1=9 =&gt; C1=27/18\n#=&gt; y(t)= t^3/6 + 21t/18 + 1\n# --------------------------------------------\nplt.plot(t, t**3/6 + 21*t/18 + 1, 'r-', label='Analitik')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nMatris denklemini el ile yazmadan yani başlangıçta biz vermeden çözmeye çalışalım.\n\nimport numpy as np\nfrom scipy.linalg import solve\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk(t):\n    return t\n# Sınır Değerleri\ny_t0=1\ny_t3=9\n# Adım aralığı\nh=0.5\n# Tum t değerleri\nt0=0\ntSon=3\n# adet=(tSon-t0/h)+1\nadet= int((tSon-t0)/h)+1\ntTum=np.linspace(t0, tSon, adet)\n# Yerine koyduğumuzda oluşan denklemler (tabloya bakınız)\n# y''(t)=t = (y_{i+1}-2y_{i}+y_{i-1})/h^2\n# t * h^2 = y_{i+1}-2y_{i}+y_{i-1}\n# ilk denklem için t= h olacak. i=1 olacak\n# h * h^2 = y_{2}-2y_{1}+y_{0}\n# ilkDenklemSagTaraf= h*(h**2)-y_{0}\n# Son denklem için t= tSon-h olacak. i=son-1 olacak\n# (tSon-h) * h^2 = y_{son}-2y_{son-1}+y_{son-2}\n# sonDenklemSagTaraf=(tSon-h)*(h**2)-y_{son}\nilkDenklemSagTaraf=fonk(h)*(h**2)-y_t0\nsonDenklemSagTaraf=fonk(tSon-h)*(h**2)-y_t3\n# Ara denklemleri oluştur.\n# araDenklemlerSagTaraf[0]=ilkDenklemSagTaraf\naraDenklemlerSagTaraf=np.array(ilkDenklemSagTaraf)\nfor i in range(1, adet-3):\n    araDenklemlerSagTaraf= np.append(araDenklemlerSagTaraf, fonk(tTum[i+1])*(h**2))\n# Son denklemi ekle\nsonucMatrisi= np.append(araDenklemlerSagTaraf,sonDenklemSagTaraf)\n# Katsayı Matrisi\nkatsayiMat= np.zeros((adet-2, adet-2))\n# y''(t)=t = (y_{i+1}-2y_{i}+y_{i-1})/h^2\n# Denkleminde katsayılar hep aynı olur.\nfor i in range(adet-2):\n    katsayiMat[i, i]= -2\n    if not i == adet-3:\n        katsayiMat[i, i+1]= 1\n    if not i == 0:\n        katsayiMat[i, i-1]= 1\n# Çöz\nprint(f\"Katsayı Matrisi: \\n{katsayiMat}\")\nprint(f\"Sonuç Matrisi: \\n{sonucMatrisi}\")\ncozum=solve(katsayiMat, sonucMatrisi)\n# İlk Çözümü Ekle\ncozum=np.insert(cozum, 0, y_t0)\n# Son Çözümü Ekle\ncozum=np.append(cozum, y_t3)\n# Çiz\nplt.plot(tTum, cozum, 'o-', label='Sonlu Farklar')\nplt.plot(tTum, tTum**3/6 + 21*tTum/18 + 1, 'r-', label='Analitik')\nplt.legend()\nplt.show()\n\nKatsayı Matrisi: \n[[-2.  1.  0.  0.  0.]\n [ 1. -2.  1.  0.  0.]\n [ 0.  1. -2.  1.  0.]\n [ 0.  0.  1. -2.  1.]\n [ 0.  0.  0.  1. -2.]]\nSonuç Matrisi: \n[-0.875  0.25   0.375  0.5   -8.375]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yönteminin-çalışmadığı-örnek",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yönteminin-çalışmadığı-örnek",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Sonlu Farklar Yönteminin Çalışmadığı Örnek",
    "text": "Sonlu Farklar Yönteminin Çalışmadığı Örnek\nEğer oluşturduğumuz diferansiyel denklem sistemi doğrusal değilse, yukarıdaki algoritmayı kullanmayız. Aşağıdaki örneği inceleyelim.\n\\[\ny''(t)=tyy'(t)\n\\]\nÇözmemiz gereken denklem\n\\[\ny''(t)=tyy'(t)=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\n\\(i=1\\) için yazalım.\n\\[\nty_{1}y_{1}'=\\frac{y_{2}-2y_{1}+y_{0}}{h^2}\n\\]\nTürevi de açıkça yazalım.\n\\[\nty_{1} \\frac{y_{2}-y_{0}}{2h}=\\frac{y_{2}-2y_{1}+y_{0}}{h^2}\n\\]\nDüzenleyelim.\n\\[\n\\frac{th}{2} (y_{1}y_{2}-y_{1}y_{0}) -y_{2}+2y_{1}-y_{0} = 0\n\\]\n\\(y_{1}y_{2}\\) gibi terimlerin varlığından dolayı bu denklem doğrusal olmayan (nonlineer) denklemdir. Klasik yöntemlerle (LU ayrıştırma veya Gauss eleme) çözülemez.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#problemler",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAşağıdaki diferansiyel denklemi sonlu farklar yöntemi kullanarak çözebilir misinz?\n\\[\n\\frac{\\hbar^{2}}{2 m}\\frac{d^{2}}{dx^{2}}\\psi(x) = E\\psi(x), \\qquad \\psi(x=0)=0, \\qquad \\psi(x=L)=0 \\text{.}\n\\]\nÇözümü \\(n=1\\) ve \\(n=2\\) için bulmaya çalışın. Hem bulduğunuz enerji değerlerini hem de dalga fonksiyonunun karesini (olasılık yoğunluğunu, \\(|\\psi(x)|^{2}\\)) çizdirin. \\(x\\) değerleri \\(0\\) ile \\(L\\) arasında \\(N=100\\) adet olsun.\nDenklemdeki katsayıları aşağıdaki gibi alın.\n\n\\(\\hbar=1\\)\n\\(m=1\\) kg\n\\(L=2\\)\n\nEnerji özdeğerinin gerçek değeri aşağıdaki gibi olmalıdır.\n\\(E=\\frac{\\pi^{2}\\hbar^{2}}{2mL^{2}}n^{2}\\) J.\nDalga fonksiyonunun analitik çözümü aşağıdaki gibi olmalıdır.\n\\[\n\\psi(x)=\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi x}{L}\\right)\n\\]\n\n\n\n\n\n\nTavsiye\n\n\n\nBu problem bir özdeğer problemidir. Diferansiyel operatörü \\(\\left(\\frac{d^{2}}{dx^{2}}\\right)\\) doğrusal operatörü matris şeklinde yazmalısınız. Bu matrisi sonlu farklar yönteminde yazdık.\n\n\n\n\nProblem 2\nAşağıdaki diferansiyel denklemi sonlu farklar yöntemini kullanarak çözün. Adım aralığını \\(h=0.05\\) alın. Analitik sonuçla karşılaştırın.\n\\[\ny''(t) = t^{3}+t+5, \\quad y(0)=1, \\quad y(6)=545.8\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#kaynaklar",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#kaynaklar",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Methods in Engineering with Python 3, Jaan Kiusalaas, Cambridge University Press, 2013, Syf:307\nSonlu Farklar Yöntemi, Youtube Videosu\nNumerical Solutions of Schrodinger’s Equation, Neill Lambert, 2001",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html",
    "href": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html",
    "title": "THFD - Ters Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "Ters Hızlı Fourier Dönüşümü (IFFT), Hızlı Fourier Dönüşümü (FFT) sonucu elde edilen frekans bileşenlerini zaman alanına dönüştürmek için kullanılır.\nFrekans uzayındaki verilerden zaman uzayındaki sinyali elde etmek için kullanılır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "THFD - Ters Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#thfd---ters-hızlı-fourier-dönüşümü-ifft---inverse-fast-fourier-transform",
    "href": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#thfd---ters-hızlı-fourier-dönüşümü-ifft---inverse-fast-fourier-transform",
    "title": "THFD - Ters Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "Ters Hızlı Fourier Dönüşümü (IFFT), Hızlı Fourier Dönüşümü (FFT) sonucu elde edilen frekans bileşenlerini zaman alanına dönüştürmek için kullanılır.\nFrekans uzayındaki verilerden zaman uzayındaki sinyali elde etmek için kullanılır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "THFD - Ters Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#örnek",
    "href": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#örnek",
    "title": "THFD - Ters Hızlı Fourier Dönüşümü",
    "section": "Örnek",
    "text": "Örnek\nFrekans uzayında, kendimiz belirlediğimiz bir frekansın en yakın noktalara 1 değeri atanmış bir sinyal oluşturalım. Bu sinyali THFD ile zaman uzayına dönüştürelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Frekansı 5 Hz olan sinyal\nfrekans = 5\n# Maksimum Frekans\nmaxFrekans = 20\n# Toplam Orneklem\nN= maxFrekans*2\n# Frekans Çözünürlüğü\nfCoz = maxFrekans/N\n# Tum Frekanslar\nfrek = np.arange(-maxFrekans, maxFrekans, fCoz)\n# HFD değerleri\nhfdDegerleri= np.zeros(len(frek), dtype=np.complex128)\n# frek'in 5 Hz ve -5 Hz en yakın noktalara 1 değeri atanır\nhfdDegerleri[np.abs(frek - frekans).argmin()] = 1\nhfdDegerleri[np.abs(frek + frekans).argmin()] = 1\n# Çiz\nplt.stem(frek, np.abs(hfdDegerleri))\nplt.title(\"HFT\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.ylabel(\"$|X(f)|$\")\nplt.show()\n# THFD\nsinyal = np.fft.ifft(hfdDegerleri)\n# Zaman\nt= np.arange(0, N)\n# Çiz\nplt.plot(sinyal.real)\nplt.title(\"THFD\")\nplt.xlabel(\"Zaman (s)\")\nplt.ylabel(\"Genlik\")\nplt.xlim(0, 40)\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "THFD - Ters Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "",
    "text": "Basit bir dalgada periyot/frekans, genlik faz gibi kavramları anladık. Peki daha üst üste binen dalgaları nasıl analiz edeceğiz? Örneğin aşağıdaki gibi bir dalgayı analiz etmek istediğimizi düşünelim.\n\\[\ny(t) = \\sin(\\omega t + \\phi) + \\cos(2 \\omega t + \\phi)\n\\]\nÇizdirelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nt= np.arange(0, 4*np.pi, 0.01)\n# Dalganın acısal frekansı\nomega= 2* np.pi* 0.2\n# Çiz\nplt.plot(t, np.cos(omega*t)+ np.sin(2*omega*t), \n    'b', label= '$\\sin(0.4\\omega t)+ \\cos(0.4\\omega t)$')\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi,\n    5*np.pi/2, 3*np.pi, 7*np.pi/2, 4*np.pi],\n    [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\",\n     \"5$\\pi$/2\", \"3$\\pi$\", \"7$\\pi$/2\", \"4$\\pi$\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nBu şekildeki dalganın frekansı nedir sorusunu cevaplayamayız. Benzer şekilde üst üste binen dalgaların genlik bilgileri de açıkça gözükmemektedir.\nBuna benzer dalgaları analiz etmek için Fourier dönüşümü kullanılır. Fourier dönüşümü, bir dalgayı frekans bileşenlerine ayırır. Kesikli (bizim inceleyeceğimiz durum) ve sürekli olmak üzere iki farklı şekilde yapabiliriz.\nElimizde bir dalgayı temsil eden veri seti olsun. Bu veri setinin elemanlarına \\(N\\) adet örnek sayısı olup \\(x_{n}\\) değerlerinde bulunsunlar. Kesikli Fourier dönüşümünün formülü aşağıdaki gibidir. Her noktayı (örneklemi - sample) bir frekans bileşenine, \\(k\\), dönüştürür.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\[\nX_{k}= \\sum_{n=0}^{N-1} x_{n} \\left[ \\cos \\left( \\frac{2 \\pi k n}{N} \\right) - i \\sin \\left( \\frac{2 \\pi k n}{N} \\right) \\right]\n\\]\nBurada\n\nN: Örnek sayısı\nn: Örneklem numarası\nk: Frekans numarası (0, 1, 2, …, N-1)\n\\(x_{n}\\): n. örneğin değeri\n\\(X_{k}\\): KFD değeri (genlik ve faz değeri içerir.)\n\n\n\n\n\n\n\nNot\n\n\n\nPython’da ilk indeks değeri 0 olduğu için formül 0’dan başladı ve \\(N-1\\)’e kadar gitti.\n\n\nFormül bize kabaca şunu söylemektedir. Eğer \\(N\\) adet örnek sayımız varsa, bunu \\(N\\) adet frekansa sahip dalgaların toplamı şeklinde düşünebiliriz. \\(k\\) frekansına sahip olan dalganın değeri \\(X_{k}\\), faz değeri ise \\(\\phi_{k}\\) olacaktır.\nAşağıdaki şekilde birbirinden farklı genliğe ve frekansa sahip 3 dalganın üst üste binmesi ile açığa çıkan şekli görebilirsiniz  [1].",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfd---kesikli-fourier-dönüşümü-ddt---discrete-fourier-transform",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfd---kesikli-fourier-dönüşümü-ddt---discrete-fourier-transform",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "",
    "text": "Basit bir dalgada periyot/frekans, genlik faz gibi kavramları anladık. Peki daha üst üste binen dalgaları nasıl analiz edeceğiz? Örneğin aşağıdaki gibi bir dalgayı analiz etmek istediğimizi düşünelim.\n\\[\ny(t) = \\sin(\\omega t + \\phi) + \\cos(2 \\omega t + \\phi)\n\\]\nÇizdirelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nt= np.arange(0, 4*np.pi, 0.01)\n# Dalganın acısal frekansı\nomega= 2* np.pi* 0.2\n# Çiz\nplt.plot(t, np.cos(omega*t)+ np.sin(2*omega*t), \n    'b', label= '$\\sin(0.4\\omega t)+ \\cos(0.4\\omega t)$')\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi,\n    5*np.pi/2, 3*np.pi, 7*np.pi/2, 4*np.pi],\n    [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\",\n     \"5$\\pi$/2\", \"3$\\pi$\", \"7$\\pi$/2\", \"4$\\pi$\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nBu şekildeki dalganın frekansı nedir sorusunu cevaplayamayız. Benzer şekilde üst üste binen dalgaların genlik bilgileri de açıkça gözükmemektedir.\nBuna benzer dalgaları analiz etmek için Fourier dönüşümü kullanılır. Fourier dönüşümü, bir dalgayı frekans bileşenlerine ayırır. Kesikli (bizim inceleyeceğimiz durum) ve sürekli olmak üzere iki farklı şekilde yapabiliriz.\nElimizde bir dalgayı temsil eden veri seti olsun. Bu veri setinin elemanlarına \\(N\\) adet örnek sayısı olup \\(x_{n}\\) değerlerinde bulunsunlar. Kesikli Fourier dönüşümünün formülü aşağıdaki gibidir. Her noktayı (örneklemi - sample) bir frekans bileşenine, \\(k\\), dönüştürür.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\[\nX_{k}= \\sum_{n=0}^{N-1} x_{n} \\left[ \\cos \\left( \\frac{2 \\pi k n}{N} \\right) - i \\sin \\left( \\frac{2 \\pi k n}{N} \\right) \\right]\n\\]\nBurada\n\nN: Örnek sayısı\nn: Örneklem numarası\nk: Frekans numarası (0, 1, 2, …, N-1)\n\\(x_{n}\\): n. örneğin değeri\n\\(X_{k}\\): KFD değeri (genlik ve faz değeri içerir.)\n\n\n\n\n\n\n\nNot\n\n\n\nPython’da ilk indeks değeri 0 olduğu için formül 0’dan başladı ve \\(N-1\\)’e kadar gitti.\n\n\nFormül bize kabaca şunu söylemektedir. Eğer \\(N\\) adet örnek sayımız varsa, bunu \\(N\\) adet frekansa sahip dalgaların toplamı şeklinde düşünebiliriz. \\(k\\) frekansına sahip olan dalganın değeri \\(X_{k}\\), faz değeri ise \\(\\phi_{k}\\) olacaktır.\nAşağıdaki şekilde birbirinden farklı genliğe ve frekansa sahip 3 dalganın üst üste binmesi ile açığa çıkan şekli görebilirsiniz  [1].",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#örnek-elle",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#örnek-elle",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Örnek (Elle)",
    "text": "Örnek (Elle)\nElimizde 3 adet örnekleme sahip (3 nokta) bir dalga olsun. Yani sinüs dalgasını 3 adet nokta ile temsil edelim. Bu noktalardan oluşan dalganın frekans bileşenlerini bulmak için Fourier dönüşümünü adım adım yapalım.\n\\[\nX_{k} = \\sum_{n=0}^{2} x_{n} e^{-i 2 \\pi k n / 3}\n\\]\n\\[\n\\begin{align*}\n    X_{0}=& x_{0} e^{-i (2 \\pi 0\\times0) / 3} + x_{1} e^{-i (2 \\pi 0\\times1) / 3} + x_{2} e^{-i (2 \\pi 0\\times2) / 3}\\\\\n    =& x_{0} e^{0} + x_{1} e^{0} + x_{2} e^{0}\\\\\n    =& x_{0} + x_{1} + x_{2}\\\\\n    X_{1}= & x_{0} e^{-i (2 \\pi 1\\times0) / 3} + x_{1} e^{-i (2 \\pi 1\\times1) / 3} + x_{2} e^{-i (2 \\pi 1\\times2) / 3}\\\\\n    =& x_{0} e^{0} + x_{1} e^{-i 2 \\pi / 3} + x_{2} e^{-i 4 \\pi / 3}\\\\\n    =& x_{0} + x_{1} (\\cos(2 \\pi / 3) - i \\sin(2 \\pi / 3)) + x_{2} (\\cos(4 \\pi / 3) - i \\sin(4 \\pi / 3))\\\\\n    =& x_{0} + x_{1} (-0.5 - i 0.9) + x_{2} (-0.5 + i 0.9)\\\\\n    X_{2}= & x_{0} e^{-i (2 \\pi 2\\times0) / 3} + x_{1} e^{-i (2 \\pi 2\\times1) / 3} + x_{2} e^{-i (2 \\pi 2\\times2) / 3}\\\\\n    =& x_{0} + x_{1} e^{-i 4 \\pi / 3} + x_{2} e^{-i 8 \\pi / 3}\\\\\n    =& x_{0} + x_{1} (\\cos(4 \\pi / 3) - i \\sin(4 \\pi / 3)) + x_{2} (\\cos(8 \\pi / 3) - i \\sin(8 \\pi / 3))\\\\\n    =& x_{0} + x_{1} (-0.5 + i 0.9) + x_{2} (-0.5 - i 0.9)\n\\end{align*}\n\\]\nYukarıdaki denklemde \\(x_{0}=1\\), \\(x_{1}=2\\), \\(x_{2}=3\\) olarak alırsak \\(X_{0}=6\\), \\(X_{1}=-1.5 - i 0.9\\), \\(X_{2}=-1.5 + i 0.9\\) değerlerini buluruz.\n\n\n\n\n\n\nÖnemli\n\n\n\n\nHer zaman 0. değer \\(X_{0}= \\sum_{n=0}^{N-1} x_{n}\\) şeklinde olacaktır.\n\\(X_{n}\\) karmaşık bir sayıdır.\n\n\n\nBir dalganın frekanslarını belirlemek için Fourier dönüşümü kullanacağımızı söylemiştik ancak elde ettiğimiz frekanslar \\(X_{k}\\) karmaşık sayı olarak karşımıza çıktı. Gerçel (reel) frekans değerleri için \\(X_{k}\\) değerlerinin modülünü, \\(|X_{k}|\\), alacağız.\nSinyalin genliği \\(A_{k}\\) ve fazı \\(\\phi_{k}\\) ise aşağıdaki şekilde hesaplanır.\n\\[\nA_{k} = \\frac{|X_{k}|}{N}\n\\]\n\\[\n\\phi_{k} = \\arctan \\left( \\frac{Im(X_{k})}{Re(X_{k})} \\right)\n\\]\n\n\n\n\n\n\nUyarı\n\n\n\n\nEğer tek sayıda örnek varsa, yani \\(N\\) tek ise, k tane \\(X\\) değerlerinin 0’dan \\((N-1)/2\\) kadar olanlar pozitif frekanslı \\((N+1)/2\\)’den \\(N-1\\) kadar olanlar negatif frekanslı olarak tanımlanır.\nEğer çift sayıda örnek varsa, yani \\(N\\) çift ise, k tane \\(X\\) değerlerinin 0’dan \\((N/2)-1\\) kadar olanlar pozitif frekanslı \\((N/2)\\)’den \\(N-1\\) kadar olanlar negatif frekanslı olarak tanımlanır.\n\\(X_{k}\\) değerlerini hesaplarken modülünü aldığımızdan dolayı negatif frekanslı değerlerin modülü pozitif frekanslı değerlerin modülüne eşittir. Bu yüzden \\(X_{k}\\) değerlerini hesaplarken sadece pozitif frekanslı değerleri hesaplamak yeterlidir.\n\n\n\nYukarıdaki gibi örnek oranının yarısına Nyquist frekansı denir. Yani \\(N-1\\) üzerinden toplam almak yerine \\(N/2\\) üzerinden toplam alırsak Nyquist frekansına ulaşırız. Dalgaların frekanslarını bulurken bu konu daha ayrıntılı açıklanacaktır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tkfd---ters-kesikli-fourier-dönüşümü-idft---inverse-discrete-fourier-transform",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tkfd---ters-kesikli-fourier-dönüşümü-idft---inverse-discrete-fourier-transform",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "TKFD - Ters Kesikli Fourier Dönüşümü, (IDFT - Inverse Discrete Fourier Transform),",
    "text": "TKFD - Ters Kesikli Fourier Dönüşümü, (IDFT - Inverse Discrete Fourier Transform),\nKFD’nin tersi de yapılabilir. Yani \\(X_{k}\\) değerlerinden \\(x_{n}\\) değerlerini bulabiliriz. Ters DFT formülü aşağıdaki gibidir. Ters Fourier dönüşümü, frekans bileşenlerini zaman bileşenlerine dönüştürerek orjinal sinyali elde etmemize yarar. Formülü aşağıdaki gibidir.\n\\[\nx_{n} = \\frac{1}{N} \\sum_{k=0}^{N-1} X_{k} e^{i 2 \\pi k n / N}\n\\]\nTKFD ile yapılan işlemler, KFD ile yapılan işlemlerin neredeyse aynısıdır. Sadece eksponansiyel terim negatif değil pozitif olacaktır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfdnin-limitleri",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfdnin-limitleri",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "KFD’nin Limitleri",
    "text": "KFD’nin Limitleri\nDFT metodu ile bir sinyalin frekanslarını bulabiliriz ancak büyük bir sinyalde bu işlemi yapmak çok uzun sürecektir.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kod",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kod",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Kod",
    "text": "Kod\nfourier_kfd fonksiyonu bilYonMod.py dosyasına tanımlıdır. Aşağıdaki kodu inceleyelim ve örneklem sayısını kfd fonksyionunun gerçekleşme zamanını karşılaştıralım.\n\n\n\n\n\n\nNot\n\n\n\nfourier_kfd fonksiyonunu inceleyiniz.\n\n\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\n# 1 Boyutlu sinyal oluşturan fonksiyon\ndef olus_sin(orneklemOrani):\n    # Örneklem frekansı (rate)\n    ts = 1.0/orneklemOrani\n    # Örneklem aralığı\n    t = np.arange(0, 1, ts)\n    # Dalganın frekansı\n    frekans = 1.\n    # Genlik\n    genlik = 3\n    return genlik* np.sin(2* np.pi* frekans* t)\n# Orneklem Orani 1\norneklemOrani1 = 20\n# Toplam zamanı hesapla\nprint(f\"{orneklemOrani1} örneklem sayısına sahip bir dalganın\")\nprint(\"Fouirer dönüşümü yapması için geçen süre\")\n# FD Fonksiyonunu çağır ve %temit ile süreyi ölç\n%timeit bym.fourier_kfd(olus_sin(orneklemOrani1))\nprint(\"\\n\")\n# Orneklem Orani 2\norneklemOrani2 = 200\n# Toplam zamanı hesapla\nprint(f\"{orneklemOrani2} örneklem sayısına sahip bir dalganın\")\nprint(\" Fouirer dönüşümü yapması için geçen süre\")\n# FD Fonksiyonunu çağır ve %temit ile süreyi ölç\n%timeit bym.fourier_kfd(olus_sin(orneklemOrani2))\n\n20 örneklem sayısına sahip bir dalganın\nFouirer dönüşümü yapması için geçen süre\n566 μs ± 5.16 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n200 örneklem sayısına sahip bir dalganın\n Fouirer dönüşümü yapması için geçen süre\n54.9 ms ± 190 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\nZaman sorunu aşmak için 1965’te Cooley ve Tukey, Fourier dönüşümü algoritmasını geliştirdiler. Bu algoritma HFD, Hızlı Fourier Dönüşümü (FFT, Fast Fourier Transform) olarak bilinir - kesikli ifadesini kullanmacağız. HFD algoritması KFD’ye göre çok daha hızlı çalışır. HFD algoritmasının karmaşıklığı \\(\\mathcal{O}(n \\log n)\\) iken KFD’nin karmaşıklığı \\(\\mathcal{O}(n^2)\\)’dir.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tanımlar",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tanımlar",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Tanımlar",
    "text": "Tanımlar\nAlıştırmalara geçmeden önce bazı tanımlar yapalım ve kullanacağımız tanımları hatırlayalım.\nÖncelikle bir dalgadan bahsediyorsak bir tekrardan bahsedebiliriz. Bundan dolayı belli bir pencere seçip o penceredeki sinyali analiz edeceğiz.\n\nZaman Uzayı\n\n\nÖrneklem sayısı (# of samples): Bir sinyali kaç adet örnek ile betimliyoruz [adet], N.\nÖrneklem oranı (sampling rate): Bir saniye içerisinde kaç örneklem olduğunu veren ifade [1/saniye] orneklemOrani.\nÖrnekleme aralığı (sampling interval): İki örneklem arasının kaç saniye olduğunu veren ifade [saniye], orneklemAraligi.\nZaman, pencere boyutu (time, frame size): Bir sinyalin kaç saniye içerisinde olduğunu veren ifade [saniye], t.\n\n\nFrekans Uzayı\n\n\nMaksimum Frekans, Nyquist Frekansı (maximum frequency, Nyquist frequency): Bir sinyalin içerisindeki en yüksek frekans [Hz], maxFrek. Maksimum frekans değeri, örneklem oranının yarısına eşittir, maxFrek=orneklemOrani/2.\nFrekans sayısı, Spektral Çizgiler (# of frequency, spectral lines): Bir sinyalin içerisindeki frekanslar [Hz], frekSayisi. Frekans sayısı, örnek sayısının yarısına eşittir, frekSayisi=N/2, çünkü hem pozitif hem negatif frekanslar bulunur.\nFrekans Çözünürlülüğü: Frekans uzayindaki iki frekans arasındaki fark [Hz], frekCoz=maksFrek/frekSayisi.\nFrekans (frequency): Tüm frekanslar, frek\n\n\n\n\n\n\n\nNot\n\n\n\nDaha önceden belirttiğimiz gibi frekansların ilk yarısı pozitif, ikinci yarıs ise negatif olarak tanımlanır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-1",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-1",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBir sinüs sinyali, \\(\\sin(2\\pi f t)\\) düşünelim ve bunu \\([-2,2]\\) zaman aralığında çizelim.\n\nBu dalganın genlik-zaman grafiğini çizdirebilmek için frekans \\(f\\) değerini bilmem lazım. \\(f=4\\) [Hz] olsun frek=4.\nBu dalganın \\([-2,2]\\) arasında kaç nokta ile betimlediğimi belirtmem lazım. Örneklem sayısı \\(N=100\\) olsun, N=100.\nBu dalgan \\(N=100\\) ve toplam zaman \\(t=4\\) s için örneklem oranı \\(100/4\\) olurorneklemOrani=25. Bu değer, bir saniyede içerisinde \\(25\\) adet nokta olduğu anlamına gelir.\nBu dalganın örnekleme aralığı \\(1/25=0.04\\), orneklemAraligi=1/orneklemOrani. Bu değer, iki örneklem arasında \\(0.04\\) saniye olduğu anlamına gelir.\nZamanı oluşturabilirim. \\(t=-2\\)’den başlayıp \\(t=2\\)’ye kadar orneklemAraligi aralıklarla bir array oluşturum, t=np.arange(-2, 2, orneklemAraligi).\nKolayca gösterebilirsiniz ki zaman arrayinin eleman sayısı, t.size, örneklem sayısına, N’e, eşittir.\n\n\n\n\n\n\n\nUyarı\n\n\n\nt=np.arange(-2, 2, orneklemAraligi) kodunda \\(N=100\\) adet nokta vardır ancak son nokta, \\(t=2\\), noktası alınmamıştır.\n\n\n\nMaksiumum frekans değerini bulurken toplam örneklem sayısına ihtiyacımız vardır.\n\nÖrneklem sayısı çift olursa maksiumum frekans değeri \\(N/2\\) olur, maksFrek=N/2.\nÖrneklem sayısı tek olursa maksiumum frekans değeri \\((N-1)/2\\) olur, maksFrek=(N-1)/2.\n\nFrekans çözünürlülüğü bulurken örneklem sayısına ihtiyacımız vardır.\n\nÖrneklem sayısı çift olursa frekans çözünürlülüğü \\(maksFrek/frekSayisi\\) olur, frekCoz=maksFrek/(N/2).\nÖrneklem sayısı tek olursa frekans çözünürlülüğü \\(maksFrek/frekSayisi\\) olur, frekCoz=maksFrek/((N-1)/2).\n\nKFD sonucunda elde ettiğimiz \\(X_{k}\\) değerlerinin ilk yarısı pozitif, kalan yarısı ise negatif olarak tanımlanır.\n\nÖrneklem sayısı çift olursa, pozitif DFT değerleri şöyle olur: XPoz= X[:int(N/2)], negatif DFT değerleri şöyle olur: XNeg= X[int(N/2):].\nÖrneklem sayısı tek olursa, pozitif DFT değerleri şöyle olur: XPoz= X[:int((N-1)/2)], negatif DFT değerleri şöyle olur: XNeg= X[int((N+1)/2):].\n\nPozitif frekanslar frekPoz= np.arange(0, maksFrek, frekCoz) ve negatif frekanslar frekNeg= np.arange(-maksFrek, 0, frekCoz) şeklinde tanımlanır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-2",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-2",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\n\nAşağıdaki formülü verilen sinyali, 100 örneklem oranı kullanarak \\(-2\\pi,2\\pi\\) arasında çizdirin.\n\n\\[\ny(t) = 7 \\sin(2\\pi t)\n\\]\nBu sinyalin KFD’sini alın ve genlik ve faz değerlerini bulun.\n\nÇözüm\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Örneklem orani\norneklemOrani = 100\n# Örneklem aralığı\norneklemAraligi = 1.0/orneklemOrani\nt= np.arange(0, 6, orneklemAraligi)\n# Toplam örneklem sayısı\nN= t.size\n# Dalganın frekansı\nacisalFrekans= 10\ngenlik= 5\n# Çiz\nsinyal= genlik* np.sin(acisalFrekans* t)\nplt.plot(t, sinyal, 'b', label= f'${genlik} \\sin({acisalFrekans} t)$')\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.legend()\nplt.show()\nplt.close()\n# Kesikli Fourier Dönüşümü\nX = bym.fourier_kfd(sinyal)\n# Frekans\nif N%2 == 0:\n    maksFrek= N/ 2\n    frekCoz=maksFrek/ (N/2)\n    XPoz= X[:int(N/2)]\n    XNeg= X[int(N/2):]\nelse:\n    maksFrek= (N-1)/ 2\n    frekCoz=maksFrek/ ((N-1)/2)\n    XPoz= X[:int((N-1)/2)]\n    XNeg= X[int((N+1)/2):]\nfrekPoz= np.arange(0, maksFrek, frekCoz)\nfrekNeg= np.arange(-maksFrek, 0, frekCoz)\n# Genlik ve Faz Değerlerini Çiz\nplt.stem(frekPoz, np.abs(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\nplt.stem(frekNeg, np.abs(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.xlim(-acisalFrekans-10, acisalFrekans+10)\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#problemler",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#problemler",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAçısal frekansı 5, genliği 10 olan bir cosinüs sinyali çizdirin Örneklem oranı \\(100\\), \\(t=[0,6)\\) aralığında olsun. Sinyalin KFD’sini alın ve bu değerleri pozitif/negatif frekanslara göre çizdirin.\n\n\nProblem 2\nAçısal frekansı 5, genliği 10 olan bir cosinüs sinyali ve açısal frekansı 10, genliği 5 olan bir cosinüs sinyalinin toplamını çizdirin çizdirin Örneklem oranı \\(100\\), \\(t=[0,6)\\) aralığında olsun. Sinyalin KFD’sini alın ve bu değerleri pozitif/negatif frekanslara göre çizdirin.\n\n\nProblem 3\nZamandan bağımsız Schrödinger denklemini boşluk için çözdüğümüzde Gaussian dalga paketini elde ederiz. Konum uzayındaki dalga fonksiyonu aşağıdaki gibidir  [3].\n\\[ \\psi(x, t=0) = &lt;x | \\psi(0)&gt;= e^{-\\frac{(x^{2}- \\mu)}{4\\sigma_{x}^{2}}+i k_{0} x}\\]\nBurada \\(\\mu\\) paketin merkezini yani ortalama (mean) değeridir. \\(\\sigma_{x}\\) ise \\(x\\) uzayındaki standart sapmayı yani belirsizliği verir. \\(k_{0}= p/\\hbar\\) ise paketin momentumunu verir.\n\nYukarıda verilen dalga paketini konum uzayında olasılık yoğunluğunu çizdirin. Formülde \\(\\mu = 0\\), \\(\\sigma_{x} = 0.1\\) ve \\(k_{0} = 10\\) olarak alın.\nElde ettiğiniz dalga paketinin Fourier dönüşümünü hesaplayın.\n\nHFD sonucunu np.fft.fftshift fonksiyonu ile kaydırın. Bu işlem \\(k\\) uzayının \\(-k_{max}\\) ile \\(k_{max}\\) arasında yapın. Bunun için np.fft.fftshift(np.fft.fft(veri)) kullanabilirsiniz.\nFourier dönüşümünü \\(\\frac{2\\pi}{L}\\) ile normalize edin.\nFourier dönüşümünün frekansını belirleyin. Bunun için np.fft.fftshift(np.fft.fftfreq(L, dx)) formülünü kullanabilirsiniz.\n\nFourier dönüşümünden elde ettiğiniz Gaussian dalga paketinin momentum uzayındaki olasılık yoğunluğunu çizdirin.\nTüm işlemi \\(\\sigma_x=0.01\\) için tekrar edin. Konum uzayındaki olasılık fonksiyonu ve momentum uzayındaki olasılık fonksiyonunu nasıl değişti?\nAynı işlemi \\(\\sigma_x=0.001\\) için tekrar edin. Konum uzayındaki olasılık fonksiyonu ve momentum uzayındaki olasılık fonksiyonunu nasıl değişti?\nYukarıdaki işlem ile Heisenberg belirsizlik ilkesi arasında nasıl bir bağlantı var mıdır?",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#problem-4",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#problem-4",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Problem 4",
    "text": "Problem 4\n\n/veri/ klasöründe bulunan veri-hft-dalga.csv dosyasını okuyunuz. Dosyaya bu linkten erişebilirsiniz. pd.read_csv fonksiyonunu kullanabilirsiniz.\nBu dosyanın ilk sütuunu x, ikinci sütunu y olarak atayınız.\nx sütununu x eksenine y sütununu y eksenine yerleştirerek bir grafik çizin. Grafikte noktalar kırmızı ve yıldız şeklinde olsun.\nAynı grafiği siyah renkli ve çizgi şeklinde tekrar çizin.\nBu grafiği kapatın.\nscipy.fft.fft fonksiyonunu kullanarak DFT genliğini çizdirin.\nSadece Nyquist frekansına kadar olan genliği çizdirin.\nDFT verisini dalga_dft.csv dosyasına kaydedin.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kaynaklar",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kaynaklar",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nPython Programming and Numerical Methods, Qingkai Kong, 2018\nhttps://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/bilYonMod.html",
    "href": "icerik/bilYonMod.html",
    "title": "Python Modülü",
    "section": "",
    "text": "Bilgisayarlı yöntemler notlarında kullanılan fonksiyonlardan oluşan modül bu linktedir: bilYonMod.py",
    "crumbs": [
      "**İçerik**",
      "Python Modülü"
    ]
  }
]