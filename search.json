[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bilgisayarlı Yöntemler",
    "section": "",
    "text": "Bu site, çeşitli kaynaklardan derlenerek hazırlanan sayısal yöntemler veya bilgisayarlı yöntemler notlarını içerir. Bu notlar, sayısal analiz, diferansiyel denklemler, optimizasyon, istatistik ve benzeri konularda kullanılan algoritmaları ve bu algoritmaların nasıl çalıştığını anlatır.\nEğer bu notlarla ilgili herhangi bir hata veya eksiklik bulursanız, lütfen GitHub Issue sayfasına yazınız. Bu link her sayfanın sağ tarafında bulunmaktadır.\nSol taraftaki menüden konulara ulaşabilirsiniz. Ayrıca, her sayfanın altında bulunan “Next” ve “Previous” butonları ile notları sırasıyla okuyabilirsiniz.\n\n\n\n\n\n\nUyarı\n\n\n\nBuradaki notlar ve kodlar açık kaynak kodudur. Kişisel kullanım ve eğitim amaçlıdır. Ticari amaçlar için kullanılmamalıdır."
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html",
    "title": "Uygulama - Ses Dalgaları",
    "section": "",
    "text": "Örnek olarak aşağıdaki adımları takip edelim.\n\nscipy.io.wavfile modülünü çağırın.\nÖrnekleme oranı \\(44100\\) Hz olsun. Yani oluşturacağınız sinyallerin bir saniyesindeki veri sayısı bu olsun. Ses bilgi için  [1] numaralı kaynağa bakabilirsiniz.\nBir sinüs sinyali oluşturun. Frekansı 440 Hz, süresi 5 saniye olsun.\nBir sinüs sinyali oluşturun. Frekansı 880 Hz, süresi 5 saniye olsun.\nBu iki sinyali başka bir değişkende toplayın.\nTüm sinyalleri alt alta çizdirin.\nTüm sinyalleri 0.01 saniyeye kadar olan kısmını alt alta çizdirin.\nTüm değişkenleri oranlayın wav dosyası kaydetmek üzere değişkene atayın (scaling).\nTüm değişkenleri write(\"&lt;dosya_adi&gt;.wav\", örneklemeOranı, &lt;degisken&gt;) ile kaydedin.\n\nŞimdi bu adımları kodlayalım.\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\n# Veriyi oluştur\norneklemeOrani= 44100 # 1 saniyede kaç tane veri var?\nsure= 5 # s\n# Zaman\nt= np.linspace(0, sure, orneklemeOrani* sure)\n# Sinüs dalgaları\nveri1_440Hz= np.sin(2*np.pi*440*t)\nveri2_880Hz= np.sin(2*np.pi*880*t)\nveri3= veri1_440Hz + veri2_880Hz\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(t, veri1_440Hz)\naxs[0].set_title(\"440Hz\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, veri2_880Hz)\naxs[1].set_title(\"880Hz\")\naxs[1].set_xlim([0, 0.01])\naxs[2].plot(t, veri3)\naxs[2].set_title(\"440Hz + 880Hz\")\naxs[2].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\n# Normalizasyon için [-32767, 32767] kullacağız.\n# Çünkü 16 bitlik ses dosyaları bu aralıkta değer alır.\nveri1_440Hz = np.int16((veri1_440Hz/ np.max(np.abs(veri1_440Hz)))* 32767)\nveri2_880Hz = np.int16((veri2_880Hz/ np.max(np.abs(veri2_880Hz)))* 32767)\nveri3 = np.int16((veri3/ np.max(np.abs(veri3)))* 32767)\n# Dosyları wav formatında, ../../../sesler klasörüne kaydet\nwavfile.write(sesler_dir+ \"sin1_440Hz.wav\", orneklemeOrani, veri1_440Hz)\nwavfile.write(sesler_dir+ \"sin2_880Hz.wav\", orneklemeOrani, veri2_880Hz)\nwavfile.write(sesler_dir+ \"sin3_440Hz880Hz.wav\", orneklemeOrani, veri3)",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#ses-dosyası-oluşturma",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#ses-dosyası-oluşturma",
    "title": "Uygulama - Ses Dalgaları",
    "section": "",
    "text": "Örnek olarak aşağıdaki adımları takip edelim.\n\nscipy.io.wavfile modülünü çağırın.\nÖrnekleme oranı \\(44100\\) Hz olsun. Yani oluşturacağınız sinyallerin bir saniyesindeki veri sayısı bu olsun. Ses bilgi için  [1] numaralı kaynağa bakabilirsiniz.\nBir sinüs sinyali oluşturun. Frekansı 440 Hz, süresi 5 saniye olsun.\nBir sinüs sinyali oluşturun. Frekansı 880 Hz, süresi 5 saniye olsun.\nBu iki sinyali başka bir değişkende toplayın.\nTüm sinyalleri alt alta çizdirin.\nTüm sinyalleri 0.01 saniyeye kadar olan kısmını alt alta çizdirin.\nTüm değişkenleri oranlayın wav dosyası kaydetmek üzere değişkene atayın (scaling).\nTüm değişkenleri write(\"&lt;dosya_adi&gt;.wav\", örneklemeOranı, &lt;degisken&gt;) ile kaydedin.\n\nŞimdi bu adımları kodlayalım.\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\n# Veriyi oluştur\norneklemeOrani= 44100 # 1 saniyede kaç tane veri var?\nsure= 5 # s\n# Zaman\nt= np.linspace(0, sure, orneklemeOrani* sure)\n# Sinüs dalgaları\nveri1_440Hz= np.sin(2*np.pi*440*t)\nveri2_880Hz= np.sin(2*np.pi*880*t)\nveri3= veri1_440Hz + veri2_880Hz\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(t, veri1_440Hz)\naxs[0].set_title(\"440Hz\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, veri2_880Hz)\naxs[1].set_title(\"880Hz\")\naxs[1].set_xlim([0, 0.01])\naxs[2].plot(t, veri3)\naxs[2].set_title(\"440Hz + 880Hz\")\naxs[2].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\n# Normalizasyon için [-32767, 32767] kullacağız.\n# Çünkü 16 bitlik ses dosyaları bu aralıkta değer alır.\nveri1_440Hz = np.int16((veri1_440Hz/ np.max(np.abs(veri1_440Hz)))* 32767)\nveri2_880Hz = np.int16((veri2_880Hz/ np.max(np.abs(veri2_880Hz)))* 32767)\nveri3 = np.int16((veri3/ np.max(np.abs(veri3)))* 32767)\n# Dosyları wav formatında, ../../../sesler klasörüne kaydet\nwavfile.write(sesler_dir+ \"sin1_440Hz.wav\", orneklemeOrani, veri1_440Hz)\nwavfile.write(sesler_dir+ \"sin2_880Hz.wav\", orneklemeOrani, veri2_880Hz)\nwavfile.write(sesler_dir+ \"sin3_440Hz880Hz.wav\", orneklemeOrani, veri3)",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#nota-silme",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#nota-silme",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Nota Silme",
    "text": "Nota Silme\n\nscipy.io.wavfile modülünü çağırın.\nBir önceki bölümde kaydettiğiniz toplam sinüs dalgası ses dosyasını wavfile.read() ile okuyun.\nSes dosyasının ilk 0.01 saniyesinin grafiğini çizdirin.\nSes dosyasının Fourier analizini yapın.\nscipy.fft.fftfreq(len(veri), 1/orneklemOrani) ile frekansları bulun.\nSes dosyasındaki frekansları (HFD) çizdirin.\n500 Hz’den büyük tüm frekansları sıfırlayın.\nTers Fourier dönüşümü yapın.\nSes dosyasının ilk 0.01 saniyesini gösterin.\nTers dönüşüm ile elde ettiğiniz ses dosyasını kaydedin.\n\nŞimdi bu adımları kodlayalım.\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\nimport scipy.fft as fft\n# sin3_440Hz880Hz.wav dosyasını oku\norneklemOrani, veri = wavfile.read(sesler_dir+ \"sin3_440Hz880Hz.wav\")\n# Süre\nsure= len(veri)/ orneklemOrani\n# Zaman dizisi\nt= np.linspace(0, sure, len(veri))\nplt.plot(t, veri)\nplt.xlim([0,0.01])\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.show()\nplt.close()\n# HFD\nveriHFD= fft.fft(veri)\n# Frekanslar\nveriHFDFrek= fft.fftfreq(len(veri), 1/orneklemOrani)\n# Çiz\nplt.plot(veriHFDFrek, np.abs(veriHFD))\nplt.xlim([-1000,1000])\nplt.ylabel(\"|X(f)|\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.show()\nplt.close()\n# 500 Hz'den büyük tüm frekansları sıfırla\n# (Low Pass Filter)\nveriHFD[veriHFDFrek &gt; 500] = 0 \n#veriHFD[veriHFDFrek &gt; 500] = veriHFD[veriHFDFrek &gt; 500]* 0.5\nveriHFD[veriHFDFrek &lt; -500] = 0\n#veriHFD[veriHFDFrek &lt; -500] = veriHFD[veriHFDFrek &lt; -500]* 0.5 \n# Çiz\nplt.plot(veriHFDFrek, np.abs(veriHFD))\nplt.xlim([-1000,1000])\nplt.ylabel(\"|X(f)| (Filtreli)\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.show()\nplt.close()\n# THFD\nveriTHFD_filtreli= fft.ifft(veriHFD)\n# Zaman\ntTHFD_filtreli=\\\n    np.linspace(0, sure, len(veriTHFD_filtreli))\n# Çiz\nplt.plot(tTHFD_filtreli, np.real(veriTHFD_filtreli))\nplt.xlim([0,0.01])\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.show()\nplt.close()\n# Normalizasyon\n# Gerek yok ama yine de yapalım\nveriTHFD_filtreli = np.int16((np.real(veriTHFD_filtreli)/ np.max(np.abs(veriTHFD_filtreli)))* 32767)\n# Dosyları wav formatında kaydet\nwavfile.write(sesler_dir+\"sin3_440Hz880Hz_filtreliLowPass500.wav\", orneklemOrani, veriTHFD_filtreli)",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#alıştırma-1",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#alıştırma-1",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nYukarıda yapılan örnekte 500’den küçük frekansları sıfırlayın ve tüm adımları tekrarlayın.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#gürültü-ve-ses-dosyası-analizi",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#gürültü-ve-ses-dosyası-analizi",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Gürültü ve Ses Dosyası Analizi",
    "text": "Gürültü ve Ses Dosyası Analizi\n\nÖrnekleme oranını 44100 Hz olarak belirleyin.\nToplam 5 saniye olacak şekilde bir zaman dizisi oluşturun.\n5 saniyelik rastgele bir sinyal gürültüsü oluşturun. np.rand.randn(arrayBoyutu) kullanabilirsiniz.\n5 saniyelik bir sinüs sinyali oluşturun. Frekansı 170 Hz olsun.\nGürültü ve sinüs sinyalini toplayın ve yeni bir değişkene atayın.\nTüm değişkenleri oranlayın (scaling) ve write(\"&lt;dosya_adi&gt;.wav\", örneklemeOranı, &lt;oranli-degisken&gt;) ile kaydedin.\nSinüs, gürültü ve toplam sinyallerinin ilk 0.1 saniyesini aynı grafikte alt alta çizdirin.\n3 adet sinyalin hızlı Fourier dönüşümünü (scipy.fft.fft()) yapın.\n3 adet sinyalin frekanslarını (scipy.fft.fftfreq(len(veri), 1/orneklem_orani)) hesaplayın. Frekans miktarı verinizden bağımsız olacaktır. Sadece verinizin örnekleme oranı (verinin büyüklüğü) ve saniyede kaç örnekleme yaptığınız önemlidir.\nFrekans uzayını, 3 adet alt alta grafik olacak şekilde çizdirin.\nToplam sinyalden gürültü frekansını silin.\nFiltrelenmiş sinyalin Fourier dönüşümünü, karşılaştırmalı olarak çizdirin.\nTers Fourier dönüşümü yapın ve filtrelenmiş sinyalin ilk 0.1 saniyesi ile filtrelenmemiş sinyalin ilk 0.1 saniyesini grafik üzerinde karşılaştırın.\nFiltrelenmiş sinyali wav dosyası olarak kaydedin.\n\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık + sesler klasörü\nsesler_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'sesler')\n# Bu klasör var mı? Yoksa oluştur\nif not os.path.exists(sesler_dir):\n    # Oluştur\n    os.makedirs(sesler_dir)\n# Linux/MacOS için\n# Eğer OS Linux/Unix ise\nif sys.platform == \"linux\" or sys.platform == \"linux2\" or sys.platform == \"darwin\":\n    sesler_dir = sesler_dir + \"/\"\n# Eğer OS, Windows ise\nelif sys.platform == \"win32\":\n    sesler_dir = sesler_dir + \"\\\\\"\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.io.wavfile as wavfile\nimport scipy.fft as fft\n# Veriyi oluştur\norneklemeOrani= 44100\nsure= 5 # s\n# Zaman\nt= np.linspace(0, sure, orneklemeOrani* sure)\n# Sinüs dalgaları\nveri4_170Hz= np.sin(2*np.pi*170*t)\nveri5_Gurultu= np.random.rand(len(t))\nveri6_topla= veri4_170Hz+ veri5_Gurultu\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(t, veri4_170Hz)\naxs[0].set_title(\"170Hz\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, veri5_Gurultu)\naxs[1].set_title(\"Gürültü\")\naxs[1].set_xlim([0, 0.01])\naxs[2].plot(t, veri6_topla)\naxs[2].set_title(\"Gürültü+170Hz\")\naxs[2].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Wav dosyası olarak kaydet\nwavfile.write(sesler_dir+ \"sin4_170Hz.wav\", orneklemeOrani, np.int16((np.real(veri4_170Hz)/ np.max(np.abs(veri4_170Hz)))* 32767))\nwavfile.write(sesler_dir+ \"gurultu.wav\", orneklemeOrani, np.int16((np.real(veri5_Gurultu)/ np.max(np.abs(veri5_Gurultu)))* 32767))\nwavfile.write(sesler_dir+ \"sin4_170Hz_gurultulu.wav\", orneklemeOrani, np.int16((np.real(veri6_topla)/ np.max(np.abs(veri6_topla)))* 32767))\n# HFD\nhfd_veri4_170Hz= fft.fft(veri4_170Hz)\nhfd_veri5_Gurultu= fft.fft(veri5_Gurultu)\nhfd_veri6_topla= fft.fft(veri6_topla)\n# Frekanslar\nhfd_veri4_170HZ_frek= fft.fftfreq(len(veri4_170Hz), 1/orneklemeOrani)\nhfd_veri5_Gurultu_frek= fft.fftfreq(len(veri5_Gurultu), 1/orneklemeOrani)\nhfd_veri6_topla_frek= fft.fftfreq(len(veri6_topla), 1/orneklemeOrani)\n# Çiz\nfig, axs= plt.subplots(3,1)\naxs[0].plot(hfd_veri4_170HZ_frek, np.abs(hfd_veri4_170Hz))\naxs[0].set_title(\"HFD-170Hz\")\naxs[0].set_xlim([-1000, 1000])\naxs[1].plot(hfd_veri5_Gurultu_frek, np.abs(hfd_veri5_Gurultu))\naxs[1].set_title(\"HFD-Gürültü\")\naxs[1].set_xlim([-1000, 1000])\naxs[2].plot(hfd_veri6_topla_frek, np.abs(hfd_veri6_topla))\naxs[2].set_title(\"HFD-Toplam\")\naxs[2].set_xlim([-1000, 1000])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Toplam sinyalden gürültüyü çıkar\nhfd_veri7_topla_filtre= hfd_veri6_topla - hfd_veri5_Gurultu\n# Çiz\nfig, axs= plt.subplots(2,1)\naxs[0].plot(hfd_veri6_topla_frek, np.abs(hfd_veri6_topla))\naxs[0].set_title(\"HFD-Toplam\")\naxs[0].set_xlim([-1000, 1000])\naxs[1].plot(hfd_veri6_topla_frek, np.abs(hfd_veri7_topla_filtre))\naxs[1].set_title(\"HFD-Toplam-Gürültüsüz\")\naxs[1].set_xlim([-1000, 1000])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Ters HFD\nveri7_topla_filtre= fft.ifft(hfd_veri7_topla_filtre)\n# Çiz\nfig, axs= plt.subplots(2,1)\naxs[0].plot(t, np.abs(veri6_topla))\naxs[0].set_title(\"Toplam-Veri\")\naxs[0].set_xlim([0, 0.01])\naxs[1].plot(t, np.real(veri7_topla_filtre))\naxs[1].set_title(\"Toplam-Veri-Gürültüsüz\")\naxs[1].set_xlim([0, 0.01])\nplt.tight_layout()\nplt.show()\nplt.close()\n# Wav dosyası olarak kaydet\nwavfile.write(sesler_dir+ \"sin4_170Hz_gurultulu_filtreli.wav\", orneklemeOrani, np.int16((np.real(veri7_topla_filtre)/ np.max(np.abs(veri7_topla_filtre)))* 32767))",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#problemler",
    "href": "icerik/konular/fourier-analizi/uygulama-ses-dalgalari.html#problemler",
    "title": "Uygulama - Ses Dalgaları",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nKara Delik Birleşmesi (GW150914)\n\nhttps://gwosc.org/events/GW150914/ sitesine gidin. Bu sitede 2015 yılında tespit edilen kara delik birleşmesi verileri bulunmaktadır.\nObservation of Gravitational Waves from a Binary Black Hole Merger başlığına tıklayınız. Burada hem Hanford hem de Livingston merkezlerinden alınan veriler bulunmaktadır.\n\nhttps://gwosc.org/GW150914data/P150914/fig1-observed-H.txt\nhttps://gwosc.org/GW150914data/P150914/fig1-observed-L.txt\n\nBu dosyaları pandas kütüphanesini kullanarak okuyun, pandas.read_csv(\"&lt;LINK&gt;, skiprows=1, sep=\" \", header=None\") .\nVerilerin grafiğini üst üste çizdirin.\nVerileri wav dosyası olarak kaydedin. (https://www.youtube.com/watch?v=TWqhUANNFXw)\nVerilerin Fourier dönüşümünü yapın ve grafiklerini çizdirin.\n\n\n\nProblem 2\nGürültü Silme\n\nGürültü filtreleme işlemini problem2-gurultulu-sinyal.wav dosyası için yapın. Dosyaya bu linkten ulaşabilirsiniz. Bu dosya C akoru ve G akorunu ardı ardına eklenerek oluşturulmuştur.\nSes dosyasını tam ortadan ikiye ayırın.\nİlk yarısına hfd yapın. Bu frekansların 261.63 Hz, 329.63 Hz ve 392.0 Hz olduğunu göreceksiniz.\nBu frekanslar dışındaki tüm frekansları sıfırlayın.\nİkinci yarısına hfd yapın. Bu frekansların 392.0 Hz, 493.88 Hz ve 293.66 Hz olduğunu göreceksiniz.\nBu frekanslar dışındaki tüm frekansları sıfırlayın.\nArdından bu iki dosyanın ters hfd’sini alın ve birleştirin.\nFiltrelenmiş ses dosyasını problem2-gurultusuz-sinyal.wav.wav olarak kaydedin.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Uygulama - Ses Dalgaları"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "HFD, Gauss’un yayınlanmamış 1805 yılındaki çalışmalarına dayanır. Temel olarak KFD algoritmasını daha küçük parçalara bölerek hesaplar. Bu küçük parçaları hesaplamak için ise tekrarlanan (rekürsif, recursive) bir algoritma kullanır.\n\n\nKFD denklemini hatırlayalım.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\(k+N\\)’inci frekansın değeri ise aşağıdaki gibidir.\n\\[\nX_{k+N} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi (k+N) n / N}\n\\]\n\\(e^{-i2\\pi n}=1\\) özelliğini kullanalım.\n\\[\n\\begin{align*}\n    X_{k+N} =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N} e^{-i 2 \\pi N n / N}\\\\\n    =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\\\\\n    =& X_{k}\n\\end{align*}\n\\]\nFormülde bir simetri elde ettik \\(X_{k+N}=X_{k}\\).\nBu simetrinin anlamı şudur: \\(X_{k}\\)’nın değeri, \\(X_{k+N}\\) değerine eşit olması demek, aynı değeri veren bazı \\(X_{k}\\) değerleri olduğunu gösterir. Ayrıca gösterilebiliriz ki bu simetri \\(k+N\\), \\(x+2N\\), \\(\\cdots\\) için de geçerlidir. O halde simetriyi \\(X_{k+i\\times N}=X_{k}\\) şeklinde genelleştirebiliriz. Burada \\(i\\) bir tam sayıdır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hfd---hızlı-fourier-dönüşümü-fft---fast-fourier-transform",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hfd---hızlı-fourier-dönüşümü-fft---fast-fourier-transform",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "HFD, Gauss’un yayınlanmamış 1805 yılındaki çalışmalarına dayanır. Temel olarak KFD algoritmasını daha küçük parçalara bölerek hesaplar. Bu küçük parçaları hesaplamak için ise tekrarlanan (rekürsif, recursive) bir algoritma kullanır.\n\n\nKFD denklemini hatırlayalım.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\(k+N\\)’inci frekansın değeri ise aşağıdaki gibidir.\n\\[\nX_{k+N} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi (k+N) n / N}\n\\]\n\\(e^{-i2\\pi n}=1\\) özelliğini kullanalım.\n\\[\n\\begin{align*}\n    X_{k+N} =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N} e^{-i 2 \\pi N n / N}\\\\\n    =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\\\\\n    =& X_{k}\n\\end{align*}\n\\]\nFormülde bir simetri elde ettik \\(X_{k+N}=X_{k}\\).\nBu simetrinin anlamı şudur: \\(X_{k}\\)’nın değeri, \\(X_{k+N}\\) değerine eşit olması demek, aynı değeri veren bazı \\(X_{k}\\) değerleri olduğunu gösterir. Ayrıca gösterilebiliriz ki bu simetri \\(k+N\\), \\(x+2N\\), \\(\\cdots\\) için de geçerlidir. O halde simetriyi \\(X_{k+i\\times N}=X_{k}\\) şeklinde genelleştirebiliriz. Burada \\(i\\) bir tam sayıdır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hızlanmak-için-yapılan-numaralar",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hızlanmak-için-yapılan-numaralar",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Hızlanmak İçin Yapılan Numaralar",
    "text": "Hızlanmak İçin Yapılan Numaralar\nKFD algoritmasının simetri özelliğini kullanarak N sayısını 2’ye bölelim. Böldüğümüz kısımlar \\(n\\)’in tek ve çift olduğu durumlar olsun.\n\\[\n\\begin{align*}\nX_{k} =& \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\\\\\n      =& \\sum_{m=0}^{N/2-1} x_{2m} e^{-i 2 \\pi k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i 2 \\pi k (2m+1) / N}\\\\\n\\end{align*}\n\\]\nBu toplamdaki ilk terim \\(n\\)’in çift terimlerinden oluşuyor, ikinci terim ise tek terimlerden oluşuyor. Hesaplamaya devam edelim ve \\(2m/N\\) yerine \\(m/(N/2)\\) yazalım.\n\\[\n\\begin{align*}\nX_{k} =& \\sum_{m=0}^{N/2-1} x_{2m} e^{-i 2 \\pi k m / (N/2)} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i 2 \\pi k (2m+1) / N}\\\\\n      =& \\sum_{m=0}^{N/2-1} x_{2m} e^{-i 2 \\pi k m / (N/2)} + e^{-i 2 \\pi k / N} \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i 2 \\pi k m / (N/2)}\\\\\n\\end{align*}\n\\]\nKFT’daki simetri bize şunu söyler. \\(X_{k}\\)’yı hesaplarken \\(N/2\\)’ye kadar olan kısmı hesaplıdır. Yani yukarıdaki toplamın sadece birisini hesapladığımızda diğerini de hesaplamış oluruz. Bu da bilgisayara yaptıracağımız işi yarıya indirir.\nYukarıda yaptığımız yarıya bölme işlemini tekrar tekrar yaparak en küçük parçaya gidilir. HFD algoritmasının tekrarlanan yapısı da buradan gelir. Bunun için algoritmada kendi kendine çağıran bir yapı kullanacağız. Bu yapıya fonksyion tekrarlanması (function recursion) adı verilir  [1].\nHFD algoritması bu şekilde çalışarak hesaplama zamanını oldukça azaltır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kod",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kod",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Kod",
    "text": "Kod\nfourier_hfd fonksiyonu bilYonMod.py dosyasına tanımlıdır. Aşağıdaki kodu inceleyelim.\n\n\n\n\n\n\nNot\n\n\n\nfourier_hfd fonksiyonunu inceleyiniz.\n\n\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Örnelem sayısı\norneklemOrani = 128\n# Zaman\norneklemAraligi = 1.0/orneklemOrani\nt = np.arange(0, 1, orneklemAraligi)\n# Toplam Örnekleme Sayısı\nN= len(t)\n# Birinci dalgayı olustur\n# Frekans\nfrek = 1.\n# Birinci dalgayı oluştur\nx = 3*np.sin(2* np.pi* frek* t)\n# İkinci dalganın frekansı\nfrek = 4\n# İkinci dalgayı oluştur\nx += np.sin(2* np.pi* frek* t)\n# Üçüncü dalganın frekansı\nfrek = 7\n# Üçüncü dalgayı oluştur\nx += 0.5* np.sin(2* np.pi* frek* t)\n# Sinyali Çiz\nplt.plot(t, x, \"r\", label= \"$3\\\\sin(2\\\\pi 1 t)+ 2\\\\sin(2\\\\pi 4 t)+ 0.5sin(2\\\\pi 7 t)$\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.title(f\"Sinyal, Örnekleme Sayısı: {N}\")\nplt.legend()\nplt.show()\nplt.close()\n# -------------------------\n# Hızlı Fourier Dönüşümü\nX=bym.fourier_hfd(x)\n# Frekans\nif N%2 == 0:\n    maksFrek= N/ 2\n    XPoz= X[:int(N/2)]\n    XNeg= X[int(N/2):]\n    frekCoz=maksFrek/ (N/2)\nelse:\n    maksFrek= (N-1)/ 2\n    XPoz= X[:int((N-1)/2)]\n    XNeg= X[int((N+1)/2):]\n    frekCoz=maksFrek/ ((N-1)/2)\nfrekPoz= np.arange(0, maksFrek, frekCoz)\nfrekNeg= np.arange(-maksFrek, 0, frekCoz)\n# Çiz\nfig, axs = plt.subplots(3, 1)\n# Re(X) Değeri\naxs[0].stem(frekPoz, np.real(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\naxs[0].stem(frekNeg, np.real(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\n# Imag(X) Değeri\naxs[1].stem(frekPoz, np.imag(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\naxs[1].stem(frekNeg, np.imag(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\n# |X| Değeri\naxs[2].stem(frekPoz, np.abs(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\naxs[2].stem(frekNeg, np.abs(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\n# Kozmetik\naxs[0].set_ylabel(\"Re($X_{k}$) Değeri\")\naxs[0].set_title(\"Hızlı Fourier Dönüşümü\")\naxs[1].set_ylabel(\"Im($X_{k}$) Değeri\")\naxs[1].set_yticklabels([])\naxs[2].set_ylabel(\"|$X_{k}$| Değeri\")\naxs[2].set_xlabel(\"Frekans (Hz)\")\nplt.legend()\nplt.show()\nplt.close()\n# Tek bir tarafı çizdir (Pozitif Frekanslar)\nplt.stem(frekPoz, np.abs(XPoz)/(N/2), 'r', markerfmt=\" \", basefmt=\"-r\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.ylabel(\"Normalize, Tek Taraflı |$X_{k}$|$_{norm}$ Değeri\")\n# X Eksenindeki Sayıları Belirle\nplt.xticks([1, 4, 7, 10, 20, 30, 40, 50, 60])\nplt.tight_layout()\nplt.show()\nplt.close()",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hız-testi",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hız-testi",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Hız Testi",
    "text": "Hız Testi\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport time\n# Örnekleme sayısı\norneklemOrani = 2**11\n# Zaman\norneklemAraligi = 1.0/orneklemOrani\nt = np.arange(0, 1, orneklemAraligi)\n# Toplam Örnekleme Sayısı\nN= len(t)\n# Birinci dalgayı olustur\n# Frekans\nfrek = 1.\n# Birinci dalgayı oluştur\nx = 3*np.sin(2* np.pi* frek* t)\n# İkinci dalganın frekansı\nfrek = 4\n# İkinci dalgayı oluştur\nx += np.sin(2* np.pi* frek* t)\n# Üçüncü dalganın frekansı\nfrek = 7\n# Üçüncü dalgayı oluştur\nx += 0.5* np.sin(2* np.pi* frek* t)\nprint(f\"Örnekleme Sayısı: {N}\")\n# Kesikli Fourier Dönüşümü\nstart = time.time()\nX=bym.fourier_kfd(x)\nend = time.time()\nprint(f\"Kesikli Fourier Dönüşümü: {end-start:.2f} saniye\")\n# Hızlı Fourier Dönüşümü\nstart = time.time()\nX=bym.fourier_hfd(x)\nend = time.time()\nprint(f\"Hızlı Fourier Dönüşümü  : {end-start:.2f} saniye\")\n\nÖrnekleme Sayısı: 2048\nKesikli Fourier Dönüşümü: 5.80 saniye\nHızlı Fourier Dönüşümü  : 0.02 saniye",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hazır-fonksiyonlar",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#hazır-fonksiyonlar",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Hazır Fonksiyonlar",
    "text": "Hazır Fonksiyonlar\nDaha detaylı bilgi için numpy.fft ve scipy.fft modüllerinin dökümantasyonunu inceleyebilirsiniz.\n\nimport numpy as np\n#import scipy.fft as spfft\nimport matplotlib.pyplot as plt\n# Örnekleme sayısı\norneklemOrani = 2**13\n# Zaman\norneklemAraligi = 1.0/orneklemOrani\nt = np.arange(0, 6, orneklemAraligi)\n#toplamSure= 1\n#t= np.linspace(0, toplamSure, orneklemOrani* toplamSure)\nN= len(t)\n# Açısal Frekans\nfrekans= 5\nfrekans2= 7\n# Sinyal\nsinyal= np.sin((2 * np.pi) *frekans* t)\\\n    + 2*np.sin((2 * np.pi) *frekans2* t)\n# Hızlı Fourier Dönüşümü\nX= np.fft.fft(sinyal)\n# X= spfft.fft(sinyal)\n# Frekans\nfrek= np.fft.fftfreq(N, 1/orneklemOrani)\n#frek= spfft.fftfreq(N, 1/orneklemOrani)\n# Çiz\nplt.stem(frek, np.abs(X)/orneklemOrani, 'b', markerfmt=\" \", basefmt=\"-b\")\nplt.xlim(-15, 15)\nplt.show()\n\n\n\n\n\n\n\n\nGrafikteki y ekseni, dalga içerisindeki frekansların büyüklüğünü gösterir. Yani 5 Hz’e sahip olan dalganın genliği, 10 Hz’e sahip olan dalganın genliğinin yarısıdır.\n\n\n\n\n\n\nNot\n\n\n\nHızlı Fourier dönüşümünde scipy, numpy’dan daha hazlıdır  [2].",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#problemler",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#problemler",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAçısal frekansı 5, genliği 10 olan bir cosinüs sinyali ve açısal frekansı 10, genliği 5 olan bir sinüs sinyalinin toplamını çizdirin. Örneklem oranı \\(100\\), \\(t=[0,6)\\) aralığında olsun. Sinyalin HFD’sini hesaplayın ve doğru frekanslar için çizdirin.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kaynaklar",
    "href": "icerik/konular/fourier-analizi/hfd-hizli-fourier-donusumu.html#kaynaklar",
    "title": "HFD - Hızlı Fourier Dönüşümü",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nPython Programming and Numerical Methods, Qingkai Kong, 2018\nhttps://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "HFD - Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html",
    "href": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html",
    "title": "THFD - Ters Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "Ters Hızlı Fourier Dönüşümü (IFFT), Hızlı Fourier Dönüşümü (FFT) sonucu elde edilen frekans bileşenlerini zaman alanına dönüştürmek için kullanılır.\nFrekans uzayındaki verilerden zaman uzayındaki sinyali elde etmek için kullanılır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "THFD - Ters Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#thfd---ters-hızlı-fourier-dönüşümü-ifft---inverse-fast-fourier-transform",
    "href": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#thfd---ters-hızlı-fourier-dönüşümü-ifft---inverse-fast-fourier-transform",
    "title": "THFD - Ters Hızlı Fourier Dönüşümü",
    "section": "",
    "text": "Ters Hızlı Fourier Dönüşümü (IFFT), Hızlı Fourier Dönüşümü (FFT) sonucu elde edilen frekans bileşenlerini zaman alanına dönüştürmek için kullanılır.\nFrekans uzayındaki verilerden zaman uzayındaki sinyali elde etmek için kullanılır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "THFD - Ters Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#örnek",
    "href": "icerik/konular/fourier-analizi/thfd-ters-hizli-fourier-donusumu.html#örnek",
    "title": "THFD - Ters Hızlı Fourier Dönüşümü",
    "section": "Örnek",
    "text": "Örnek\nFrekans uzayında, kendimiz belirlediğimiz bir frekansın en yakın noktalara 1 değeri atanmış bir sinyal oluşturalım. Bu sinyali THFD ile zaman uzayına dönüştürelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Frekansı 5 Hz olan sinyal\nfrekans = 5\n# Maksimum Frekans\nmaxFrekans = 20\n# Toplam Orneklem\nN= maxFrekans*2\n# Frekans Çözünürlüğü\nfCoz = maxFrekans/N\n# Tum Frekanslar\nfrek = np.arange(-maxFrekans, maxFrekans, fCoz)\n# HFD değerleri\nhfdDegerleri= np.zeros(len(frek), dtype=np.complex128)\n# frek'in 5 Hz ve -5 Hz en yakın noktalara 1 değeri atanır\nhfdDegerleri[np.abs(frek - frekans).argmin()] = 1\nhfdDegerleri[np.abs(frek + frekans).argmin()] = 1\n# Çiz\nplt.stem(frek, np.abs(hfdDegerleri))\nplt.title(\"HFT\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.ylabel(\"$|X(f)|$\")\nplt.show()\n# THFD\nsinyal = np.fft.ifft(hfdDegerleri)\n# Zaman\nt= np.arange(0, N)\n# Çiz\nplt.plot(sinyal.real)\nplt.title(\"THFD\")\nplt.xlabel(\"Zaman (s)\")\nplt.ylabel(\"Genlik\")\nplt.xlim(0, 40)\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "THFD - Ters Hızlı Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html",
    "title": "BDP - Euler Yöntemi",
    "section": "",
    "text": "Euler yöntemi diferansiyel denklem çözümü için kullanılan en basit yöntemdir.\nAlternatif isimleri Euler-Cauchy veya nokta-eğim (point-slope) yöntemidir.\nKabaca türevin tanımını kullanır.\n\n\\[\ny'(x)= \\frac{y(x+h)-y(x)}{h}\n\\]\nÇözüm olarak Taylor serisini kullanacağız. \\[\ny(x+h)=y(x)+h\\times y'(x)+\\cdot\n\\]\n\nAmacımız başlangıç koşulundan itibaren adım adım \\(y(x)\\) fonksiyonunu bulmaktır. \\(x\\) noktasından \\(x+h\\) noktasına ilerlediğimiz için bu yöntem “ileri adım” yöntemidir.\n\n\n\n\n\n\n\nNot\n\n\n\nAlternatif olarak her (x+h) noktası için integral de alabiliriz ancak diferansiyel denklem çözerken sayısal integral alma yöntemleri kullanmak sakıncalıdır.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#başlangıç-değer-problemi---euler-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#başlangıç-değer-problemi---euler-yöntemi",
    "title": "BDP - Euler Yöntemi",
    "section": "",
    "text": "Euler yöntemi diferansiyel denklem çözümü için kullanılan en basit yöntemdir.\nAlternatif isimleri Euler-Cauchy veya nokta-eğim (point-slope) yöntemidir.\nKabaca türevin tanımını kullanır.\n\n\\[\ny'(x)= \\frac{y(x+h)-y(x)}{h}\n\\]\nÇözüm olarak Taylor serisini kullanacağız. \\[\ny(x+h)=y(x)+h\\times y'(x)+\\cdot\n\\]\n\nAmacımız başlangıç koşulundan itibaren adım adım \\(y(x)\\) fonksiyonunu bulmaktır. \\(x\\) noktasından \\(x+h\\) noktasına ilerlediğimiz için bu yöntem “ileri adım” yöntemidir.\n\n\n\n\n\n\n\nNot\n\n\n\nAlternatif olarak her (x+h) noktası için integral de alabiliriz ancak diferansiyel denklem çözerken sayısal integral alma yöntemleri kullanmak sakıncalıdır.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#hata-analizi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#hata-analizi",
    "title": "BDP - Euler Yöntemi",
    "section": "Hata Analizi",
    "text": "Hata Analizi\nBir uygulamada Taylor serisi kullanılırsa hata analizi aşağıdaki gibi yapılır. Farz edelim ki \\(f(x+h)\\) fonksiyonunu \\(f(x)\\) etrafında seriye açıyoruz ve \\(n\\)’nci dereceden terimden sonrasını atıyoruz. \\(E_{n}\\) terimi ise kestiğimiz terimden sonraki terimler yani hata terimi olarak tanımlansın.\n\\[\nf(x+h)=f(x)+f'(x)h+\\frac{f''(x)}{2!}h^2+\\cdots+\\frac{f^{(n)}(x)}{n!}h^n+E_{n}\n\\]\nHata terimi \\(E_{n}\\)’e kesme hatası (truncation error) adı verilir. Bu hatanın en büyük değeri Taylor teoreminden bulunabilir.\n\\[\nE_{n}=f^{n+1}(\\xi)\\frac{h^{n+1}}{(n+1)!}\n\\]\nBurada \\(\\xi\\), \\(x\\) ile \\(x+h\\) arasında bir değerdir. Bu değer ulaşılabilir değilse kesme hatasını belirleyen terim \\(h\\) adım aralığı olacaktır. Yani\n\\[\nE_{n}=\\mathcal{O}(h^{n+1})\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yöntemi-ile-çözümde-hata-analizi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yöntemi-ile-çözümde-hata-analizi",
    "title": "BDP - Euler Yöntemi",
    "section": "Euler Yöntemi ile Çözümde Hata Analizi",
    "text": "Euler Yöntemi ile Çözümde Hata Analizi\nEuler yöntemi kullanılırken her bir adımdaki kesme hatası \\(\\mathcal{O}(h^2)\\)’dir çünkü ikinci dereceden türev terimlerini ihmal ediyoruz. Her \\(h\\) adımda bu hata üst üste binecektir. Yani denklem \\(n\\) adımda çözülüyorsa kesme hatası da \\(n\\) kere tekrarlanacaktır.\n\\[\nE_{acc}=nE_{2}=\\frac{x_{n}-x_{0}}{h}E_{2}=O(h)\n\\]\nEuler yöntemi ile diferansiyel denklem çözümünde kesme hata payı \\(h\\) adım aralığı ile orantılı olacaktır.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-geometrik-tasviri",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-geometrik-tasviri",
    "title": "BDP - Euler Yöntemi",
    "section": "Euler Yönteminin Geometrik Tasviri",
    "text": "Euler Yönteminin Geometrik Tasviri\nBasitlik için çözmek istediğimiz \\(y(x)\\) fonksiyonu tek değişkene bağlı olsun. Bu fonksiyonun \\(x\\) ve \\(x+h\\) arasındaki değişimi aşağıdaki gibi olur  [1].\n\\[\ny(x+h)=y(x)+h\\times y'(x)\n\\]\nBuradan şu sonuç çıkarılabilir. Bulmak istediğimiz \\(y(x+h)\\) terimi, \\(y(x)\\) terimine ve o noktadaki eğiminin (türevinin) adım aralığı kadar katının toplamına eşittir.\n\n\n\nEuler Yönteminin Geometrik Tasviri",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-kodlanması",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#euler-yönteminin-kodlanması",
    "title": "BDP - Euler Yöntemi",
    "section": "Euler Yönteminin Kodlanması",
    "text": "Euler Yönteminin Kodlanması\nadd_coz_euler adlı fonksiyon bilYonMod.py modülünde tanımlıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_euler fonksiyonunu inceleyiniz.\n\n\n\n\n\n\n\n\nDikkat\n\n\n\nadd_coz_euler(fonk_y_x, xBaslangic, xBitis, yBaslangic, adimSayisi) fonksiyonunu çağırırken diferansiyel denklemin (\\(y'(x)=f(y,x)\\)) sağ tarafında yer alan ve çözmeniz gereken fonksiyonda, \\(f(y,x)\\), önce y ardından x tanımlanmalıdır. Yani kodda fonksiyon \\(f(y,x)\\) şeklinde yazılmalıdır. Burada \\(y\\) değişkeni \\(y(x)\\) olarak tanımlanır, \\(x\\) ise bağımsız değişkendir.\n\n\nAşağıdaki diferansiyel denklemi çözen bir örneği inceleyelim.\n\\[\n\\frac{d}{dx}y(x) = x, \\quad y(0)=1, \\quad x=[0, 1], \\quad n=10000\n\\]\nÇözüm aşağıdaki gibi olacaktır.\n\\[\ny(x)=1+\\frac{x^{2}}{2}\n\\]\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_y_x(y, x):\n    return x\n# Başlangıç koşulları\nx0 = 0\ny0 = 1\nxSon = 1\nn = 10\n# Çöz\nxTum, yTum = bym.add_coz_euler(fonk_y_x, x0, xSon, y0, n)\n# Çiz\nplt.plot(xTum, yTum, 'o-', color='r', label='Euler')\nplt.plot(xTum, 1+(xTum**2)/2, 'k', label='Analitik')\nplt.xlabel('$x$')\nplt.ylabel('$y(x)$')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#alıştırma-1",
    "title": "BDP - Euler Yöntemi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nEuler yöntemi ile aşağıdaki diferansiyel denklemi çözün ve analitik çözüm ile karşılaştırın.\n\\[\ny' + 4y = x^{2}, \\quad y(0)=1, \\quad x=[0, 0.03], \\quad n=10\n\\]\nAnalitik çözüm:\n\\[\ny(x)=\\frac{31}{32}e^{-4x} + \\frac{1}{4}x^{2}- \\frac{1}{8}x + \\frac{1}{32}\n\\]\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_y_x(y, x):\n    return -4*y + x**2\n# Başlangıç koşulları\nx0 = 0\ny0 = 1\nxSon = 0.03\nn = 10\n# Çöz\nxTum, yTum = bym.add_coz_euler(fonk_y_x, x0, xSon, y0, n)\n# Analitik çözüm\nyAnalitik=(31/32)*np.exp(-4*xTum) + (1/4)*(xTum**2) - (1/8)*xTum + (1/32)\n# Çiz\nplt.plot(xTum, yTum, 'o-', color='r', label='Euler')\nplt.plot(xTum, yAnalitik, 'k', label='Analitik')\nplt.xlabel('$x$')\nplt.ylabel('$y(x)$')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-euler-yontemi.html#problemler",
    "title": "BDP - Euler Yöntemi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nBasit bir RC devresi ele alalım. Bu devrede voltaj kaynağı olmasın, kondansatör \\(t=0\\) s’de \\(V_{0}=10\\) V gerilime sahip olsun. Devrede \\(R=220\\) k \\(\\Omega\\) direnci ve \\(C=10\\) \\(\\mu\\) F kondansatörü olsun. Devre bu haldeyken devreyi tamamlayalım. Devrenin voltajı-zaman grafiğini Euler yöntemi kullanarak çiziniz.\n\n\\[\nC\\frac{dV}{dt}+\\frac{V}{R}=0\n\\]\nAnalitik çözüm: \\(V(t) = V_{0}e^{-t/RC}\\)\n\n\nProblem 2\nThoryum-234’ün yarılanma ömrü \\(\\tau=24.1\\) gündür. \\(N_{0}=150\\) g saf Thoryum-234 izotopu \\(100\\) gün bekletilmektedir. İçerisinde kalan içerisinde kalan Thoryum-234 miktarı-zaman grafiğini Euler metodu kullanarak çiziniz.\n\\[\n\\frac{dN}{dt}= -\\frac{\\ln 2}{\\tau}N\n\\]\nAnalitik çözüm: \\(N(t) = N_{0}e^{-t(\\ln 2/\\tau)}\\)",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Euler Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "",
    "text": "Euler yöntemi için Taylor serisini birinci dereceden türevli terimden kesmiştik. Eğer Taylor serisinde daha yüksek mertebelerden türevler kullanılırsa, bu yöntemlere Runge-Kutta yöntemleri adı verilir.\n\n\n\n\n\n\nDikkat\n\n\n\nYüksek mertebeden türevler kullanmak demek, yüksek mertebe diferansiyel denklem çözümü anlamına gelmez. Örneğin, birinci dereceden diferansiyel denklemi, Taylor serisinin üçüncü dereceden teriminden keserek çözebiliriz. Runge-Kutta yöntemleri, Euler yönteminin bir genelleştirilmesidir.\n\n\n\n\nAna denklemi yazalım.\n\\[\ny'(x)=f(y,x)\n\\]\nEuler yöntemini hatırlayalım. \\(y'(x)=f(y,x)\\) bağıntısını da kullanalım.\n\\[\ny(x+h)= y(x)+hy'(y,x) = y(x)+hf(y,x)\n\\]\nTaylor serisinin ikinci mertebesinden kesmeden önce en genel formülü yazalım. Bu formül Runge-Kutta yöntemlerinin genel formülüdür.\n\\[\ny(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hf(x+ph,y+qhF(y,x))\n\\]\nBurada \\(c_{0},c_{1},p,q\\) birer katsayıdır. Taylor serisine dönelim.\n\\[\n\\begin{align*}\ny(x+h) &= y(x) + y'(x)h + \\frac{1}{2}y''(x)h^{2}\\\\\n       &= y(x) + F(y,x)h + \\frac{1}{2}f'(y,x)h^{2}    \n\\end{align*}\n\\]\nBurada \\(f'(y,x)\\) aşağıdaki gibi yazılır.\n\\[\n\\begin{align*}\nf'(y,x)&= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}f \\\\\n       &= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}y'\n\\end{align*}\n\\]\nVektörize edilmiş \\(F\\) için ise,\n\\[\nF'(y,x)= \\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nşeklinde yazılır. Taylor açılımından elde ettiğimiz denklemde yerine koyarsak,\n\\[\ny(x+h)= y(x) + F(y,x)h + \\frac{h^{2}}{2}\\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nifadesini elde ederiz. Şimdi genelleştirilmiş formülü, yani \\(y(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hF(x+ph,y+qhF(y,x))\\) terimindeki \\(F(x+ph,y+qhF(y,x))\\) terimi açalım.\n\\[\nF(x+ph,y+qhF(y,x)) = F(y,x) + \\frac{\\partial F}{\\partial x}ph + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}qhF_{i}(y,x)\n\\]\n\nYukarıdaki açılımı genelleştirilmiş formülde yerine koyalım.\n\n\\[\ny(x+h) = y(x) + (c_{0}+c_{1})F(y,x)h+ c_{1}\\left[\\frac{\\partial F}{\\partial x}ph + qh \\sum_{i=1}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\\right]\n\\]\nBurada elde ettiğimiz formül ile Taylor serisinde elde ettiğimiz formülü karşılaştıralım. Eğer\n\\[\nc_{0}+c_{1}=1 \\quad \\text{ve} \\quad c_{1}p=c_{1}q=\\frac{1}{2}\n\\]\nolursa, iki formül de aynı olur. Buradaki \\(c_{0}, c_{1},q,p\\) parametreleri farklı farklı seçilebilir. Bazı farklı seçimler için özel isimlendirme yapılır.\n\n\n\nİsim\n\\(c_{0}\\)\n\\(c_{1}\\)\np\nq\n\n\n\n\nDeğiştirilmiş (Modified) Euler\n0\n1\n1/2\n1/2\n\n\nHeun Yöntemi\n1/2\n1/2\n1\n1\n\n\nRalston Yöntemi\n1/3\n2/3\n3/4\n3/4\n\n\n\n\nTüm bu sınıflandırma 2. derece Runge-Kutta yöntemleri altındadır.\nBu yöntemler birbirlerinden üstün değildir.\nBirinci derece Runge-Kutta yöntemi olan Euler yönteminde ise \\(c_{0}=1\\) ve diğer terimler sıfırdır.\n\nGenelleştirmek adına değiştirilmiş Euler motdunu aşağıdaki gibi yazabiliriz.\n\\[\n\\vec{y}(x+h) = \\vec{y}(x) + \\vec{F}\\left[x+\\frac{h}{2},\\vec{y}+\\frac{h}{2}\\vec{F}(x,\\vec{y}) \\right]\n\\]\nRunge-Kutta metodları için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\vec{K}_{0} = h\\vec{F}(x,\\vec{y})\n\\]\n\nEn popüler Runge-Kutta diferansiyel denklem çözme yöntemi dördüncü dereceden Runge-Kutta yöntemidir.\n\n\n\n\nDördüncü Derece Runge-Kutta yöntemi için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\begin{align*}\n    \\vec{K}_{0} &= h\\vec{F}(x,\\vec{y})\\\\\n    \\vec{K}_{1} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{0}\\right)\\\\\n    \\vec{K}_{2} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{1}\\right)\\\\\n    \\vec{K}_{3} &= h\\vec{F}\\left(x+h,\\vec{y}+\\vec{K}_{2}\\right)\n\\end{align*}\n\\]\nSonuç olarak bir sonraki adım aşağıdaki gibi yazılır.\n\\[\n\\vec{y}(x+h)= \\vec{y}(x) + \\frac{1}{6}\\left(\\vec{K}_{0}+2\\vec{K}_{1}+2\\vec{K}_{2}+\\vec{K}_{3}\\right)\n\\]\nKatsayı tablosu oluşturalım.\n\n\n\n\n\n\n\n\n\n\\(K_{0}\\)\n\\(K_{1}\\)\n\\(K_{2}\\)\n\\(K_{3}\\)\n\n\n\n\n\\(hF(y,x)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{0}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{1}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+K_{2}, x+h\\right)\\)\n\n\n\nKatsayıları kullanarak bir sonraki adım hesaplanır.\n\\[\ny(x+h)= y(x) + \\frac{1}{6}(K_{0}+2K_{1}+2K_{2}+K_{3})\n\\]\nPython kodunu yazalım. add_coz_rk4_sistem adlı fonksiyon bilYonMod.py modülünde tanımlıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_rk4_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-yöntemleri",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-yöntemleri",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "",
    "text": "Euler yöntemi için Taylor serisini birinci dereceden türevli terimden kesmiştik. Eğer Taylor serisinde daha yüksek mertebelerden türevler kullanılırsa, bu yöntemlere Runge-Kutta yöntemleri adı verilir.\n\n\n\n\n\n\nDikkat\n\n\n\nYüksek mertebeden türevler kullanmak demek, yüksek mertebe diferansiyel denklem çözümü anlamına gelmez. Örneğin, birinci dereceden diferansiyel denklemi, Taylor serisinin üçüncü dereceden teriminden keserek çözebiliriz. Runge-Kutta yöntemleri, Euler yönteminin bir genelleştirilmesidir.\n\n\n\n\nAna denklemi yazalım.\n\\[\ny'(x)=f(y,x)\n\\]\nEuler yöntemini hatırlayalım. \\(y'(x)=f(y,x)\\) bağıntısını da kullanalım.\n\\[\ny(x+h)= y(x)+hy'(y,x) = y(x)+hf(y,x)\n\\]\nTaylor serisinin ikinci mertebesinden kesmeden önce en genel formülü yazalım. Bu formül Runge-Kutta yöntemlerinin genel formülüdür.\n\\[\ny(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hf(x+ph,y+qhF(y,x))\n\\]\nBurada \\(c_{0},c_{1},p,q\\) birer katsayıdır. Taylor serisine dönelim.\n\\[\n\\begin{align*}\ny(x+h) &= y(x) + y'(x)h + \\frac{1}{2}y''(x)h^{2}\\\\\n       &= y(x) + F(y,x)h + \\frac{1}{2}f'(y,x)h^{2}    \n\\end{align*}\n\\]\nBurada \\(f'(y,x)\\) aşağıdaki gibi yazılır.\n\\[\n\\begin{align*}\nf'(y,x)&= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}f \\\\\n       &= \\frac{\\partial f}{\\partial x} + \\frac{\\partial f}{\\partial y}y'\n\\end{align*}\n\\]\nVektörize edilmiş \\(F\\) için ise,\n\\[\nF'(y,x)= \\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nşeklinde yazılır. Taylor açılımından elde ettiğimiz denklemde yerine koyarsak,\n\\[\ny(x+h)= y(x) + F(y,x)h + \\frac{h^{2}}{2}\\frac{\\partial F}{\\partial x} + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\n\\]\nifadesini elde ederiz. Şimdi genelleştirilmiş formülü, yani \\(y(x+h)= y(x)+c_{0}hF(y,x) + c_{1}hF(x+ph,y+qhF(y,x))\\) terimindeki \\(F(x+ph,y+qhF(y,x))\\) terimi açalım.\n\\[\nF(x+ph,y+qhF(y,x)) = F(y,x) + \\frac{\\partial F}{\\partial x}ph + \\sum_{i=0}^{n-1}\\frac{\\partial F}{\\partial y_{i}}qhF_{i}(y,x)\n\\]\n\nYukarıdaki açılımı genelleştirilmiş formülde yerine koyalım.\n\n\\[\ny(x+h) = y(x) + (c_{0}+c_{1})F(y,x)h+ c_{1}\\left[\\frac{\\partial F}{\\partial x}ph + qh \\sum_{i=1}^{n-1}\\frac{\\partial F}{\\partial y_{i}}F_{i}(y,x)\\right]\n\\]\nBurada elde ettiğimiz formül ile Taylor serisinde elde ettiğimiz formülü karşılaştıralım. Eğer\n\\[\nc_{0}+c_{1}=1 \\quad \\text{ve} \\quad c_{1}p=c_{1}q=\\frac{1}{2}\n\\]\nolursa, iki formül de aynı olur. Buradaki \\(c_{0}, c_{1},q,p\\) parametreleri farklı farklı seçilebilir. Bazı farklı seçimler için özel isimlendirme yapılır.\n\n\n\nİsim\n\\(c_{0}\\)\n\\(c_{1}\\)\np\nq\n\n\n\n\nDeğiştirilmiş (Modified) Euler\n0\n1\n1/2\n1/2\n\n\nHeun Yöntemi\n1/2\n1/2\n1\n1\n\n\nRalston Yöntemi\n1/3\n2/3\n3/4\n3/4\n\n\n\n\nTüm bu sınıflandırma 2. derece Runge-Kutta yöntemleri altındadır.\nBu yöntemler birbirlerinden üstün değildir.\nBirinci derece Runge-Kutta yöntemi olan Euler yönteminde ise \\(c_{0}=1\\) ve diğer terimler sıfırdır.\n\nGenelleştirmek adına değiştirilmiş Euler motdunu aşağıdaki gibi yazabiliriz.\n\\[\n\\vec{y}(x+h) = \\vec{y}(x) + \\vec{F}\\left[x+\\frac{h}{2},\\vec{y}+\\frac{h}{2}\\vec{F}(x,\\vec{y}) \\right]\n\\]\nRunge-Kutta metodları için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\vec{K}_{0} = h\\vec{F}(x,\\vec{y})\n\\]\n\nEn popüler Runge-Kutta diferansiyel denklem çözme yöntemi dördüncü dereceden Runge-Kutta yöntemidir.\n\n\n\n\nDördüncü Derece Runge-Kutta yöntemi için \\(\\vec{K}_{i}\\) vektörleri tanımlanır.\n\\[\n\\begin{align*}\n    \\vec{K}_{0} &= h\\vec{F}(x,\\vec{y})\\\\\n    \\vec{K}_{1} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{0}\\right)\\\\\n    \\vec{K}_{2} &= h\\vec{F}\\left(x+\\frac{h}{2},\\vec{y}+\\frac{1}{2}\\vec{K}_{1}\\right)\\\\\n    \\vec{K}_{3} &= h\\vec{F}\\left(x+h,\\vec{y}+\\vec{K}_{2}\\right)\n\\end{align*}\n\\]\nSonuç olarak bir sonraki adım aşağıdaki gibi yazılır.\n\\[\n\\vec{y}(x+h)= \\vec{y}(x) + \\frac{1}{6}\\left(\\vec{K}_{0}+2\\vec{K}_{1}+2\\vec{K}_{2}+\\vec{K}_{3}\\right)\n\\]\nKatsayı tablosu oluşturalım.\n\n\n\n\n\n\n\n\n\n\\(K_{0}\\)\n\\(K_{1}\\)\n\\(K_{2}\\)\n\\(K_{3}\\)\n\n\n\n\n\\(hF(y,x)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{0}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+\\frac{1}{2}K_{1}, x+\\frac{h}{2}\\right)\\)\n\\(hF\\left(y+K_{2}, x+h\\right)\\)\n\n\n\nKatsayıları kullanarak bir sonraki adım hesaplanır.\n\\[\ny(x+h)= y(x) + \\frac{1}{6}(K_{0}+2K_{1}+2K_{2}+K_{3})\n\\]\nPython kodunu yazalım. add_coz_rk4_sistem adlı fonksiyon bilYonMod.py modülünde tanımlıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_rk4_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-1",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBirbirine bağlı iki adet diferansiyel denklemi çözmek için Euler yöntemini, 4. Mertebe Runge-Kutta ve scipy.integrate.odeint yöntemlerini kullanınız. Toplamda 10 adım kullanın.\nDenklem sistemi aşağıdaki gibidir.\n\\[\n\\begin{align*}\n\\frac{d}{dx}y(v(x), x) &= v(x) \\\\\n\\frac{d}{dx}v(x) &= x\n\\end{align*}\n\\]\nAnalitik çözümü yazabiliriz. Önce \\(v(x)\\)’i çözelim.\n\\[\n\\frac{d}{dx}v(x) = x \\Rightarrow v(x) = \\frac{x^{2}}{2} + C\n\\]\nBaşlangıç koşulunu, \\(v(0)=0\\) koşulunu kullanarak \\(C\\) sabitini bulalım.\n\\[\nv(0) = 0 \\Rightarrow C = 0  \\Rightarrow v(x) = \\frac{x^{2}}{2}\n\\]\nŞimdi \\(y(x)\\)’i çözelim.\n\\[\n\\begin{align*}\n    \\frac{d}{dx}y(v(x), x) =& v(x) \\\\\n    y(x) =& \\int v(x)dx \\\\\n         =& \\int \\frac{x^{2}}{2}dx = \\frac{x^{3}}{6} + C\n\\end{align*}\n\\]\nBaşlangıç koşulunu, \\(y(0)=1\\) koşulunu kullanarak \\(C\\) sabitini bulalım.\n\\[\ny(0) = 1 \\Rightarrow C = 1 \\Rightarrow y(x) = \\frac{x^{3}}{6} + 1\n\\]\nAnalitik çözüm aşağıdaki gibi olur.\n\\[\ny(x)= \\frac{x^{3}}{6} + 1 \\quad \\text{ve} \\quad v(x) = \\frac{x^{2}}{2}\n\\]\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.integrate as spInt\n# Fonksiyon\ndef fonk_yVek_x(yVek, x):\n    dydx = yVek[1]\n    return np.array([dydx, x])\n# Başlangıç koşulları\ny0 = 1\nv0 = 0\nx0 = 0\nxSon = 10\nn = 10\n# Çöz, Euler\nxTumEuler, yTum_VekEuler = bym.add_coz_euler_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Çöz, 4. Mertebe Runge-Kutta\nxTumRK4, yTum_VekRK4 = bym.add_coz_rk4_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Çöz, scipy.integrate.odeint\nxTumScipy= np.linspace(x0, xSon, n)\nyTumScipy= spInt.odeint(fonk_yVek_x, np.array([y0, v0]), xTumScipy)\n# Analitik çözüm\nyAnalitik = xTumEuler**3/6 + 1\nvAnalitik = xTumEuler**2/2\n# Çiz\nfig, ax = plt.subplots(1, 2)\n# Sol grafik\nax[0].plot(xTumEuler, yTum_VekEuler[0], lw='5', label='y(x) Euler', color='red')\nax[0].plot(xTumRK4, yTum_VekRK4[0], lw='3', label='y(x) RK4', color='green')\nax[0].plot(xTumScipy, yTumScipy[:,0], lw='1', label='y(x) Scipy', color='blue')\nax[0].plot(xTumEuler, yAnalitik, label='y(x) Analitik', color='black', linestyle='--')\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\nax[0].legend()\n# Sağ grafik\nax[1].plot(xTumEuler, yTum_VekEuler[1], lw='5', label='v(x) Euler', color='blue')\nax[1].plot(xTumRK4, yTum_VekRK4[1], lw='3', label='v(x) RK4', color='green')\nax[1].plot(xTumScipy, yTumScipy[:,1], lw='1', label='v(x) Scipy', color='red')\nax[1].plot(xTumEuler, vAnalitik, label='v(x) Analitik', color='cyan', linestyle='--')\nax[1].set_xlabel('x')\nax[1].set_ylabel('v(x)')\nax[1].legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-2",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#alıştırma-2",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\nAşağıdaki diferansiyel denklem sistemini tüm bildiğiniz çözüm yöntemleri ile çözün  [1].\n\n\n\n\n\n\\[\n\\begin{align*}\nm_{1}\\ddot{x}_{1}+b_{1}\\dot{x}_{1}+ k_{1}(x_{1} - L_{1})-k_{2}(x_{2}-x_{1}-L_{2})=0 \\\\\nm_{2}\\ddot{x}_{2}+b_{2}\\dot{x}_{2}+ k_{2}(x_{2}- x_{1}-L_{2})=0\n\\end{align*}\n\\]\n\n\\(m_{1}= 1\\) kg, \\(m_{2}=1.5\\) kg: Cisimlerin kütlesi\n\\(k_{1}= 8\\) N/m, \\(k_{2}=40.0\\) N/m: Yayların esneklik katsayısı\n\\(b_{1}= 0.8\\) Ns/m, \\(b_{2}=0.5\\) Ns/m: Sürtünme katsayısı\n\\(L_{1}= 0.5\\) m, \\(L_{2}=1.0\\) m: Yayların kuvvet yokkenki uzunluğu\n\nBaşlangıç koşulları:\n\n\\(x_{1}=0.5\\) m\n\\(v_{1}=0.0\\) m/s\n\\(x_{2}=2.25\\) m\n\\(v_{2}=0.0\\) m/s\n\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.integrate as spInt\n# Global değişkenler\nm1 = 1.0\nm2 = 1.5\nk1 = 8.0\nk2 = 40.0\nL1 = 0.5\nL2 = 1.0\nb1 = 0.8\nb2 = 0.5\n# Fonksiyonlar\ndef fonkVek(yVek, t):\n    x1= yVek[0]\n    v1= yVek[1]\n    x2= yVek[2]\n    v2= yVek[3]\n    return np.array([v1\\\n        , (-b1 * v1 - k1 * (x1 - L1) + k2 * (x2 - x1 - L2)) / m1 \\\n        , v2 \\\n        , (-b2 * v2 - k2 * (x2 - x1 - L2)) / m2])\n# Başlangıç koşulları\nyVek0= np.array([0.5, 0.0, 2.25, 0.0])\nt0=0\ntSon=50\nn=100\n# Çöz, Euler\ntTumEuler, yTum_VekEuler = bym.add_coz_euler_sistem(fonkVek, t0, tSon, yVek0, n)\n# Çöz, 4. Mertebe Runge-Kutta\ntTumRK4, yTum_VekRK4 = bym.add_coz_rk4_sistem(fonkVek, t0, tSon, yVek0, n)\n# Çöz, scipy.integrate.odeint\ntTumScipy= np.linspace(t0, tSon, n)\nyTumScipy= spInt.odeint(fonkVek, yVek0, tTumScipy)\n# Çiz\nfig, ax = plt.subplots(2, 2)\n# Sol üst grafik\nax[0,0].plot(tTumEuler, yTum_VekEuler[0], lw='5', label='x1(t) Euler', color='red')\nax[0,0].plot(tTumRK4, yTum_VekRK4[0], lw='3', label='x1(t) RK4', color='green')\nax[0,0].plot(tTumScipy, yTumScipy[:,0], lw='1', label='x1(t) Scipy', color='blue')\nax[0,0].set_xlabel('t')\nax[0,0].set_ylabel('x1(t)')\nax[0,0].legend()\n# Sağ üst grafik\nax[0,1].plot(tTumEuler, yTum_VekEuler[1], lw='5', label='v1(t) Euler', color='blue')\nax[0,1].plot(tTumRK4, yTum_VekRK4[1], lw='3', label='v1(t) RK4', color='green')\nax[0,1].plot(tTumScipy, yTumScipy[:,1], lw='1', label='v1(t) Scipy', color='red')\nax[0,1].set_xlabel('t')\nax[0,1].set_ylabel('v1(t)')\nax[0,1].legend()\n# Sol alt grafik\nax[1,0].plot(tTumEuler, yTum_VekEuler[2], lw='5', label='x2(t) Euler', color='red')\nax[1,0].plot(tTumRK4, yTum_VekRK4[2], lw='3', label='x2(t) RK4', color='green')\nax[1,0].plot(tTumScipy, yTumScipy[:,2], lw='1', label='x2(t) Scipy', color='blue')\nax[1,0].set_xlabel('t')\nax[1,0].set_ylabel('x2(t)')\nax[1,0].legend()\n# Sağ alt grafik\nax[1,1].plot(tTumEuler, yTum_VekEuler[3], lw='5', label='v2(t) Euler', color='blue')\nax[1,1].plot(tTumRK4, yTum_VekRK4[3], lw='3', label='v2(t) RK4', color='green')\nax[1,1].plot(tTumScipy, yTumScipy[:,3], lw='1', label='v2(t) Scipy', color='red')\nax[1,1].set_xlabel('t')\nax[1,1].set_ylabel('v2(t)')\nax[1,1].legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-fehlberg-rk45-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#runge-kutta-fehlberg-rk45-yöntemi",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Runge-Kutta-Fehlberg (RK45) Yöntemi",
    "text": "Runge-Kutta-Fehlberg (RK45) Yöntemi\n\nRunge-Kutta-Fehlberg (RK45) yöntemi, dördüncü ve beşinci mertebe Runge-Kutta yöntemi kullanarak çözüm elde eder.\nRK45, değişken adım aralığı (adaptive step size) kullanır.\nRK45’in girdilerinden (input) biri rölatif (relative) hata değeridir. RK4 ile elde edilen sonuç ile RK5 ile elde edilen sonuç arasındaki fark rölatif hatadan büyükse adım aralığı küçültülür ve o adım tekrar hesaplanır.\nBunun gibi metotlara değişken (adaptive) adım aralığı yöntemleri denir.\nRunge-Kutta metotları açık (explicit) yöntemlerdir.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#scipy-paketleri-hakkında",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#scipy-paketleri-hakkında",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Scipy Paketleri Hakkında",
    "text": "Scipy Paketleri Hakkında\n\nScipy içerisinde başlangıç değer problemi çözümleri için birçok fonksiyon var  [2].\nEski api olarak odeint hala kullanılabiliyor ancak scipy’ın gelecekteki versiyonlarında çıkarılma ihtimali çok yüksek.\nodeint fonksiyonunda çağırılan \\(f\\) fonksiyonunda \\(f(y,t)\\) olmak zorunda. solve_ivp’de ise bu durum tam tersi. Bu farklılığı tfirst=True parametresi ile değiştirebilirsiniz - 1.1.0 versiyonundan itibaren.\nodeint ile ilgili bilgi için  [3] referansına bakabilirsiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-runge-kutta-yontemleri.html#problemler",
    "title": "BDP - Runge-Kutta Yöntemleri",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAşağıdaki matris denklemlerini yazdığımız rk4 fonksiyonu ile çözün.\n\\[\n\\begin{align*}\n\\frac{d}{dt}\n\\begin{bmatrix}\n\\rho_{11}(t) & \\rho_{12}(t) \\\\\n\\rho_{21}(t) & \\rho_{22}(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\rho_{11}(t) & -2\\rho_{12}(t) \\\\\n-3\\rho_{21}(t) & -4\\rho_{22}(t)\n\\end{bmatrix}\n\\end{align*}\n\\]\n\n\nProblem 2\nscipy.integrate.solve_ivp fonksiyonunu kullanarak aşağıdaki denklemi çözün. Çözüm yöntemi olarak method='RK45' ve method='LSODA' kullanın.\n\\[\n\\frac{d}{dx}y(x) = \\sin(5x)\n\\]\nBaşlangıç koşulu: \\(y(-3)=4.5\\). Çözümü -3 ile 3 arasında çizdirin.\nAynı denklemi sağ taraf \\(\\sin(15x)\\) ve \\(\\sin(25x)\\) olacak şekilde çözün.\n\n\nProblem 3\nSönümlü harmonik salınıcının Lagranjiyen’i aşağıdaki gibidir.\n\\[\nL(x,v) = \\frac{1}{2}mv^{2} - \\frac{1}{2}kx^2\n\\]\nBurada \\(v\\) hız olup konumun \\(x\\) zamana göre birinci türevine eşittir. Lagrange hareket denklemleri aşağıdaki gibi yazılır.\n\\[\n    \\left(\\frac{d}{dt}\\frac{\\partial L}{\\partial v} \\right) - \\frac{\\partial L}{\\partial x} = \\frac{\\partial F^{dis}}{\\partial v}\n\\]\nYukarıda verilen formülden diferansiyel denklem setini oluşturun. Burada \\(F^{dis}=-\\frac{1}{2}bv^{2}\\) sönümleyici kuvvettir. \\(t=0-50\\) arasındaki değerler için ve \\(n=1000\\) adımda, - Runge-Kutta-4 (veya 5(4) mertebe için Runge-Kutta methodu) yöntemi ile çözün. - x ile t’nin oluşturduğu grafiği çizdirin.\nBaşlangıç koşulları ve sabitler aşağıdaki gibidir.\n\n\\(m=1\\) kg\n\\(k=1\\) N/m\n\\(b=0.1\\) Ns/m\n\\(x(t=0)=1\\) m\n\\(v(t=0)=0\\) m/s\n\n\n\nProblem 4\nAşağıdaki diferansiyel denklemi Runge Kutta 4(5) yöntemini kullanarak \\(N=100\\) adımda çözün. Analitik sonuçla karşılaştırın.\n\\[\ny''(t) = t^{3}+t+5, \\quad y(0)=1, \\quad y'(0)=5\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Runge-Kutta Yöntemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html",
    "title": "BDP - Giriş",
    "section": "",
    "text": "Amaç \\(y'=F(x,y)\\) denklemini, \\(y(a)=\\alpha\\) başlangıç koşuluyla çözüp \\(y(x)\\)’i istenilen aralıkta elde etmek.\nAşağıdaki gibi formda olan diferansiyel denklemlere birinci dereceden adi diferansiyel denklemler denir.\n\\[\n\\frac{dy}{dx}=y'=f(x)\n\\]\nHer iki tarafın integralini alırsak sağ tarafta bir integral sabiti olur. Bu integral sabitini belirlemek için bir adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nEğer n. dereceden diferansiyel denklem varsa, yani \\(y^{(n)}=f(x,y,y',\\cdots,y^{(n-1)})\\), bu durumda n adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nYüksek dereceden diferansiyel denklemler düşük dereceden diferansiyel denklemlere çevrilebilir. Örneğin,\n\\[\ny''=-y(x) \\qquad y'(x) \\equiv v(x) \\qquad v'(x)=-y(x)\n\\]\nYukarıdaki denklemin koşulları \\(y(0)=1\\), \\(v(0)=1\\) şeklinde ise başlangıç değer problemi, \\(y(0)=1\\) ve \\(v(100)=0\\) şeklinde farklı ise sınır değer problemi olarak tanımlanır.\nDiferansiyel denklemler tek halde bulunabildiği gibi çoklu halde de bulunabilir. Örneğin,\n\\[\n\\textbf{y}'=\\textbf{F}(x,\\textbf{y})\n\\]\n\\[\n\\begin{bmatrix}\ny_1' \\\\\ny_2' \\\\\n\\vdots \\\\\ny_n'\n\\end{bmatrix}=\n\\begin{bmatrix}\nf_1(x,y_1,y_2,\\cdots,y_n) \\\\\nf_2(x,y_1,y_2,\\cdots,y_n) \\\\\n\\vdots \\\\\nf_n(x,y_1,y_2,\\cdots,y_n)\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html#başlangıç-değer-problemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-giris.html#başlangıç-değer-problemi",
    "title": "BDP - Giriş",
    "section": "",
    "text": "Amaç \\(y'=F(x,y)\\) denklemini, \\(y(a)=\\alpha\\) başlangıç koşuluyla çözüp \\(y(x)\\)’i istenilen aralıkta elde etmek.\nAşağıdaki gibi formda olan diferansiyel denklemlere birinci dereceden adi diferansiyel denklemler denir.\n\\[\n\\frac{dy}{dx}=y'=f(x)\n\\]\nHer iki tarafın integralini alırsak sağ tarafta bir integral sabiti olur. Bu integral sabitini belirlemek için bir adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nEğer n. dereceden diferansiyel denklem varsa, yani \\(y^{(n)}=f(x,y,y',\\cdots,y^{(n-1)})\\), bu durumda n adet başlangıç koşuluna veya sınır değere ihtiyaç vardır.\nYüksek dereceden diferansiyel denklemler düşük dereceden diferansiyel denklemlere çevrilebilir. Örneğin,\n\\[\ny''=-y(x) \\qquad y'(x) \\equiv v(x) \\qquad v'(x)=-y(x)\n\\]\nYukarıdaki denklemin koşulları \\(y(0)=1\\), \\(v(0)=1\\) şeklinde ise başlangıç değer problemi, \\(y(0)=1\\) ve \\(v(100)=0\\) şeklinde farklı ise sınır değer problemi olarak tanımlanır.\nDiferansiyel denklemler tek halde bulunabildiği gibi çoklu halde de bulunabilir. Örneğin,\n\\[\n\\textbf{y}'=\\textbf{F}(x,\\textbf{y})\n\\]\n\\[\n\\begin{bmatrix}\ny_1' \\\\\ny_2' \\\\\n\\vdots \\\\\ny_n'\n\\end{bmatrix}=\n\\begin{bmatrix}\nf_1(x,y_1,y_2,\\cdots,y_n) \\\\\nf_2(x,y_1,y_2,\\cdots,y_n) \\\\\n\\vdots \\\\\nf_n(x,y_1,y_2,\\cdots,y_n)\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "",
    "text": "Sonlu farklar yöntemini kullanarak sınır değer problemine ait diferansiyel denklem çözeceğiz. Bunun için Taylor açılımını kullanacağız. Taylor açılımında birinci türevi orta noktayı kullanarak yazalım.\n\\[\ny'_{i} = \\frac{y_{i+1}-y_{i-1}}{2h}\n\\]\nFarz edelim ki bu fonksiyonu \\(g_{i}\\) için yazmışız.\n\\[\ng'_{i} = \\frac{g_{i+1}-g_{i-1}}{2h}\n\\]\nBu \\(g_{i}\\) fonksiyonu \\(y'_{i}\\) fonksiyonuna eşit olsun. Yani \\(g_{i}=y'_{i}\\) olur. Bu durumda\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{y'_{i+1}-y'_{i-1}}{2h} \\\\\n            &= \\frac{1}{2h}\\left(\\frac{y_{i+2}-y_{i}}{2h}-\\frac{y_{i}-y_{i-2}}{2h}\\right)\n\\end{align*}\n\\]\nBiraz düzenleyelim.\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{1}{4h^2}\\left(y_{i+2}-y_{i}-y_{i}+y_{i-2}\\right) \\\\\n            &= \\frac{y_{i+2}-2y_{i}+y_{i-2}}{4h^2}\n\\end{align*}\n\\]\nEğer adım aralığını yarıya indirirsek yani \\(h \\rightarrow h/2\\) yaparsak \\(y_{i+2}\\) noktasından \\(y_{i+1}\\) noktasına gelebiliriz. Benzer şekilde \\(y_{i-2}\\) noktasından \\(y_{i-1}\\) noktasına geliriz. O halde ikinci türeve ait olan denklem şöyle olur.\n\n\n\n\n\n\nNot\n\n\n\nBu işlem sadece sabit adım aralığı için geçerlidir.\n\n\n\\[\ny''_{i} = \\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\nBu denklemi kullanarak sınır değer problemlerini çözeceğiz. Yukarıdaki bağıntı, diferansiyel denklemi cebirsel denklem sistemine dönüştürür.\n\\[\ny''_{i} = f\\left(x,y_{i},\\frac{y_{i+1}-y_{i-1}}{2h}\\right)=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yöntemi",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "",
    "text": "Sonlu farklar yöntemini kullanarak sınır değer problemine ait diferansiyel denklem çözeceğiz. Bunun için Taylor açılımını kullanacağız. Taylor açılımında birinci türevi orta noktayı kullanarak yazalım.\n\\[\ny'_{i} = \\frac{y_{i+1}-y_{i-1}}{2h}\n\\]\nFarz edelim ki bu fonksiyonu \\(g_{i}\\) için yazmışız.\n\\[\ng'_{i} = \\frac{g_{i+1}-g_{i-1}}{2h}\n\\]\nBu \\(g_{i}\\) fonksiyonu \\(y'_{i}\\) fonksiyonuna eşit olsun. Yani \\(g_{i}=y'_{i}\\) olur. Bu durumda\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{y'_{i+1}-y'_{i-1}}{2h} \\\\\n            &= \\frac{1}{2h}\\left(\\frac{y_{i+2}-y_{i}}{2h}-\\frac{y_{i}-y_{i-2}}{2h}\\right)\n\\end{align*}\n\\]\nBiraz düzenleyelim.\n\\[\n\\begin{align*}\n    y''_{i} &= \\frac{1}{4h^2}\\left(y_{i+2}-y_{i}-y_{i}+y_{i-2}\\right) \\\\\n            &= \\frac{y_{i+2}-2y_{i}+y_{i-2}}{4h^2}\n\\end{align*}\n\\]\nEğer adım aralığını yarıya indirirsek yani \\(h \\rightarrow h/2\\) yaparsak \\(y_{i+2}\\) noktasından \\(y_{i+1}\\) noktasına gelebiliriz. Benzer şekilde \\(y_{i-2}\\) noktasından \\(y_{i-1}\\) noktasına geliriz. O halde ikinci türeve ait olan denklem şöyle olur.\n\n\n\n\n\n\nNot\n\n\n\nBu işlem sadece sabit adım aralığı için geçerlidir.\n\n\n\\[\ny''_{i} = \\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\nBu denklemi kullanarak sınır değer problemlerini çözeceğiz. Yukarıdaki bağıntı, diferansiyel denklemi cebirsel denklem sistemine dönüştürür.\n\\[\ny''_{i} = f\\left(x,y_{i},\\frac{y_{i+1}-y_{i-1}}{2h}\\right)=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#alıştırma-1",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nAşağıdaki denklemi adım adım çözelim.\n\\[\ny''(t)=t, \\quad y(0)=1, \\quad y(3)=9\n\\]\n\nÇözüm (Elle)\nAdım aralığı \\(h=1\\) olsun. Çözeceğimiz \\(t\\)’nin değerleri \\(0, 1, 2, 3\\) olacaktır. Bu değerlerden \\(y\\) değerlerini bulalım.\n\\[\ny''(t)=t=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\nÇözüme \\(y(0)\\)’dan başlayalım. Bunun için \\(y(0) \\equiv y_{i-1}\\) almamız gerekecektir. Aksi taktirde köşe noktalar için denklemi çözemeyiz.\nAşağıdaki tabloyu \\(h=1\\) için yazalım.\n\n\n\n\\(y_{0}\\)\n\\(y_{1}\\)\n\\(y_{2}\\)\n\\(y_{3}\\)\n\n\n\n\n\\(y(0)\\)\n\\(y(0+h)\\)\n\\(y(0+2h)\\)\n\\(y(0+3h)\\)\n\n\n\\(y(t=0)\\)\n\\(y(t=1)\\)\n\\(y(t=2)\\)\n\\(y(t=3)\\)\n\n\n1\n?\n?\n9\n\n\n\nÖrneğin aşağıdaki tabloyu da \\(h=0.5\\) için yazalım.\n\n\n\n\n\n\n\n\n\n\n\n\n\\(y_{0}\\)\n\\(y_{1}\\)\n\\(y_{2}\\)\n\\(y_{3}\\)\n\\(y_{4}\\)\n\\(y_{5}\\)\n\\(y_{6}\\)\n\n\n\n\n\\(y(0)\\)\n\\(y(0.5)\\)\n\\(y(1)\\)\n\\(y(1.5)\\)\n\\(y(2)\\)\n\\(y(2.5)\\)\n\\(y(3)\\)\n\n\n1\n?\n?\n?\n?\n?\n9\n\n\n\nŞimdi yukarıdaki elde ettiğimiz denklemi yazalım.\n\\[\ny''(t)=t=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\n\\(i=1\\) olmalı. Bundan dolayı \\(t\\) ilk değil bir sonraki adımından yani \\(t+h=0+0.5\\)’den itibaren başlatmalıyız. \\[\n0.5 = \\frac{y_{2}-2y_{1}+y_{0}}{h^2}\n\\]\nBu denklemi \\(h=0.5\\) için adım adım yazalım.\n\\[\n\\begin{align*}\n    0.5\\times (0.5)^{2} =& y_{2}-2y_{1}+y_{0}\\\\\n    1\\times (0.5)^{2} =& y_{3}-2y_{2}+y_{1}\\\\\n    1.5\\times (0.5)^{2} =& y_{4}-2y_{3}+y_{2}\\\\\n    2\\times (0.5)^{2} =& y_{5}-2y_{4}+y_{3}\\\\\n    2.5\\times (0.5)^{2} =& y_{6}-2y_{5}+y_{4}\n\\end{align*}\n\\]\nYukarıdaki denklemleri matris şeklinde yazalım. Yazarken \\(y_{0}=1\\) ve \\(y_{6}=9\\) yazacağız.\n\\[\n\\begin{align*}\n-0.875 =& y_{2}-2y_{1}\\\\\n0.25 =& y_{3}-2y_{2}+y_{1}\\\\\n0.375 =& y_{4}-2y_{3}+y_{2}\\\\\n0.5 =& y_{5}-2y_{4}+y_{3}\\\\\n-8.375 =& -2y_{5}+y_{4}\n\\end{align*}\n\\]\nMatris şeklinde yazalım.\n\\[\n\\begin{bmatrix}\n    -2 & 1 & 0 & 0 & 0\\\\\n    1 & -2 & 1 & 0 & 0\\\\\n    0 & 1 & -2 & 1 & 0\\\\\n    0 & 0 & 1 & -2 & 1\\\\\n    0 & 0 & 0 & 1 & -2\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n    y_{1}\\\\\n    y_{2}\\\\\n    y_{3}\\\\\n    y_{4}\\\\\n    y_{5}\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\n    -0.875\\\\\n    0.25\\\\\n    0.375\\\\\n    0.5\\\\\n    -8.375    \n\\end{bmatrix}\n\\]\nBu denklemi çözmeyi biliyoruz. Denklemi çözdüğümüzde \\(y_{1}, y_{2}, y_{3}, y_{4}, y_{5}\\) değerlerini bulmuş oluruz.\n\n\nÇözüm (Kod)\n\nimport numpy as np\nfrom scipy.linalg import solve\nimport matplotlib.pyplot as plt\n# Katsayı Matrisi\ncoefMat= np.array([\\\n      [-2, 1, 0, 0, 0]\\\n    , [ 1,-2, 1, 0, 0]\\\n    , [ 0, 1,-2, 1, 0]\\\n    , [ 0, 0, 1,-2, 1]\\\n    , [ 0, 0, 0, 1,-2]])\n# Sonuç Matrisi\nsolMat= np.array([-0.875,0.25,0.375,0.5,-8.375])\n# Doğrusal Denklemi Çöz\nsolution=solve(coefMat, solMat)\n# Başlangıç Değeri\ny0= 1.\n# Çözümü Başına Ekle\nsolution=np.insert(solution, 0, y0)\n# Bitiş Değeri\nySon= 9.\n# Çözümü Sonuna Ekle\nsolution=np.append(solution, ySon)\n# Çözmek istediğimiz t değerleri\nt= np.linspace(0, 3, 7)\n# Çiz\nplt.plot(t, solution, 'o-', label='Sonlu Farklar')\n# --------------------------------------------\n# Analitik Çözüm\n# y''= t y(0)=1 y(3)=9\n# y'= t^2/2  + C1\n# y= t^3/6  + C1 t + C2\n# y(0)=1 =&gt; C2=1\n# y(3)=9 =&gt; 9=27/6 + 3C1 + 1=9 =&gt; C1=27/18\n#=&gt; y(t)= t^3/6 + 21t/18 + 1\n# --------------------------------------------\nplt.plot(t, t**3/6 + 21*t/18 + 1, 'r-', label='Analitik')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nMatris denklemini el ile yazmadan yani başlangıçta biz vermeden çözmeye çalışalım.\n\nimport numpy as np\nfrom scipy.linalg import solve\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk(t):\n    return t\n# Sınır Değerleri\ny_t0=1\ny_t3=9\n# Adım aralığı\nh=0.5\n# Tum t değerleri\nt0=0\ntSon=3\n# adet=(tSon-t0/h)+1\nadet= int((tSon-t0)/h)+1\ntTum=np.linspace(t0, tSon, adet)\n# Yerine koyduğumuzda oluşan denklemler (tabloya bakınız)\n# y''(t)=t = (y_{i+1}-2y_{i}+y_{i-1})/h^2\n# t * h^2 = y_{i+1}-2y_{i}+y_{i-1}\n# ilk denklem için t= h olacak. i=1 olacak\n# h * h^2 = y_{2}-2y_{1}+y_{0}\n# ilkDenklemSagTaraf= h*(h**2)-y_{0}\n# Son denklem için t= tSon-h olacak. i=son-1 olacak\n# (tSon-h) * h^2 = y_{son}-2y_{son-1}+y_{son-2}\n# sonDenklemSagTaraf=(tSon-h)*(h**2)-y_{son}\nilkDenklemSagTaraf=fonk(h)*(h**2)-y_t0\nsonDenklemSagTaraf=fonk(tSon-h)*(h**2)-y_t3\n# Ara denklemleri oluştur.\n# araDenklemlerSagTaraf[0]=ilkDenklemSagTaraf\naraDenklemlerSagTaraf=np.array(ilkDenklemSagTaraf)\nfor i in range(1, adet-3):\n    araDenklemlerSagTaraf= np.append(araDenklemlerSagTaraf, fonk(tTum[i+1])*(h**2))\n# Son denklemi ekle\nsonucMatrisi= np.append(araDenklemlerSagTaraf,sonDenklemSagTaraf)\n# Katsayı Matrisi\nkatsayiMat= np.zeros((adet-2, adet-2))\n# y''(t)=t = (y_{i+1}-2y_{i}+y_{i-1})/h^2\n# Denkleminde katsayılar hep aynı olur.\nfor i in range(adet-2):\n    katsayiMat[i, i]= -2\n    if not i == adet-3:\n        katsayiMat[i, i+1]= 1\n    if not i == 0:\n        katsayiMat[i, i-1]= 1\n# Çöz\nprint(f\"Katsayı Matrisi: \\n{katsayiMat}\")\nprint(f\"Sonuç Matrisi: \\n{sonucMatrisi}\")\ncozum=solve(katsayiMat, sonucMatrisi)\n# İlk Çözümü Ekle\ncozum=np.insert(cozum, 0, y_t0)\n# Son Çözümü Ekle\ncozum=np.append(cozum, y_t3)\n# Çiz\nplt.plot(tTum, cozum, 'o-', label='Sonlu Farklar')\nplt.plot(tTum, tTum**3/6 + 21*tTum/18 + 1, 'r-', label='Analitik')\nplt.legend()\nplt.show()\n\nKatsayı Matrisi: \n[[-2.  1.  0.  0.  0.]\n [ 1. -2.  1.  0.  0.]\n [ 0.  1. -2.  1.  0.]\n [ 0.  0.  1. -2.  1.]\n [ 0.  0.  0.  1. -2.]]\nSonuç Matrisi: \n[-0.875  0.25   0.375  0.5   -8.375]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yönteminin-çalışmadığı-örnek",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#sonlu-farklar-yönteminin-çalışmadığı-örnek",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Sonlu Farklar Yönteminin Çalışmadığı Örnek",
    "text": "Sonlu Farklar Yönteminin Çalışmadığı Örnek\nEğer oluşturduğumuz diferansiyel denklem sistemi doğrusal değilse, yukarıdaki algoritmayı kullanmayız. Aşağıdaki örneği inceleyelim.\n\\[\ny''(t)=tyy'(t)\n\\]\nÇözmemiz gereken denklem\n\\[\ny''(t)=tyy'(t)=\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^2}\n\\]\n\\(i=1\\) için yazalım.\n\\[\nty_{1}y_{1}'=\\frac{y_{2}-2y_{1}+y_{0}}{h^2}\n\\]\nTürevi de açıkça yazalım.\n\\[\nty_{1} \\frac{y_{2}-y_{0}}{2h}=\\frac{y_{2}-2y_{1}+y_{0}}{h^2}\n\\]\nDüzenleyelim.\n\\[\n\\frac{th}{2} (y_{1}y_{2}-y_{1}y_{0}) -y_{2}+2y_{1}-y_{0} = 0\n\\]\n\\(y_{1}y_{2}\\) gibi terimlerin varlığından dolayı bu denklem doğrusal olmayan (nonlineer) denklemdir. Klasik yöntemlerle (LU ayrıştırma veya Gauss eleme) çözülemez.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#problemler",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAşağıdaki diferansiyel denklemi sonlu farklar yöntemi kullanarak çözebilir misinz?\n\\[\n\\frac{\\hbar^{2}}{2 m}\\frac{d^{2}}{dx^{2}}\\psi(x) = E\\psi(x), \\qquad \\psi(x=0)=0, \\qquad \\psi(x=L)=0 \\text{.}\n\\]\nÇözümü \\(n=1\\) ve \\(n=2\\) için bulmaya çalışın. Hem bulduğunuz enerji değerlerini hem de dalga fonksiyonunun karesini (olasılık yoğunluğunu, \\(|\\psi(x)|^{2}\\)) çizdirin. \\(x\\) değerleri \\(0\\) ile \\(L\\) arasında \\(N=100\\) adet olsun.\nDenklemdeki katsayıları aşağıdaki gibi alın.\n\n\\(\\hbar=1\\)\n\\(m=1\\) kg\n\\(L=2\\)\n\nEnerji özdeğerinin gerçek değeri aşağıdaki gibi olmalıdır.\n\\(E=\\frac{\\pi^{2}\\hbar^{2}}{2mL^{2}}n^{2}\\) J.\nDalga fonksiyonunun analitik çözümü aşağıdaki gibi olmalıdır.\n\\[\n\\psi(x)=\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi x}{L}\\right)\n\\]\n\n\n\n\n\n\nTavsiye\n\n\n\nBu problem bir özdeğer problemidir. Diferansiyel operatörü \\(\\left(\\frac{d^{2}}{dx^{2}}\\right)\\) doğrusal operatörü matris şeklinde yazmalısınız. Bu matrisi sonlu farklar yönteminde yazdık.\n\n\n\n\nProblem 2\nAşağıdaki diferansiyel denklemi sonlu farklar yöntemini kullanarak çözün. Adım aralığını \\(h=0.05\\) alın. Analitik sonuçla karşılaştırın.\n\\[\ny''(t) = t^{3}+t+5, \\quad y(0)=1, \\quad y(6)=548.8\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#kaynaklar",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-sonlu-farklar-yontemi.html#kaynaklar",
    "title": "SDP - Sonlu Farklar Yöntemi",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Methods in Engineering with Python 3, Jaan Kiusalaas, Cambridge University Press, 2013, Syf:307\nSonlu Farklar Yöntemi, Youtube Videosu\nNumerical Solutions of Schrodinger’s Equation, Neill Lambert, 2001",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Sonlu Farklar Yöntemi"
    ]
  },
  {
    "objectID": "icerik/izlence.html",
    "href": "icerik/izlence.html",
    "title": "İzlence",
    "section": "",
    "text": "Bu bölümde MSGSÜ Fizik Bölümü’nde verilen derslerin izlenceleri yer almaktadır.",
    "crumbs": [
      "**İçerik**",
      "İzlence"
    ]
  },
  {
    "objectID": "icerik/izlence.html#fiz366---fizikte-bilgisayarlı-yöntemler-ii",
    "href": "icerik/izlence.html#fiz366---fizikte-bilgisayarlı-yöntemler-ii",
    "title": "İzlence",
    "section": "FIZ366 - Fizikte Bilgisayarlı Yöntemler II",
    "text": "FIZ366 - Fizikte Bilgisayarlı Yöntemler II\n\n2023-2024 Bahar Dönemi\n\nÖğretim Üyesi: Taygun Bulmuş\nE-posta: taygun.bulmus@msgsu.edu.tr\nDers Gün ve Saatleri: Salı 09:00-12:00\nUygulama Gün ve Saatleri: Cuma 15:00-17:00 (MS Teams)\nNotlandımra: İki Vize (%20 + %20), Quizler ve Ödevler (%20), Final (%40)\n\nDers İçeriği:\n\nAdi Diferansiyel Denklemler - Başlangıç Değer Problemleri\nAdi Diferansiyel Denklemler - Sınır Değer Problemleri\nFourier Analizi\nPandas Kütüphanesi\nVeri İşleme ve Analizi\nTemel İstatistik ve Olasılık\n\n\n\n\n\n\n\nUyarı\n\n\n\nKonuların işleyiş sırası değişebilir. Dönem içerisinde konu eklenebilir verya çıkarılabilir.\n\n\nKaynaklar:\n\nBilgisayarlı Yöntemler Github Sitesi, https://bulmust.github.io/bilgisayarli-yontemler/\n\n\n\n\n\n\n\nNot\n\n\n\nKullanılacak kaynaklar, notların altına eklenecektir.",
    "crumbs": [
      "**İçerik**",
      "İzlence"
    ]
  },
  {
    "objectID": "icerik/izlence.html#fiz365---fizikte-bilgisayarlı-yöntemler-i",
    "href": "icerik/izlence.html#fiz365---fizikte-bilgisayarlı-yöntemler-i",
    "title": "İzlence",
    "section": "FIZ365 - Fizikte Bilgisayarlı Yöntemler I",
    "text": "FIZ365 - Fizikte Bilgisayarlı Yöntemler I\n\n2022-2023 Güz Dönemi\n\nÖğretim Üyesi: Taygun Bulmuş\nE-posta: taygun.bulmus@msgsu.edu.tr\nDers Gün ve Saatleri: Cuma 13:00-16:00\nUygulama Gün ve Saatleri: Cuma 16:00-18:00\nOfis Saatleri: Cuma 10:00-12:00\nNotlandımra: İki Vize (%20 + %20), Quizler (%10), Ödevler (%10), Final (%40)\n\nDers İçeriği:\n\nDersin Tanıtımı, Python ile Programlamaya Giriş\nTemel Python Programlama - I\nTemel Python Programlama - II\nNumpy-Scipy-Matplotlib\nArasınav - I\nDoğrusal Denklem Sistemleri - I\nDoğrusal Denklem Sistemleri - II\nİnterpolasyon\nEğri Uydurma\nArasınav - II\nKök Bulma\nSayısal Türev Alma\nSayısal İntegral Alma\nAdi Diferansiyel Denklemler\n\n\n\n\n\n\n\n\nUyarı\n\n\n\nKonuların işleyiş sırası değişebilir. Dönem içerisinde konu eklenebilir verya çıkarılabilir.\n\n\nKaynaklar:\n\nNumerical Methods in Engineering with Python 3, Jaan Kiusalaas, Cambridge University Press, 2013,\nIntroduction to Engineering and Scientific Computing with Python, David E. Clough, Steven C. Chapra, 1. Baskı, 2022,\nSayısal Analiz ve Mühendislik Uygulamaları, İrfan Karagöz, 5. Baskı, 2019.",
    "crumbs": [
      "**İçerik**",
      "İzlence"
    ]
  },
  {
    "objectID": "icerik/bilYonMod.html",
    "href": "icerik/bilYonMod.html",
    "title": "Python Modülü",
    "section": "",
    "text": "Bilgisayarlı yöntemler notlarında kullanılan fonksiyonlardan oluşan modül bu linktedir: bilYonMod.py",
    "crumbs": [
      "**İçerik**",
      "Python Modülü"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "",
    "text": "İkinci dereceden diferansiyel denklemleri çözmek için Euler yöntemini iki kere kullanmak gerekir. Örneğin,\n\\[\ny''(x)+4y(x)=0\n\\]\nİlk adımda \\(y''\\) türevi yerine \\(v(x) \\equiv y'(x)\\) tanımlaması yapalım bu durumda denklem şu şekilde olur.\n\\[\nv'(x)=-4y\n\\]\nYukarıdaki denklem birinci dereceden bir diferansiyel denklem olduğu için Euler yöntemi ile çözülebilir. Bu denklemi çözdükten sonra \\(y(x)\\) fonksiyonunu bulmak için \\(y'(x)\\equiv v(x)\\) denklemini çözmemiz gerekir. Sonuç olarak ikinci dereceden diferansiyel denklemi 2 adet birbirine bağlı dif. denk. sistemi olarak düşünebiliriz.\nDikkat edilmesi gereken husus başlangıç koşullarının \\(y(x)\\) ve \\(v(x)\\) fonksiyonları için yazmaktır. İkinci dereden bir diferansiyel denklemin çözümünü bulabilmek için hem \\(y(x_{0})\\) hem de \\(y'(x_{0})=v(x_{0})\\) koşullarına ihtiyaç vardır.\nİkinci dereceden diferansiyel denklemleri çözmek üst üste Euler çözücü fonksiyonu çağırmak yerine denklemi vektörel bir şekilde yazabiliriz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#bdp---ikinci-dereceden-diferansiyel-denklemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#bdp---ikinci-dereceden-diferansiyel-denklemler",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "",
    "text": "İkinci dereceden diferansiyel denklemleri çözmek için Euler yöntemini iki kere kullanmak gerekir. Örneğin,\n\\[\ny''(x)+4y(x)=0\n\\]\nİlk adımda \\(y''\\) türevi yerine \\(v(x) \\equiv y'(x)\\) tanımlaması yapalım bu durumda denklem şu şekilde olur.\n\\[\nv'(x)=-4y\n\\]\nYukarıdaki denklem birinci dereceden bir diferansiyel denklem olduğu için Euler yöntemi ile çözülebilir. Bu denklemi çözdükten sonra \\(y(x)\\) fonksiyonunu bulmak için \\(y'(x)\\equiv v(x)\\) denklemini çözmemiz gerekir. Sonuç olarak ikinci dereceden diferansiyel denklemi 2 adet birbirine bağlı dif. denk. sistemi olarak düşünebiliriz.\nDikkat edilmesi gereken husus başlangıç koşullarının \\(y(x)\\) ve \\(v(x)\\) fonksiyonları için yazmaktır. İkinci dereden bir diferansiyel denklemin çözümünü bulabilmek için hem \\(y(x_{0})\\) hem de \\(y'(x_{0})=v(x_{0})\\) koşullarına ihtiyaç vardır.\nİkinci dereceden diferansiyel denklemleri çözmek üst üste Euler çözücü fonksiyonu çağırmak yerine denklemi vektörel bir şekilde yazabiliriz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#sec-alistirma1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#sec-alistirma1",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nSürtünmesiz bir düzlemde serbest düşen bir parçacığın konum zaman grafiğini ve hız zaman grafiğini Newton’un ikinci yasasını kullanarak çizin. \\(g=9.81\\) m/s \\(^{2}\\) sabit düşüş ivmesi. Denklemleri Euler yöntemi ile çözün. Başlangıç koşulları \\(v(0)=0\\) ve \\(y(0)=100\\) olsun. Çözümü \\(n=100\\) s adımda yapın. Zaman aralığı \\(t=0\\) s’den \\(t=10\\) s’ye kadar olsun.\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Global değişkenler\ng=9.81\n# Denklemin sağ tarafı\ndef F(yVek, x):\n    # F=m*a\n    # F=m*y''(t)\n    # -g=y''(t)\n    # y'(t)=v(t)\n    # v'(t)=-g\n    return np.array([yVek[1], -g])\n# Başlangıç koşulları\nx0=0\nyVek=np.array([100, 0])\nxStop=5\nn=100\n# Çöz\nxTum, yVekTum = bym.add_coz_euler_sistem(F, x0, xStop, yVek, n)\n# Analitik çözüm\n# y(t) = y0 + v0*t - (1/2)*g*t^2\n# v(t) = v0 - g*t\nyAnalitik= yVek[0] + yVek[1]*xTum - (1/2)*g*xTum**2\nvAnalitik= yVek[1] - g*xTum\n# Çiz\nfig,axs=plt.subplots(1,2)\n# Soldaki grafik\naxs[0].plot(xTum, yVekTum[0,:], 'o-', color='r', label='Euler $y(t)$')\naxs[0].plot(xTum, yAnalitik, 'k', label='Analitik $y(t)$')\naxs[0].set_ylabel('$y(t)$')\naxs[0].legend()\n# Sağdaki grafik\naxs[1].plot(xTum, yVekTum[1,:], 'o-', color='r', label='Euler $v(t)$')\naxs[1].plot(xTum, vAnalitik, 'k', label='Analitik $v(t)$')\naxs[1].set_ylabel('$v(t)$')\naxs[1].set_xlabel('$t$')\naxs[1].legend()\n# Sıkıştır\nplt.tight_layout()\n# Göster\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-ikinci-dereceden-diferansiyel-denklemler.html#problemler",
    "title": "BDP - İkinci Dereceden Diferansiyel Denklemler",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nBölüm 2 verilen denklemi ilk hızı \\(v(0)=10\\) m/s olarak değiştirerek çözün. Grafikleri karşılaştırın.\n\n\nProblem 2\nYatay düzlemde \\(k=100\\) N/m sabitine sahip \\(m=1\\) kg kütleli yay olsun. Bu cisme denge noktasından \\(x_{0}=0.1\\) m sıkıştırılarak harekete başlatılıyor. Cisim bırakıldığı anda hızı \\(v_{0}=0\\) m/s. Bu cismin hareket denklemini \\(t=0-5\\) aralığında Euler yöntemiyle çözünüz.\n\\[\n-kx=m\\frac{d^{2}x}{dt^{2}}\n\\]\nAnalitik çözüm: \\(x(t) = A\\cos(\\sqrt{k/m}x)+B\\sin(\\sqrt{k/m}x)\\)\n\n\nProblem 3\nBölüm 3.2 bölümündeki soruyu \\(F_{sürtünme}= -bv\\) sürtünme kuvveti varlığında çözünüz. Burada \\(b=1\\) Ns/m sabit ve \\(v\\) cismin hızıdır.\n\\[\n-b\\frac{dx}{dt}-kx=m\\frac{d^{2}x}{dt^{2}}\n\\]\nAnalitik çözüm: \\(x(t) = Ae^{-\\sigma t}e^{i\\omega t}+ Be^{-\\sigma t}e^{-i \\omega t}\\). Burada frekans \\(\\omega = \\sqrt{(k/m)-(b^{2}/4m^{2})}\\) ve genliği belirleyen terim \\(\\sigma=b/2m\\)  [1].\n\n\nProblem 4\nDüşey düzlemde \\(m=1\\) kg kütleli bir cisim salınsın. Bu cisim denge noktasından \\(\\theta_{0}=\\pi/9\\) rad açı ile harekete başlıyor. Cisim bırakıldığı anda açısal hızı \\(\\omega_{0}=\\) rad/s. Bu cismin hareket denklemini \\(t=0-10\\) arasında Euler yöntemiyle çözünüz. En uygun sonuç için \\(n=10000\\) adım alınız. (\\(g=9.81\\))\n\\[\n\\frac{d^{2}\\theta}{dt^{2}}=-\\frac{g}{l}\\sin \\theta\n\\]\nAnalitik çözüm: \\(x(t) = A\\cos(\\sqrt{g/l}x)+B\\sin(\\sqrt{g/l}x)\\)\n\n\nProblem 5\nBölüm 3.4 bölümündeki problemi \\(\\theta_{0}=\\pi/2\\) başlangıç koşulu için tekrar çalıştırınız. \\(\\sin \\theta \\approx \\theta\\) yaklaşıklığı artık geçerli olmadığı için analitik çözümün hatalı olduğunu unutmayınız.\n\n\nProblem 6\nİki cisim problemini (baryosentrik yani merkezdeki cisim hareket etmesin) Euler yöntemiyle (\\(n= 1000, 10000, 100000\\) adımda) çözünüz. Burada \\(\\mu=3.98\\times 10^{5}\\) km \\(^{3}\\)/s \\(^{2}\\), \\(x_{0}=-2500\\) km, \\(y_{0}=-5500\\) km, \\(v_{x0}=7.5\\) km/s, \\(v_{y0}=0.5\\) km/s olarak alın. Aşağıdaki denklemleri \\(t=0-100000\\) s arasında çözün. \\(y-x\\) grafiği çizin. \\((x,y)=(0,0)\\) noktası merkezdeki cismin konumunu göstersin.\n\\[\n\\frac{d^{2}x}{dt^{2}}=-\\frac{\\mu}{(x^{2}+y^{2})^{3/2}}x\n\\]\n\\[\n\\frac{d^{2}y}{dt^{2}}=-\\frac{\\mu}{(x^{2}+y^{2})^{3/2}}y\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - İkinci Dereceden Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html",
    "title": "SDP - Atış Yöntemi",
    "section": "",
    "text": "Aşağıdaki denklemi çözelim.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y(b)=\\beta \\text{.}\n\\]\nBu denklemi başlangıç değer problemine çevirmeye çalışalım.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y'(a)=u \\text{.}\n\\]\nBulmamız gereken değer \\(u\\) değeridir. Bu değeri tahmin edeceğiz. Buradan diferansiyel denklemi tıpkı başlangıç değer problemi gibi \\(a\\)’dan \\(b\\)’ye kadar çözeceğiz. Bulduğumuz çözümün son noktasındaki değerde yani \\(y_{cozum}(b)\\), \\(\\beta\\)’yu bulana kadar bu işleme devam edeceğiz.\nSistematik bir tahmin yürütme mekanizması kurmamız lazım. Bunun için \\(y(b)\\), \\(u\\)’nun bir fonksiyonu olsun tanımlaması yapalım.\n\\[\ny(b)= \\theta(u) \\text{.}\n\\]\nBuradan \\(u\\) değerini bulmak için yukarıda verilen denklemin kökünü bulmamız lazım.\n\\[\n\\theta(u)- \\beta \\equiv r(u) = 0 \\text{.}\n\\]\nBuradaki \\(r(u)\\) fonksiyonuna artık fonksiyon (residual function) denir. Bu fonksiyonun kökü \\(u\\) değeridir. \\(u\\) değerini biliyorsak sınır değer probleminden çevirdiğimiz başlangıç değer problemini çözebiliriz.\nArtık fonksiyonunun kökü \\(u\\) değerini verecek. Kök bulmak için Ridder’in yöntemi kullanabiliriz. (Bisection veya Newton-Raphson yöntemleri değil.)\n\n\n\nİkinci dereceden diferansiyel denklemimiz var. \\(y''=f(x,y(x),y')(x)\\).\nÇözüm kümesinin sınır değerlerini biliyoruz. \\(y(a)=\\alpha\\), \\(y(b)=\\beta\\).\nBizim çözebildiğimiz denklem tipinde başlangıç koşulları \\(y(a)=\\alpha\\) ve \\(y'(a)=u\\) şeklinde olmalı.\n\\(u\\) değerini tahmin edelim.\nTahmin ettiğimiz \\(u\\) değerini kullanarak \\(y''=f(x,y(x),y'(x))\\) denklemini \\(b\\) noktasına kadar çözelim.\nElde ettiğimiz çözümün \\(b\\)’deki değeri \\(y(b)=\\beta\\) değerini veriyor mu? Eğer vermiyorsa \\(u\\) değerini değiştirerek tekrar deneyelim.\n\\(u\\)’nun bu değişimi sanki bir fonksiyon gibi olsun. Yukarıda bahsettiğimiz \\(\\theta(u)\\) fonksiyonu budur.\n\\(\\theta(u)\\) fonksiyonu \\(\\beta\\)’ya eşit olursa \\(u\\) değerini bulduk demektir. Yani \\(\\theta(u)- \\beta = 0\\) denkleminin kökünü bulmaya çalışıyoruz.\n\\(y(b)=\\beta\\) değerine yeteri kadar yaklaştı ise \\(u\\) değerini yani başlangıç koşulunu yani \\(y(x)\\) fonksiyonunu bulduk demektir.\nDenklem çözüldü.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#atış-yöntemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#atış-yöntemi",
    "title": "SDP - Atış Yöntemi",
    "section": "",
    "text": "Aşağıdaki denklemi çözelim.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y(b)=\\beta \\text{.}\n\\]\nBu denklemi başlangıç değer problemine çevirmeye çalışalım.\n\\[\ny'' = f(x,y(x),y'(x)), \\qquad y(a)=\\alpha, \\qquad y'(a)=u \\text{.}\n\\]\nBulmamız gereken değer \\(u\\) değeridir. Bu değeri tahmin edeceğiz. Buradan diferansiyel denklemi tıpkı başlangıç değer problemi gibi \\(a\\)’dan \\(b\\)’ye kadar çözeceğiz. Bulduğumuz çözümün son noktasındaki değerde yani \\(y_{cozum}(b)\\), \\(\\beta\\)’yu bulana kadar bu işleme devam edeceğiz.\nSistematik bir tahmin yürütme mekanizması kurmamız lazım. Bunun için \\(y(b)\\), \\(u\\)’nun bir fonksiyonu olsun tanımlaması yapalım.\n\\[\ny(b)= \\theta(u) \\text{.}\n\\]\nBuradan \\(u\\) değerini bulmak için yukarıda verilen denklemin kökünü bulmamız lazım.\n\\[\n\\theta(u)- \\beta \\equiv r(u) = 0 \\text{.}\n\\]\nBuradaki \\(r(u)\\) fonksiyonuna artık fonksiyon (residual function) denir. Bu fonksiyonun kökü \\(u\\) değeridir. \\(u\\) değerini biliyorsak sınır değer probleminden çevirdiğimiz başlangıç değer problemini çözebiliriz.\nArtık fonksiyonunun kökü \\(u\\) değerini verecek. Kök bulmak için Ridder’in yöntemi kullanabiliriz. (Bisection veya Newton-Raphson yöntemleri değil.)\n\n\n\nİkinci dereceden diferansiyel denklemimiz var. \\(y''=f(x,y(x),y')(x)\\).\nÇözüm kümesinin sınır değerlerini biliyoruz. \\(y(a)=\\alpha\\), \\(y(b)=\\beta\\).\nBizim çözebildiğimiz denklem tipinde başlangıç koşulları \\(y(a)=\\alpha\\) ve \\(y'(a)=u\\) şeklinde olmalı.\n\\(u\\) değerini tahmin edelim.\nTahmin ettiğimiz \\(u\\) değerini kullanarak \\(y''=f(x,y(x),y'(x))\\) denklemini \\(b\\) noktasına kadar çözelim.\nElde ettiğimiz çözümün \\(b\\)’deki değeri \\(y(b)=\\beta\\) değerini veriyor mu? Eğer vermiyorsa \\(u\\) değerini değiştirerek tekrar deneyelim.\n\\(u\\)’nun bu değişimi sanki bir fonksiyon gibi olsun. Yukarıda bahsettiğimiz \\(\\theta(u)\\) fonksiyonu budur.\n\\(\\theta(u)\\) fonksiyonu \\(\\beta\\)’ya eşit olursa \\(u\\) değerini bulduk demektir. Yani \\(\\theta(u)- \\beta = 0\\) denkleminin kökünü bulmaya çalışıyoruz.\n\\(y(b)=\\beta\\) değerine yeteri kadar yaklaştı ise \\(u\\) değerini yani başlangıç koşulunu yani \\(y(x)\\) fonksiyonunu bulduk demektir.\nDenklem çözüldü.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#alıştırma-1",
    "title": "SDP - Atış Yöntemi",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nAşağıda verilen difarensiyel denklemi atış yöntemi ile çözelim. \\[\ny''(t) = -g, \\qquad y(0)=0, \\qquad y(5)=50 \\text{.}\n\\]\n\nÇözüm\nÇözüm adımlarından dördüncü olan ile başlayalım. \\(u\\) değerini tahmin edelim. \\(u=25\\) olsun. Bu değerle denklemi çözelim. Çözeceğimiz denklem aşağıdaki gibi olacak.\n\\[\ny''(t) = -g, \\qquad y(0)=0, \\qquad y'(5)=25 \\text{.}\n\\]\nBu denklemin çözümü\n\\[\n\\begin{align*}\n    y'(t)&= -gt + C_{1} \\text{,} \\qquad y'(5)=25 \\text{ ,} \\\\\n         &= -gt + 25 \\text{ ,} \\\\\n     y(x)&= -\\frac{gt^2}{2} + 25t + C_{2} \\text{,} \\qquad y(0)=0 \\text{,} \\\\\n         &= -\\frac{gt^2}{2} + 25t \\text{.}\n\\end{align*}\n\\]\nŞimdi tahminimiz doğru mu deneyelim. Yani \\(y(t=5)\\) değeri \\(50\\) mi olacak?\n\\[\ny(t=5)= -\\frac{10\\times 25}{2} + 25\\times 5 = 0 \\ne 50 \\text{.}\n\\]\nYanlış! Farklı bir \\(u\\) değeri almamız gerekecek. Aynı işlemi \\(u=40\\) ile tekrarlayalım. Sonuç:\n\\[\ny(t)=-\\frac{gt^2}{2} + 40t\n\\]\nOlacak denersek eğer \\(y(5)=75\\) olacak ve yanlış olacak.\nTeker teker denemek yerine \\(u\\) değeri sanki bir fonksiyonmuş gibi davranalım.\n\\[\n\\theta(u) - 50 = 0\\text{.}\n\\]\nO halde \\(\\theta(u)\\) fonksiyonu başlangıç değer probleminin çözümüne bağlı. Bunu bir fonksiyon gibi tanımlayıp kökünü bulalım. Bu fonksiyon kodda şöyle tanımlanacak. u değeri girdi olacak. Bu u değerine göre başlangıç değer problemini çözecek. Çözümün son değeri \\(y(5)\\) değeri olacak. Bu değer ile \\(50\\) değeri arasındaki farkı döndürecek. Bu farkın kökünü bulmak için scipy.optimize.ridder(fonksiyon, kok_araligi_baslangic, kok_araligi_bitis) fonksiyonunu kullanacağız.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.integrate as scInteg\nimport scipy.optimize as scOpt\n# Diff. Denk:\n# y'' = -10 , y(0)=0 , y(5)=50\n# Fonksiyon:\ndef fonk_SDP(t, y):\n    # y[0]= y\n    # y[1]= v\n    return np.array([y[1], -10])\n# Başlangıç Koşulları\nt0=0.0\ntSon=5.0\ny0= 0.0  # y(0) = 0\nySon= 50. # y(5) = 50\n# v(0) = u (Bilmiyoruz)\n# Theta fonksiyonu:\ndef thetaFonk(u):\n    #solve_ivp(fonksiyon, t_span, y0)\n    # t_span=[t0, tStop] (y(0) ve y(1) değerini biliyoruz.)\n    cozum = scInteg.solve_ivp(fonk_SDP, [t0, tSon], [y0, u])\n    \n    # İkinci derece diferansiyel denklemin çözümü\n    # cozum.y[0] = y(t)\n    # cozum.y[1] = v(t)\n    yCozum = cozum.y[0]\n    # yCozum bir array. Son elemanı yani y(t=5) değeri bizim için önemli.\n    # Bu da yCozum[-1] ile alınır.\n    # Eğer bulduğumuz yCozum[-1] değeri ySon değerine eşitse u değerini bulduk demektir.\n    return yCozum[-1]- ySon\n# ---------------------------\n# Theta fonksiyonunun içerini şöyle düşünelim.\n# Polinom tipi bir g(x)=x^2+4x+4 fonksiyonu olsun. Bunun kökünü şöyle bulurduk.\n'''\ndef g(x):\n    return x**2 + 4*x + 4\n\n# Kökünü 0 ile 10 arasında bul.\nx0, = scOpt.ridder(g, 0, 10)\n'''\n# ---------------------------\n# theta fonksiyonunun kökünü bulalım.\nthetaU_kok_v0= scOpt.ridder(thetaFonk, 0, 50)\n# Olması gereken başlangıç değeri:\nprint(f\"v0= {thetaU_kok_v0} m/s\")\n# Deneyelim. Gerçekten v0 bu değerdeyken y(5)= 50 oluyor mu?\ncozum= scInteg.solve_ivp(fonk_SDP, [t0, tSon], [y0, thetaU_kok_v0])\n# Son değerleri karşılaştıralım.\nprint(f\"y(t=5) Bulduğumuz Çözüm: {cozum.y[0][-1]:.1f} m\")\nprint(f\"y(t=5) Gerçek Değer    : {ySon} m\")\n\nv0= 35.000000000001016 m/s\ny(t=5) Bulduğumuz Çözüm: 50.0 m\ny(t=5) Gerçek Değer    : 50.0 m\n\n\nPython ile ne yaptık?\n\nSanki başlangıç değer problemi çözer gibi fonksiyon tanımladık.\nBaşlangıç koşullarını tanımladık. İkinci başlangıç değeri yani \\(y(b)\\) değerini tanımlamadık.\nAyrı bir fonksiyon ile başlangıç değer problemini çözdük. Bu fonksiyonun girdi değeri u, dönüş dğeri ise verilen \\(y(b)\\) değeri ile çözümün son değerinin farkıdır.\nBaşlangıç değer çözücü denklemi scipy.optimize.ridder(fonksiyon, kok_araligi_baslangic, kok_araligi_bitis) ile çözdük.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#problemler",
    "title": "SDP - Atış Yöntemi",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAşağıdaki denklemi atış yöntemi ile çözün.\n\\[\ny''(t)=t, \\quad y(0)=1, \\quad y(3)=9\n\\]\n\nElde ettiğiniz çözümü yani \\(y(t)\\) fonksiyonunu çizdirin.\nBu denklemi analitik olarak çözün ve çözümü de çizdirin.\n\n\n\nProblem 2\nAşağıdaki diferansiyel denklemi atış yöntemini kullanarak çözün. Adım aralığını \\(h=0.05\\) alın. Analitik sonuçla karşılaştırın.\n\\[\ny''(t) = t^{3}+t+5, \\quad y(0)=1, \\quad y(6)=548.8\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#kaynaklar",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-atis-yontemi.html#kaynaklar",
    "title": "SDP - Atış Yöntemi",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nNumerical Methods in Engineering with Python 3, Jaan Kiusalaas, Cambridge University Press, 2013, Syf:293\nPython Programming and Numerical Methods: A Guide for Engineers and Scientists, Qingkai Kong & Timmy Siauw & Alexandre Bayen, 2020, chapter23.02-The-Shooting-Method",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Atış Yöntemi"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html",
    "title": "BDP - Denklem Sistemleri",
    "section": "",
    "text": "Adi diferansiyel denklem sistemlerini çözmek için Euler yöntemini vektör haline getirip kullanabiliriz. Bunun için bilYonMod.py modülündende tanımlanan add_coz_euler_sistem(fonk_yVek_x, xBaslangic, xBitis, yBaslangic_vek, adimSayisi) fonksiyonunu kullanılmalıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_euler_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#bdp---denklem-sistemleri",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#bdp---denklem-sistemleri",
    "title": "BDP - Denklem Sistemleri",
    "section": "",
    "text": "Adi diferansiyel denklem sistemlerini çözmek için Euler yöntemini vektör haline getirip kullanabiliriz. Bunun için bilYonMod.py modülündende tanımlanan add_coz_euler_sistem(fonk_yVek_x, xBaslangic, xBitis, yBaslangic_vek, adimSayisi) fonksiyonunu kullanılmalıdır.\n\n\n\n\n\n\nNot\n\n\n\nadd_coz_euler_sistem fonksiyonunu inceleyiniz.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#euler-yönteminin-denklem-sistemleri-için-uygulanması",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#euler-yönteminin-denklem-sistemleri-için-uygulanması",
    "title": "BDP - Denklem Sistemleri",
    "section": "Euler Yönteminin Denklem Sistemleri İçin Uygulanması",
    "text": "Euler Yönteminin Denklem Sistemleri İçin Uygulanması\nÖrneğin aşağıdaki denklem sistemini ele alalım. Denklem sisteminde iki adet birbirinden bağımsız diferansiyel denklem olsun. Bu denklemleri, bilgisayar açısından daha ekonomik olması adına birlikte çözülmelidir. (Az döngü, vektörleştirme, paralelleştirme, …)\n\\[\n\\begin{align*}\n    \\frac{d}{dx}y(x) &= x \\\\\n    \\frac{d}{dx}v(x) &= x^{2}\n\\end{align*}\n\\]\nDenklem sistemi vektör haline getirilirse aşağıdaki gibi olur.\n\\[\n\\begin{align*}\n    \\vec{y}'(x) &= \\begin{bmatrix} y'(x,v) \\\\ v'(x,y) \\end{bmatrix} = \\begin{bmatrix} x \\\\ x^{2} \\end{bmatrix}\n\\end{align*}\n\\]\nBaşlangıç koşulları \\(y(0)=1\\) ve \\(v(0)=1\\) olsun. Çözüm aralığını \\(x=0\\) ile \\(x=10\\) arasında bulmaya çalışalım, \\(x=[0,10]\\). Çözüm adım sayısı \\(n=100\\) olsun.\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_yVek_x(yVek, x):\n    y = yVek[0]\n    v = yVek[1]\n    dydx = x\n    dvdx = x**2\n    return np.array([dydx, dvdx])\n# Başlangıç koşulları\ny0 = 1\nv0 = 1\nx0 = 0\nxSon = 10\nn = 100\n# Çöz\n# xTum, yTum_Vek= add_coz_euler_sistem(fonk_yVek_x, xBaslangic, xBitis, yBaslangic_vek, adimSayisi)\n# yTum_Vek[0] =&gt; y(x)\n# yTum_Vek[1] =&gt; v(x)\nxTum, yTum_Vek = bym.add_coz_euler_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Analitik çözüm\nyAnalitik = xTum**2/2 + 1\nvAnalitik = xTum**3/3 + 1\n# Çiz\nplt.plot(xTum, yTum_Vek[0], 'o-', color='red', label='y(x)')\nplt.plot(xTum, yAnalitik, label='y(x) analitik', color='black', linestyle='--')\nplt.plot(xTum, yTum_Vek[1], 'o-',label='v(x)', color='blue')\nplt.plot(xTum, vAnalitik, label='v(x) analitik', color='cyan', linestyle='--')\nplt.xlabel('x')\nplt.ylabel('y(x), v(x)')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#alıştırma-1",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#alıştırma-1",
    "title": "BDP - Denklem Sistemleri",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBirbirine bağlı iki adet diferansiyel denklemi çözmek için Euler yöntemini kullanınız.\nDenklem sistemi aşağıdaki gibidir.\n\\[\n\\begin{align*}\n\\frac{d}{dx}y(v,x) &= v(x) \\\\\n\\frac{d}{dx}v(x) &= x\n\\end{align*}\n\\]\nDenklem sistemi vektör haline getirilirse:\n\\[\n\\begin{align*}\n\\vec{y}'(x) &= \\begin{bmatrix} y'(v,x) \\\\ v'(x) \\end{bmatrix} = \\begin{bmatrix} v(x) \\\\ x \\end{bmatrix}\n\\end{align*}\n\\]\nBu durumda sağ taraftaki vektör fonksiyonu aşağıdaki gibi tanımlanır.\n\ndef fonk_yVek_x(yVek, x):\n    # İlk çözülmesi gereken denklem y'(v,x) = v(x). \n    # fonk_yVek_x fonksiyonu girdi olarak (yVek,x) alacak. Bu yVek vektörünün\n    # ilk elemanı y'(x) 'in sağ tarafı olmalı. dydx diyelim.\n    # dydx &lt;= yVek[0]\n    dydx = yVek[1]\n    # İkinci çözülmesi gereken denklem v'(y,x) = x.\n    # fonk_yVek_x fonksiyonu girdi olarak (yVek,x) alacak. Bu yVek vektörünün\n    # ikinci elemanı v'(x) 'in sağ tarafı olmalı. dvdx diyelim.\n    # dvdx &lt;= yVek[1] \n    # dvdx = x\n    # Sonuç olarak da [dydx, dvdx] vektörünü döndürmeli.\n    return np.array([dydx, x])\n\nBaşlangıç koşulları \\(y(0)=1\\) ve \\(v(0)=0\\) olsun. Çözüm aralığı \\(x=0\\) ile \\(x=10\\) arasında olsun. Çözüm adım sayısı \\(n=100\\) olsun.\nAnalitik çözümü elde ederken önce \\(v(x)\\)’i çözmek gerekir. \\(v(x)=\\frac{x^2}{2}\\) olur. Bu durumda \\(y(x)=\\frac{x^3}{6}+1\\) olur.\n\nÇözüm\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Fonksiyon\ndef fonk_yVek_x(yVek, x):\n    dydx = yVek[1]\n    return np.array([dydx, x])\n# Başlangıç koşulları\ny0 = 1\nv0 = 0\nx0 = 0\nxSon = 10\nn = 100\n# Çöz\nxTum, yTum_Vek = bym.add_coz_euler_sistem(fonk_yVek_x, x0, xSon, np.array([y0, v0]), n)\n# Analitik çözüm\nyAnalitik = xTum**3/6 + 1\nvAnalitik = xTum**2/2\n# Çiz\nfig, ax = plt.subplots(1, 2)\n# Sol grafik\nax[0].plot(xTum, yTum_Vek[0], 'o-', label='y(x)', color='red')\nax[0].plot(xTum, yAnalitik, label='y(x) analitik', color='black', linestyle='--')\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\nax[0].legend()\n# Sağ grafik\nax[1].plot(xTum, yTum_Vek[1], 'o-', label='v(x)', color='blue')\nax[1].plot(xTum, vAnalitik, label='v(x) analitik', color='cyan', linestyle='--')\nax[1].set_xlabel('x')\nax[1].set_ylabel('v(x)')\nax[1].legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#problemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler/bdp-denklem-sistemleri.html#problemler",
    "title": "BDP - Denklem Sistemleri",
    "section": "Problemler",
    "text": "Problemler\n\nProblemi 1\nLorenz atraktörünün denklemini Euler yöntemiyle çözünüz. Sabitler için \\(\\rho=28\\), \\(\\sigma=10\\) ve \\(\\beta=8/3\\) alınız. Başlangıç koşullarını: \\(x_{0}=1\\), \\(y_{0}=1\\) ve \\(z_{0}=1\\) olarak alınız. En iyi sonucu görebilmek için \\(t=0-10\\) aralığında ve \\(n= 1000\\) adımda yapınız. 3 boyutlu grafik çizilirse ünlü şekil ortaya çıkacaktır.\n\\[\n\\frac{dx}{dt}=\\sigma(y-x)\n\\]\n\\[\n\\frac{dy}{dt}=x(\\rho-z)-y\n\\]\n\\[\n\\frac{dz}{dt}=xy-\\beta z\n\\]\n\n\nProblem 2\nLotka-Volterra Modelini Euler yöntemiyle çözünüz. Sabitler için \\(a=1.5\\), \\(b=1\\), \\(c=3\\) ve \\(d=1\\) alınız. Başlangıç koşulu olarak 10 tavşan (\\(x_{0}\\)) ve 5 vaşak (\\(y_{0}\\)) alınız. En iyi sonucu görebilmek için \\(t=0-20\\) aralığında ve \\(n= 1000\\) adımda yapınız. Bu model av-avcı popülasyonunu veya tavşan-vaşak popülasyonu simülasyonudur.\n\\[\n\\frac{dx}{dt}=ax-bxy\n\\]\n\\[\n\\frac{dy}{dt}=-cy+dxy\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "BDP - Denklem Sistemleri"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html",
    "title": "SDP - Giriş",
    "section": "",
    "text": "Farz edelim ki aşağıdaki gibi ikinci dereceden diferansiyel denklemimiz olsun.\n\\[\ny''(x) = f(x,y(x),y'(x))\n\\]\nBu denklemdeki \\(y(x)\\) ve \\(y'(x)\\) fonksiyonunun aynı \\(x\\) (ör. \\(x=0\\)) noktasındaki değerini biliyorsak bu denklem başlangıç değer problemidir. Bu denklemin \\(y(x=a)\\) ve \\(y(x=b)\\) noktalarındaki değerlerini biliyorsak bu denklem kabaca sınır değer problemidir. Yukarıda verdiğimiz örneğe iki-noktalı sınır değer problemi de denir (2-point boundary value problem). Birinci dereceden diferansiyel denklem için sınır değer problemi ile başlangıç değer problemi aynıdır, çünkü denklem bir adet koşula sahiptir.\nÖrneğin Kuyudaki bir parçacığın kuantum mekaniksel hareket denklemi aşağıdaki gibi yazılır.\n\\[\n\\frac{-h}{4\\pi m}\\frac{d^{2}}{dx^{2}}\\psi(x) = E\\psi(x), \\qquad \\psi(x=-L/2)=0, \\qquad \\psi(x=L/2)=0 \\text{.}\n\\]\nBirinci türeve ait bir koşul bilmiyoruz. Sadece bulmak istediğimiz fonksiyonun sınır değerlerini biliyoruz.\n\n\n\n\n\n\nUyarı\n\n\n\nBaşlangıç değer probleminde n. dereceden diferansiyel denklemi çözebilmek için n adet başlangıç koşuluna ihtiyaç vardır. Bu başlangıç koşulları da (n-1). dereceden türeve kadar olmak zorundadır.\n\n\nSınır değer problemlerini çözmek için birinci türeve ait olan denklemdeki başlangıç koşuluna ihtiyaç vardır. Bu sorunu:\n\nBaşlangıç koşulunu  tahmin ederek  aşabiliriz. Bu yönteme atış yöntemi (shooting method) denir.\nDiferansiyel denklemi  örgü noktalarına  (mesh points) bölerek çözebiliriz. Bu yönteme sonlu farklar yöntemi (finite difference method) denir.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html#sınır-değer-problemi",
    "href": "icerik/konular/adi-diferansiyel-denklemler/sdp-giris.html#sınır-değer-problemi",
    "title": "SDP - Giriş",
    "section": "",
    "text": "Farz edelim ki aşağıdaki gibi ikinci dereceden diferansiyel denklemimiz olsun.\n\\[\ny''(x) = f(x,y(x),y'(x))\n\\]\nBu denklemdeki \\(y(x)\\) ve \\(y'(x)\\) fonksiyonunun aynı \\(x\\) (ör. \\(x=0\\)) noktasındaki değerini biliyorsak bu denklem başlangıç değer problemidir. Bu denklemin \\(y(x=a)\\) ve \\(y(x=b)\\) noktalarındaki değerlerini biliyorsak bu denklem kabaca sınır değer problemidir. Yukarıda verdiğimiz örneğe iki-noktalı sınır değer problemi de denir (2-point boundary value problem). Birinci dereceden diferansiyel denklem için sınır değer problemi ile başlangıç değer problemi aynıdır, çünkü denklem bir adet koşula sahiptir.\nÖrneğin Kuyudaki bir parçacığın kuantum mekaniksel hareket denklemi aşağıdaki gibi yazılır.\n\\[\n\\frac{-h}{4\\pi m}\\frac{d^{2}}{dx^{2}}\\psi(x) = E\\psi(x), \\qquad \\psi(x=-L/2)=0, \\qquad \\psi(x=L/2)=0 \\text{.}\n\\]\nBirinci türeve ait bir koşul bilmiyoruz. Sadece bulmak istediğimiz fonksiyonun sınır değerlerini biliyoruz.\n\n\n\n\n\n\nUyarı\n\n\n\nBaşlangıç değer probleminde n. dereceden diferansiyel denklemi çözebilmek için n adet başlangıç koşuluna ihtiyaç vardır. Bu başlangıç koşulları da (n-1). dereceden türeve kadar olmak zorundadır.\n\n\nSınır değer problemlerini çözmek için birinci türeve ait olan denklemdeki başlangıç koşuluna ihtiyaç vardır. Bu sorunu:\n\nBaşlangıç koşulunu  tahmin ederek  aşabiliriz. Bu yönteme atış yöntemi (shooting method) denir.\nDiferansiyel denklemi  örgü noktalarına  (mesh points) bölerek çözebiliriz. Bu yönteme sonlu farklar yöntemi (finite difference method) denir.",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler",
      "SDP - Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler.html",
    "href": "icerik/konular/adi-diferansiyel-denklemler.html",
    "title": "Adi Diferansiyel Denklemler",
    "section": "",
    "text": "Aşağıdaki gibi bir adet diferansiyel denklem veya denklem sistemimiz olsun.\n\\[\n\\begin{equation}\n    \\frac{d}{dx}y(x) = F(x,y)\n\\end{equation}\n\\]\n\nBu denklemi çözmek demek sağ ve sol tarafın integralini almak demektir.\nBu denklemi çözmek demek sayısal olarak \\(y(x)\\) fonksiyonunu bulmak demektir. Yani istenilen bir x değeri için \\(y(x)\\) fonksiyonunun değerini elde ederiz.\n\\(y(x)\\) ve \\(F(x,y)\\) birer vektör olabilir. Örneğin \\(\\vec{y}(x) = (y_{1}(x), y_{2}(x))\\).\nİkinci dereceden diferansiyel denklemleri çözmek için denklemi iki adet birinci dereceden diferansiyel denkleme indirgeme yapmamız gerekmektedir.\n\n\\[\n\\begin{align*}\n    \\frac{d^{2}}{dx^{2}}y(x) =& F(x,y)\\\\\n    \\frac{d}{dx}y(x) =& v(x,y) \\qquad \\text{ve} \\qquad \\frac{d}{dx}v(x) = F(x,y)\n\\end{align*}\n\\]\n\nÇözüme başlamak için fonksiyonun başlangıçtaki değerine ihtiyacınız vardır; Başlangıç Değer Problemi, BDP (IVP)\nÇözümün sınırlarında hangi değerler aldığını bilerek de fonksiyonu elde edebiliriz; Sınır Değer Problemi, SDP (BVP)\n\n\n\n\nBaşlangıç değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(0)=0 \\text{.}\n\\]\n\nSınır değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(\\pi)=0 \\text{.}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/adi-diferansiyel-denklemler.html#adi-diferansiyel-denklemler",
    "href": "icerik/konular/adi-diferansiyel-denklemler.html#adi-diferansiyel-denklemler",
    "title": "Adi Diferansiyel Denklemler",
    "section": "",
    "text": "Aşağıdaki gibi bir adet diferansiyel denklem veya denklem sistemimiz olsun.\n\\[\n\\begin{equation}\n    \\frac{d}{dx}y(x) = F(x,y)\n\\end{equation}\n\\]\n\nBu denklemi çözmek demek sağ ve sol tarafın integralini almak demektir.\nBu denklemi çözmek demek sayısal olarak \\(y(x)\\) fonksiyonunu bulmak demektir. Yani istenilen bir x değeri için \\(y(x)\\) fonksiyonunun değerini elde ederiz.\n\\(y(x)\\) ve \\(F(x,y)\\) birer vektör olabilir. Örneğin \\(\\vec{y}(x) = (y_{1}(x), y_{2}(x))\\).\nİkinci dereceden diferansiyel denklemleri çözmek için denklemi iki adet birinci dereceden diferansiyel denkleme indirgeme yapmamız gerekmektedir.\n\n\\[\n\\begin{align*}\n    \\frac{d^{2}}{dx^{2}}y(x) =& F(x,y)\\\\\n    \\frac{d}{dx}y(x) =& v(x,y) \\qquad \\text{ve} \\qquad \\frac{d}{dx}v(x) = F(x,y)\n\\end{align*}\n\\]\n\nÇözüme başlamak için fonksiyonun başlangıçtaki değerine ihtiyacınız vardır; Başlangıç Değer Problemi, BDP (IVP)\nÇözümün sınırlarında hangi değerler aldığını bilerek de fonksiyonu elde edebiliriz; Sınır Değer Problemi, SDP (BVP)\n\n\n\n\nBaşlangıç değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(0)=0 \\text{.}\n\\]\n\nSınır değer problemi:\n\n\\[\ny''(x)= -y, \\qquad y(0)=1, \\qquad y'(\\pi)=0 \\text{.}\n\\]",
    "crumbs": [
      "**Konular**",
      "Adi Diferansiyel Denklemler"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "",
    "text": "Basit bir dalgada periyot/frekans, genlik faz gibi kavramları anladık. Peki daha üst üste binen dalgaları nasıl analiz edeceğiz? Örneğin aşağıdaki gibi bir dalgayı analiz etmek istediğimizi düşünelim.\n\\[\ny(t) = \\sin(\\omega t + \\phi) + \\cos(2 \\omega t + \\phi)\n\\]\nÇizdirelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nt= np.arange(0, 4*np.pi, 0.01)\n# Dalganın acısal frekansı\nomega= 2* np.pi* 0.2\n# Çiz\nplt.plot(t, np.cos(omega*t)+ np.sin(2*omega*t), \n    'b', label= '$\\sin(0.4\\omega t)+ \\cos(0.4\\omega t)$')\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi,\n    5*np.pi/2, 3*np.pi, 7*np.pi/2, 4*np.pi],\n    [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\",\n     \"5$\\pi$/2\", \"3$\\pi$\", \"7$\\pi$/2\", \"4$\\pi$\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nBu şekildeki dalganın frekansı nedir sorusunu cevaplayamayız. Benzer şekilde üst üste binen dalgaların genlik bilgileri de açıkça gözükmemektedir.\nBuna benzer dalgaları analiz etmek için Fourier dönüşümü kullanılır. Fourier dönüşümü, bir dalgayı frekans bileşenlerine ayırır. Kesikli (bizim inceleyeceğimiz durum) ve sürekli olmak üzere iki farklı şekilde yapabiliriz.\nElimizde bir dalgayı temsil eden veri seti olsun. Bu veri setinin elemanlarına \\(N\\) adet örnek sayısı olup \\(x_{n}\\) değerlerinde bulunsunlar. Kesikli Fourier dönüşümünün formülü aşağıdaki gibidir. Her noktayı (örneklemi - sample) bir frekans bileşenine, \\(k\\), dönüştürür.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\[\nX_{k}= \\sum_{n=0}^{N-1} x_{n} \\left[ \\cos \\left( \\frac{2 \\pi k n}{N} \\right) - i \\sin \\left( \\frac{2 \\pi k n}{N} \\right) \\right]\n\\]\nBurada\n\nN: Örnek sayısı\nn: Örneklem numarası\nk: Frekans numarası (0, 1, 2, …, N-1)\n\\(x_{n}\\): n. örneğin değeri\n\\(X_{k}\\): KFD değeri (genlik ve faz değeri içerir.)\n\n\n\n\n\n\n\nNot\n\n\n\nPython’da ilk indeks değeri 0 olduğu için formül 0’dan başladı ve \\(N-1\\)’e kadar gitti.\n\n\nFormül bize kabaca şunu söylemektedir. Eğer \\(N\\) adet örnek sayımız varsa, bunu \\(N\\) adet frekansa sahip dalgaların toplamı şeklinde düşünebiliriz. \\(k\\) frekansına sahip olan dalganın değeri \\(X_{k}\\), faz değeri ise \\(\\phi_{k}\\) olacaktır.\nAşağıdaki şekilde birbirinden farklı genliğe ve frekansa sahip 3 dalganın üst üste binmesi ile açığa çıkan şekli görebilirsiniz  [1].",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfd---kesikli-fourier-dönüşümü-ddt---discrete-fourier-transform",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfd---kesikli-fourier-dönüşümü-ddt---discrete-fourier-transform",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "",
    "text": "Basit bir dalgada periyot/frekans, genlik faz gibi kavramları anladık. Peki daha üst üste binen dalgaları nasıl analiz edeceğiz? Örneğin aşağıdaki gibi bir dalgayı analiz etmek istediğimizi düşünelim.\n\\[\ny(t) = \\sin(\\omega t + \\phi) + \\cos(2 \\omega t + \\phi)\n\\]\nÇizdirelim.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nt= np.arange(0, 4*np.pi, 0.01)\n# Dalganın acısal frekansı\nomega= 2* np.pi* 0.2\n# Çiz\nplt.plot(t, np.cos(omega*t)+ np.sin(2*omega*t), \n    'b', label= '$\\sin(0.4\\omega t)+ \\cos(0.4\\omega t)$')\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi,\n    5*np.pi/2, 3*np.pi, 7*np.pi/2, 4*np.pi],\n    [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\",\n     \"5$\\pi$/2\", \"3$\\pi$\", \"7$\\pi$/2\", \"4$\\pi$\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nBu şekildeki dalganın frekansı nedir sorusunu cevaplayamayız. Benzer şekilde üst üste binen dalgaların genlik bilgileri de açıkça gözükmemektedir.\nBuna benzer dalgaları analiz etmek için Fourier dönüşümü kullanılır. Fourier dönüşümü, bir dalgayı frekans bileşenlerine ayırır. Kesikli (bizim inceleyeceğimiz durum) ve sürekli olmak üzere iki farklı şekilde yapabiliriz.\nElimizde bir dalgayı temsil eden veri seti olsun. Bu veri setinin elemanlarına \\(N\\) adet örnek sayısı olup \\(x_{n}\\) değerlerinde bulunsunlar. Kesikli Fourier dönüşümünün formülü aşağıdaki gibidir. Her noktayı (örneklemi - sample) bir frekans bileşenine, \\(k\\), dönüştürür.\n\\[\nX_{k} = \\sum_{n=0}^{N-1} x_{n} e^{-i 2 \\pi k n / N}\n\\]\n\\[\nX_{k}= \\sum_{n=0}^{N-1} x_{n} \\left[ \\cos \\left( \\frac{2 \\pi k n}{N} \\right) - i \\sin \\left( \\frac{2 \\pi k n}{N} \\right) \\right]\n\\]\nBurada\n\nN: Örnek sayısı\nn: Örneklem numarası\nk: Frekans numarası (0, 1, 2, …, N-1)\n\\(x_{n}\\): n. örneğin değeri\n\\(X_{k}\\): KFD değeri (genlik ve faz değeri içerir.)\n\n\n\n\n\n\n\nNot\n\n\n\nPython’da ilk indeks değeri 0 olduğu için formül 0’dan başladı ve \\(N-1\\)’e kadar gitti.\n\n\nFormül bize kabaca şunu söylemektedir. Eğer \\(N\\) adet örnek sayımız varsa, bunu \\(N\\) adet frekansa sahip dalgaların toplamı şeklinde düşünebiliriz. \\(k\\) frekansına sahip olan dalganın değeri \\(X_{k}\\), faz değeri ise \\(\\phi_{k}\\) olacaktır.\nAşağıdaki şekilde birbirinden farklı genliğe ve frekansa sahip 3 dalganın üst üste binmesi ile açığa çıkan şekli görebilirsiniz  [1].",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#örnek-elle",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#örnek-elle",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Örnek (Elle)",
    "text": "Örnek (Elle)\nElimizde 3 adet örnekleme sahip (3 nokta) bir dalga olsun. Yani sinüs dalgasını 3 adet nokta ile temsil edelim. Bu noktalardan oluşan dalganın frekans bileşenlerini bulmak için Fourier dönüşümünü adım adım yapalım.\n\\[\nX_{k} = \\sum_{n=0}^{3} x_{n} e^{-i 2 \\pi k n / 3}\n\\]\n\\[\n\\begin{align*}\n    X_{0}=& x_{0} e^{-i (2 \\pi 0\\times0) / 3} + x_{1} e^{-i (2 \\pi 0\\times1) / 3} + x_{2} e^{-i (2 \\pi 0\\times2) / 3}\\\\\n    =& x_{0} e^{0} + x_{1} e^{0} + x_{2} e^{0}\\\\\n    =& x_{0} + x_{1} + x_{2}\\\\\n    X_{1}= & x_{0} e^{-i (2 \\pi 1\\times0) / 3} + x_{1} e^{-i (2 \\pi 1\\times1) / 3} + x_{2} e^{-i (2 \\pi 1\\times2) / 3}\\\\\n    =& x_{0} e^{0} + x_{1} e^{-i 2 \\pi / 3} + x_{2} e^{-i 4 \\pi / 3}\\\\\n    =& x_{0} + x_{1} (\\cos(2 \\pi / 3) - i \\sin(2 \\pi / 3)) + x_{2} (\\cos(4 \\pi / 3) - i \\sin(4 \\pi / 3))\\\\\n    =& x_{0} + x_{1} (-0.5 - i 0.9) + x_{2} (-0.5 + i 0.9)\\\\\n    X_{2}= & x_{0} e^{-i (2 \\pi 2\\times0) / 3} + x_{1} e^{-i (2 \\pi 2\\times1) / 3} + x_{2} e^{-i (2 \\pi 2\\times2) / 3}\\\\\n    =& x_{0} + x_{1} e^{-i 4 \\pi / 3} + x_{2} e^{-i 8 \\pi / 3}\\\\\n    =& x_{0} + x_{1} (\\cos(4 \\pi / 3) - i \\sin(4 \\pi / 3)) + x_{2} (\\cos(8 \\pi / 3) - i \\sin(8 \\pi / 3))\\\\\n    =& x_{0} + x_{1} (-0.5 + i 0.9) + x_{2} (-0.5 - i 0.9)\n\\end{align*}\n\\]\nYukarıdaki denklemde \\(x_{0}=1\\), \\(x_{1}=2\\), \\(x_{2}=3\\) olarak alırsak \\(X_{0}=6\\), \\(X_{1}=-1.5 - i 0.9\\), \\(X_{2}=-1.5 + i 0.9\\) değerlerini buluruz. ::: {.callout-important} 1. Her zaman 0. değer \\(X_{0}= \\sum_{n=0}^{N-1} x_{n}\\) şeklinde olacaktır. 2. \\(X_{n}\\) karmaşık bir sayıdır. :::\nBir dalganın frekanslarını belirlemek için Fourier dönüşümü kullanacağımızı söylemiştik ancak elde ettiğimiz frekanslar \\(X_{k}\\) karmaşık sayı olarak karşımıza çıktı. Gerçel (reel) frekans değerleri için \\(X_{k}\\) değerlerinin modülünü, \\(|X_{k}|\\), alacağız.\nSinyalin genliği \\(A_{k}\\) ve fazı \\(\\phi_{k}\\) ise aşağıdaki şekilde hesaplanır.\n\\[\nA_{k} = \\frac{|X_{k}|}{N}\n\\]\n\\[\n\\phi_{k} = \\arctan \\left( \\frac{Im(X_{k})}{Re(X_{k})} \\right)\n\\]\n\n\n\n\n\n\nUyarı\n\n\n\n\nEğer tek sayıda örnek varsa, yani \\(N\\) tek ise, k tane \\(X\\) değerlerinin 0’dan \\((N-1)/2\\) kadar olanlar pozitif frekanslı \\((N+1)/2\\)’den \\(N-1\\) kadar olanlar negatif frekanslı olarak tanımlanır.\nEğer çift sayıda örnek varsa, yani \\(N\\) çift ise, k tane \\(X\\) değerlerinin 0’dan \\((N/2)-1\\) kadar olanlar pozitif frekanslı \\((N/2)\\)’den \\(N-1\\) kadar olanlar negatif frekanslı olarak tanımlanır.\n\\(X_{k}\\) değerlerini hesaplarken modülünü aldığımızdan dolayı negatif frekanslı değerlerin modülü pozitif frekanslı değerlerin modülüne eşittir. Bu yüzden \\(X_{k}\\) değerlerini hesaplarken sadece pozitif frekanslı değerleri hesaplamak yeterlidir.\n\n\n\nYukarıdaki gibi örnek oranının yarısına Nyquist frekansı denir. Yani \\(N-1\\) üzerinden toplam almak yerine \\(N/2\\) üzerinden toplam alırsak Nyquist frekansına ulaşırız. Dalgaların frekanslarını bulurken bu konu daha ayrıntılı açıklanacaktır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tkfd---ters-kesikli-fourier-dönüşümü-idft---inverse-discrete-fourier-transform",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tkfd---ters-kesikli-fourier-dönüşümü-idft---inverse-discrete-fourier-transform",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "TKFD - Ters Kesikli Fourier Dönüşümü, (IDFT - Inverse Discrete Fourier Transform),",
    "text": "TKFD - Ters Kesikli Fourier Dönüşümü, (IDFT - Inverse Discrete Fourier Transform),\nKFD’nin tersi de yapılabilir. Yani \\(X_{k}\\) değerlerinden \\(x_{n}\\) değerlerini bulabiliriz. Ters DFT formülü aşağıdaki gibidir. Ters Fourier dönüşümü, frekans bileşenlerini zaman bileşenlerine dönüştürerek orjinal sinyali elde etmemize yarar. Formülü aşağıdaki gibidir.\n\\[\nx_{n} = \\frac{1}{N} \\sum_{k=0}^{N-1} X_{k} e^{i 2 \\pi k n / N}\n\\]\nTKFD ile yapılan işlemler, KFD ile yapılan işlemlerin neredeyse aynısıdır. Sadece eksponansiyel terim negatif değil pozitif olacaktır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfdnin-limitleri",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kfdnin-limitleri",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "KFD’nin Limitleri",
    "text": "KFD’nin Limitleri\nDFT metodu ile bir sinyalin frekanslarını bulabiliriz ancak büyük bir sinyalde bu işlemi yapmak çok uzun sürecektir.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kod",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kod",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Kod",
    "text": "Kod\nfourier_kfd fonksiyonu bilYonMod.py dosyasına tanımlıdır. Aşağıdaki kodu inceleyelim ve örneklem sayısını kfd fonksyionunun gerçekleşme zamanını karşılaştıralım.\n\n\n\n\n\n\nNot\n\n\n\nfourier_kfd fonksiyonunu inceleyiniz.\n\n\n\n################################################\n## Modül yolunu varsayılan yol olarak ekleme ve modülü içe aktarma\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\n# 1 Boyutlu sinyal oluşturan fonksiyon\ndef olus_sin(orneklemOrani):\n    # Örneklem frekansı (rate)\n    ts = 1.0/orneklemOrani\n    # Örneklem aralığı\n    t = np.arange(0, 1, ts)\n    # Dalganın frekansı\n    frekans = 1.\n    # Genlik\n    genlik = 3\n    return genlik* np.sin(2* np.pi* frekans* t)\n# Orneklem Orani 1\norneklemOrani1 = 20\n# Toplam zamanı hesapla\nprint(f\"{orneklemOrani1} örneklem sayısına sahip bir dalganın\")\nprint(\"Fouirer dönüşümü yapması için geçen süre\")\n# FD Fonksiyonunu çağır ve %temit ile süreyi ölç\n%timeit bym.fourier_kfd(olus_sin(orneklemOrani1))\nprint(\"\\n\")\n# Orneklem Orani 2\norneklemOrani2 = 200\n# Toplam zamanı hesapla\nprint(f\"{orneklemOrani2} örneklem sayısına sahip bir dalganın\")\nprint(\" Fouirer dönüşümü yapması için geçen süre\")\n# FD Fonksiyonunu çağır ve %temit ile süreyi ölç\n%timeit bym.fourier_kfd(olus_sin(orneklemOrani2))\n\n20 örneklem sayısına sahip bir dalganın\nFouirer dönüşümü yapması için geçen süre\n567 µs ± 3.86 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n200 örneklem sayısına sahip bir dalganın\n Fouirer dönüşümü yapması için geçen süre\n54.7 ms ± 145 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\n\nZaman sorunu aşmak için 1965’te Cooley ve Tukey, Fourier dönüşümü algoritmasını geliştirdiler. Bu algoritma HFD, Hızlı Fourier Dönüşümü (FFT, Fast Fourier Transform) olarak bilinir - kesikli ifadesini kullanmacağız. HFD algoritması KFD’ye göre çok daha hızlı çalışır. HFD algoritmasının karmaşıklığı \\(\\mathcal{O}(n \\log n)\\) iken KFD’nin karmaşıklığı \\(\\mathcal{O}(n^2)\\)’dir.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tanımlar",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#tanımlar",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Tanımlar",
    "text": "Tanımlar\nAlıştırmalara geçmeden önce bazı tanımlar yapalım ve kullanacağımız tanımları hatırlayalım.\nÖncelikle bir dalgadan bahsediyorsak bir tekrardan bahsedebiliriz. Bundan dolayı belli bir pencere seçip o penceredeki sinyali analiz edeceğiz.\n\nZaman Uzayı\n\n\nÖrneklem sayısı (# of samples): Bir sinyali kaç adet örnek ile betimliyoruz [adet], N.\nÖrneklem oranı (sampling rate): Bir saniye içerisinde kaç örneklem olduğunu veren ifade [1/saniye] orneklemOrani.\nÖrnekleme aralığı (sampling interval): İki örneklem arasının kaç saniye olduğunu veren ifade [saniye], orneklemAraligi.\nZaman, pencere boyutu (time, frame size): Bir sinyalin kaç saniye içerisinde olduğunu veren ifade [saniye], t.\n\n\nFrekans Uzayı\n\n\nMaksimum Frekans, Nyquist Frekansı (maximum frequency, Nyquist frequency): Bir sinyalin içerisindeki en yüksek frekans [Hz], maxFrek. Maksimum frekans değeri, örneklem oranının yarısına eşittir, maxFrek=orneklemOrani/2.\nFrekans sayısı, Spektral Çizgiler (# of frequency, spectral lines): Bir sinyalin içerisindeki frekanslar [Hz], frekSayisi. Frekans sayısı, örnek sayısının yarısına eşittir, frekSayisi=N/2, çünkü hem pozitif hem negatif frekanslar bulunur.\nFrekans Çözünürlülüğü: Frekans uzayindaki iki frekans arasındaki fark [Hz], frekCoz=maksFrek/frekSayisi.\nFrekans (frequency): Tüm frekanslar, frek\n\n\n\n\n\n\n\nNot\n\n\n\nDaha önceden belirttiğimiz gibi frekansların ilk yarısı pozitif, ikinci yarıs ise negatif olarak tanımlanır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-1",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-1",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Alıştırma 1",
    "text": "Alıştırma 1\nBir sinüs sinyali, \\(\\sin(2\\pi f t)\\) düşünelim ve bunu \\([-2,2]\\) zaman aralığında çizelim.\n\nBu dalganın genlik-zaman grafiğini çizdirebilmek için frekans \\(f\\) değerini bilmem lazım. \\(f=4\\) [Hz] olsun frek=4.\nBu dalganın \\([-2,2]\\) arasında kaç nokta ile betimlediğimi belirtmem lazım. Örneklem sayısı \\(N=100\\) olsun, N=100.\nBu dalgan \\(N=100\\) ve toplam zaman \\(t=4\\) s için örneklem oranı \\(100/4\\) olurorneklemOrani=25. Bu değer, bir saniyede içerisinde \\(25\\) adet nokta olduğu anlamına gelir.\nBu dalganın örnekleme aralığı \\(1/25=0.04\\), orneklemAraligi=1/orneklemOrani. Bu değer, iki örneklem arasında \\(0.04\\) saniye olduğu anlamına gelir.\nZamanı oluşturabilirim. \\(t=-2\\)’den başlayıp \\(t=2\\)’ye kadar orneklemAraligi aralıklarla bir array oluşturum, t=np.arange(-2, 2, orneklemAraligi).\nKolayca gösterebilirsiniz ki zaman arrayinin eleman sayısı, t.size, örneklem sayısına, N’e, eşittir.\n\n\n\n\n\n\n\nUyarı\n\n\n\nt=np.arange(-2, 2, orneklemAraligi) kodunda \\(N=100\\) adet nokta vardır ancak son nokta, \\(t=2\\), noktası alınmamıştır.\n\n\n\nMaksiumum frekans değerini bulurken toplam örneklem sayısına ihtiyacımız vardır.\n\nÖrneklem sayısı çift olursa maksiumum frekans değeri \\(N/2\\) olur, maksFrek=N/2.\nÖrneklem sayısı tek olursa maksiumum frekans değeri \\((N-1)/2\\) olur, maksFrek=(N-1)/2.\n\nFrekans çözünürlülüğü bulurken örneklem sayısına ihtiyacımız vardır.\n\nÖrneklem sayısı çift olursa frekans çözünürlülüğü \\(maksFrek/frekSayisi\\) olur, frekCoz=maksFrek/(N/2).\nÖrneklem sayısı tek olursa frekans çözünürlülüğü \\(maksFrek/frekSayisi\\) olur, frekCoz=maksFrek/((N-1)/2).\n\nKFD sonucunda elde ettiğimiz \\(X_{k}\\) değerlerinin ilk yarısı pozitif, kalan yarısı ise negatif olarak tanımlanır.\n\nÖrneklem sayısı çift olursa, pozitif DFT değerleri şöyle olur: XPoz= X[:int(N/2)], negatif DFT değerleri şöyle olur: XNeg= X[int(N/2):].\nÖrneklem sayısı tek olursa, pozitif DFT değerleri şöyle olur: XPoz= X[:int((N-1)/2)], negatif DFT değerleri şöyle olur: XNeg= X[int((N+1)/2):].\n\nPozitif frekanslar frekPoz= np.arange(0, maksFrek, frekCoz) ve negatif frekanslar frekNeg= np.arange(-maksFrek, 0, frekCoz) şeklinde tanımlanır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-2",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#alıştırma-2",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Alıştırma 2",
    "text": "Alıştırma 2\n\nAşağıdaki formülü verilen sinyali, 100 örneklem oranı kullanarak \\(-2\\pi,2\\pi\\) arasında çizdirin.\n\n\\[\ny(t) = 7 \\sin(2\\pi t)\n\\]\nBu sinyalin KFD’sini alın ve genlik ve faz değerlerini bulun.\n\nÇözüm\n\n################################################\nimport os\nimport sys\n# Bu dosyanın bulunduğu dizini al\ncurrent_dir = os.path.abspath('')\n# 3 üst dizine çık\nmodule_dir = os.path.join(os.path.abspath(os.path.join(current_dir, os.pardir, os.pardir, os.pardir)), 'moduller')\n# moduller dizinini yol olarak ekle\nsys.path.append(module_dir)\n# bilYonMod.py modülünü içe aktar\nimport bilYonMod as bym\n################################################\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Örneklem orani\norneklemOrani = 100\n# Örneklem aralığı\norneklemAraligi = 1.0/orneklemOrani\nt= np.arange(0, 6, orneklemAraligi)\n# Toplam örneklem sayısı\nN= t.size\n# Dalganın frekansı\nacisalFrekans= 10\ngenlik= 5\n# Çiz\nsinyal= genlik* np.sin(acisalFrekans* t)\nplt.plot(t, sinyal, 'b', label= f'${genlik} \\sin({acisalFrekans} t)$')\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.legend()\nplt.show()\nplt.close()\n# Kesikli Fourier Dönüşümü\nX = bym.fourier_kfd(sinyal)\n# Frekans\nif N%2 == 0:\n    maksFrek= N/ 2\n    frekCoz=maksFrek/ (N/2)\n    XPoz= X[:int(N/2)]\n    XNeg= X[int(N/2):]\nelse:\n    maksFrek= (N-1)/ 2\n    frekCoz=maksFrek/ ((N-1)/2)\n    XPoz= X[:int((N-1)/2)]\n    XNeg= X[int((N+1)/2):]\nfrekPoz= np.arange(0, maksFrek, frekCoz)\nfrekNeg= np.arange(-maksFrek, 0, frekCoz)\n# Genlik ve Faz Değerlerini Çiz\nplt.stem(frekPoz, np.abs(XPoz)/(N/2), 'b', label= 'Pozitif Genlik', markerfmt=\" \", basefmt=\"-b\")\nplt.stem(frekNeg, np.abs(XNeg)/(N/2), 'r', label= 'Negatif Genlik', markerfmt=\" \", basefmt=\"-r\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Frekans (Hz)\")\nplt.xlim(-acisalFrekans-10, acisalFrekans+10)\nplt.legend()\nplt.show()",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#problemler",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#problemler",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\nAçısal frekansı 5, genliği 10 olan bir cosinüs sinyali çizdirin Örneklem oranı \\(100\\), \\(t=[0,6)\\) aralığında olsun. Sinyalin KFD’sini alın ve bu değerleri pozitif/negatif frekanslara göre çizdirin.\n\n\nProblem 2\nAçısal frekansı 5, genliği 10 olan bir cosinüs sinyali ve açısal frekansı 10, genliği 5 olan bir cosinüs sinyalinin toplamını çizdirin çizdirin Örneklem oranı \\(100\\), \\(t=[0,6)\\) aralığında olsun. Sinyalin KFD’sini alın ve bu değerleri pozitif/negatif frekanslara göre çizdirin.\n\n\nProblem 3\nZamandan bağımsız Schrödinger denklemini boşluk için çözdüğümüzde Gaussian dalga paketini elde ederiz. Konum uzayındaki dalga fonksiyonu aşağıdaki gibidir  [3].\n\\[ \\psi(x, t=0) = &lt;x | \\psi(0)&gt;= e^{-\\frac{(x^{2}- \\mu)}{4\\sigma_{x}^{2}}+i k_{0} x}\\]\nBurada \\(\\mu\\) paketin merkezini yani ortalama (mean) değeridir. \\(\\sigma_{x}\\) ise \\(x\\) uzayındaki standart sapmayı yani belirsizliği verir. \\(k_{0}= p/\\hbar\\) ise paketin momentumunu verir.\n\nYukarıda verilen dalga paketini konum uzayında olasılık yoğunluğunu çizdirin. Formülde \\(\\mu = 0\\), \\(\\sigma_{x} = 0.1\\) ve \\(k_{0} = 10\\) olarak alın.\nElde ettiğiniz dalga paketinin Fourier dönüşümünü hesaplayın.\n\nHFD sonucunu np.fft.fftshift fonksiyonu ile kaydırın. Bu işlem \\(k\\) uzayının \\(-k_{max}\\) ile \\(k_{max}\\) arasında yapın. Bunun için np.fft.fftshift(np.fft.fft(veri)) kullanabilirsiniz.\nFourier dönüşümünü \\(\\frac{2\\pi}{L}\\) ile normalize edin.\nFourier dönüşümünün frekansını belirleyin. Bunun için np.fft.fftshift(np.fft.fftfreq(L, dx)) formülünü kullanabilirsiniz.\n\nFourier dönüşümünden elde ettiğiniz Gaussian dalga paketinin momentum uzayındaki olasılık yoğunluğunu çizdirin.\nTüm işlemi \\(\\sigma_x=0.01\\) için tekrar edin. Konum uzayındaki olasılık fonksiyonu ve momentum uzayındaki olasılık fonksiyonunu nasıl değişti?\nAynı işlemi \\(\\sigma_x=0.001\\) için tekrar edin. Konum uzayındaki olasılık fonksiyonu ve momentum uzayındaki olasılık fonksiyonunu nasıl değişti?\nYukarıdaki işlem ile Heisenberg belirsizlik ilkesi arasında nasıl bir bağlantı var mıdır?",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kaynaklar",
    "href": "icerik/konular/fourier-analizi/kfd-kesikli-fourier-donusumu.html#kaynaklar",
    "title": "KFD - Kesikli Fourier Dönüşümü",
    "section": "Kaynaklar",
    "text": "Kaynaklar\n\nPython Programming and Numerical Methods, Qingkai Kong, 2018\nhttps://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "KFD - Kesikli Fourier Dönüşümü"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html",
    "href": "icerik/konular/fourier-analizi/giris.html",
    "title": "Giriş",
    "section": "",
    "text": "Basit bir sinüs dalgası oluşturalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# x-y noktaları\nx= np.linspace(0,8*np.pi,1000)\ny= np.sin(x)\n# Çiz\nplt.plot(x,y)\nplt.ylabel('Genlik')\nplt.xlabel('x')\nplt.show()\n\n\n\n\n\n\n\n\nSinüs dalgası hem zamanda hem de uzayda değişebilir. Yukarıda çizilen dalga zaman içerisinde değişmemektedir yani durağan bir dalgadır. Durağan olmayan dalgalara örnek bir kod yazalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nzaman= np.arange(5)\nx= np.linspace(0,8*np.pi,1000)\nn= len(zaman)\n#Çiz\nfor t in zaman:\n    plt.subplot(n,1,t+1)\n    y= np.sin(x+t)\n    plt.plot(x,y, 'b')\n    plt.plot(x[25], y[25], 'ro')\n    plt.ylim(-1.1,1.1)\n    plt.ylabel('y')\n    plt.title(f\"t={t}\")\nplt.xlabel('x')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki grafikte kırmızı nokta durağan olmayan bir dalganın konumunu göstermektedir. Bu davranış, tıpkı bir su dalgası üzerinde bulunan bir odun parçasının yukarı aşağıya gitmesi gibidir. Dalga x doğrultusunda ilerlerken, odun parçası yukarı aşağıya hareket eder.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html#fourier-analizi",
    "href": "icerik/konular/fourier-analizi/giris.html#fourier-analizi",
    "title": "Giriş",
    "section": "",
    "text": "Basit bir sinüs dalgası oluşturalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# x-y noktaları\nx= np.linspace(0,8*np.pi,1000)\ny= np.sin(x)\n# Çiz\nplt.plot(x,y)\nplt.ylabel('Genlik')\nplt.xlabel('x')\nplt.show()\n\n\n\n\n\n\n\n\nSinüs dalgası hem zamanda hem de uzayda değişebilir. Yukarıda çizilen dalga zaman içerisinde değişmemektedir yani durağan bir dalgadır. Durağan olmayan dalgalara örnek bir kod yazalım.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nzaman= np.arange(5)\nx= np.linspace(0,8*np.pi,1000)\nn= len(zaman)\n#Çiz\nfor t in zaman:\n    plt.subplot(n,1,t+1)\n    y= np.sin(x+t)\n    plt.plot(x,y, 'b')\n    plt.plot(x[25], y[25], 'ro')\n    plt.ylim(-1.1,1.1)\n    plt.ylabel('y')\n    plt.title(f\"t={t}\")\nplt.xlabel('x')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki grafikte kırmızı nokta durağan olmayan bir dalganın konumunu göstermektedir. Bu davranış, tıpkı bir su dalgası üzerinde bulunan bir odun parçasının yukarı aşağıya gitmesi gibidir. Dalga x doğrultusunda ilerlerken, odun parçası yukarı aşağıya hareket eder.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html#dalgaların-karakteristikleri",
    "href": "icerik/konular/fourier-analizi/giris.html#dalgaların-karakteristikleri",
    "title": "Giriş",
    "section": "Dalgaların Karakteristikleri",
    "text": "Dalgaların Karakteristikleri\nDalgaların karakteristik özelliklerini tanımlayan bazı ifadeler aşağıda maddelenmiştir.\n\nFrekans: Dalganın birim zamanda kaç kez tekrarlandığını gösterir. Birimi Hz (Hertz)’dir. 1 Hz = 1 s\\(^{-1}\\)\nPeriyot: Dalganın bir tam periyotu tamamlaması için geçen süredir. Birimi s (saniye)’dir. Periyod ile frekans ters orantılıdır. Yani frekans = 1 / periyot.\nGenlik: Dalganın alabileceği maksimum değeridir.\nDalgaboyu: Dalganın bir tam periyotu boyunca. Birimi uzunlukdur.\n\n\n\n\n\n\n\nNot\n\n\n\nDalgalar/sinyaller sürekli tekrar eder. Analiz yaparken dalgaların belirli bir aralıktaki değerini çizdiririz. Bu aralığa pencere aralığı denir. Örneğin bir ses dalgasının ekolayzorını yapmak isteyelim. Basların ve tizlerin yoğunluğunu belirli bir pencere aralığında gösteririz ve bu bas/tizler şarkının her pencere aralığında farklı değerler olacaktır.\n\n\nBu nicelikleri grafik üzerinde gösteren python kodunu yazalım  [1].\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Dalganın karakteristikleri\nfrekans = 2  # Hz\nperiyot = 1 / frekans  # s\ngenlik = 1\ndalga_uzunlugu = 2  # metre\n# Zaman aralığı\nt = np.linspace(0, 2* periyot, 50)\n# Dalganın formülü\ndalga = genlik * np.sin(2* np.pi* frekans* t)\n# Çiz\nplt.plot(t, dalga, label='Dalga', color='blue')\nplt.plot(t, dalga, 'o', label='Örneklemler', color='magenta')\n# Genlik oku\nplt.annotate('', xy=(0.12, genlik), xytext=(0.12, 0),\n             arrowprops=dict(facecolor='red'))\nplt.text(0.08, genlik / 2.8, 'GENLİK', rotation=90, color='red')\n# Periyot oku\nplt.annotate('', xy=(0.6, 1), xytext=(0.15, 1),\n             arrowprops=dict(facecolor='green'))\nplt.text(0.32, 0.85, 'PERİYOT', rotation=0, color='green')\nplt.title('Dalganın Özellikleri')\nplt.xlabel('Zaman (s)')\nplt.ylabel('Genlik')\nplt.xlim(0, 2*periyot)\nplt.ylim(-1.3, 1.3)\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nYukarıdaki şekilde fuşya (galibarda, magenta) noktalar ise örneklemdir (sampling).\nÖrneklem oranı (sampling rate) ise örneklem sıklığını gösterir. Örneklem sıklığını yukarıdaki grafikte noktaların sıklığı olarak düşünebiliriz. Örneklem oranı arttıkça dalga daha iyi bir şekilde temsil edilir.\nDiğer karakteristikleri de anlamak için durağan olmayan bir sinüs dalgası ele alalım.\n\\[\ny(t) = A \\sin(\\omega t + \\phi)\n\\]\nBurada \\(A\\) genlik, \\(\\omega\\) açısal frekans, \\(\\phi\\) ise fazdır.\nAçısal frekans ise \\(\\omega = 2 \\pi f\\) şeklinde hesaplanır. Burada \\(f\\) frekansıdır.\nFaz, \\(\\phi\\) ise dalganın başlangıç noktasını belirler.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Zaman\nt = np.arange(0,2* np.pi, 0.1)\n# Çiz (farklı frekanslar)\nplt.title(\"Farklı Frekanslar\")\nplt.plot(t, np.cos(2*np.pi*0.2*t), \"b\", label=\"sin(2$\\pi$0.2t)\")\nplt.plot(t, np.cos(2*np.pi*0.4*t), \"r\", label=\"sin(2$\\pi$0.4t)\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi],\n    [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\"])\nplt.legend()\nplt.show()\nplt.close()\n# Çiz (farklı fazlar)\nplt.title(\"Faz Farkı\")\nplt.plot(t, np.cos(2*np.pi*0.2*t), \"g\", label=\"sin(2$\\pi$0.2t)\")\nplt.plot(t, np.cos(2*np.pi*0.2*t+ np.pi/2),\n    \"k\", label=\"sin(2$\\pi$0.2t + $\\pi$/2)\")\nplt.ylabel(\"Genlik\")\nplt.xlabel(\"Zaman (s)\")\n# X label in terms of pi\nplt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi],\n              [\"0\", \"$\\pi$/2\", \"$\\pi$\", \"3$\\pi$/2\", \"2$\\pi$\"])\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYukarıdaki grafikte farklı frekanslar ve farklı fazlar için dalgalar çizilmiştir. İki veya daha fazla dalganın üst üste binmesiyle oluşan dalgaların analizi için Fourier analizi kullanılır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi/giris.html#problemler",
    "href": "icerik/konular/fourier-analizi/giris.html#problemler",
    "title": "Giriş",
    "section": "Problemler",
    "text": "Problemler\n\nProblem 1\n\nFrekansı 2 Hz, genliği 1 ve fazı 0 olan bir cosinüs dalgasını çizdirin.\nBu dalgayı ve yeni bir dalgayı daha kullanarak yapıcı ve yıkıcı girişimleri gösteren bir grafik çizdirin.\n\n\n\nProblem 2\n\\(0\\) ile \\(L\\) arasında sonsuz kuyuda hapsedilmiş parçacığın durağan dalga fonksiyonu aşağıdaki gibi yazılır.\n\\[\n\\psi(x)=\\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi x}{L}\\right)\n\\]\nBurada \\(L=2\\) [birimsiz] kuyunun uzunluğu, \\(n\\) ise kuantum numarasıdır. Aşağıdaki soruları cevaplayın.\n\nBu fonksiyonu \\(N=1,2,3\\) için çizdirin. Grafiğin başlığına genliği, frekansı ve fazı yazın.\nOlasılık yoğunluğunu çizdirin. Olasılık yoğunluğu \\(|&lt;\\psi(x)|\\psi(x)&gt;|^{2}\\) olarak hesaplanır.",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi",
      "Giriş"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi.html",
    "href": "icerik/konular/fourier-analizi.html",
    "title": "Fourier Analizi",
    "section": "",
    "text": "Fourier analizi, matematik ve mühendislikte temel bir rol oynayan güçlü bir araçtır. İsmini 18. yüzyıl Fransız matematikçisi Joseph Fourier’den alan bu analiz yöntemi, karmaşık dalgaları basit sinüzoidal bileşenlere ayırarak, doğrusal olmayan sistemlerin incelenmesinde ve sinyal işlemede kullanılır. Başlangıçta ısı iletimi problemlerini çözmek için geliştirilmiş olmasına rağmen, günümüzde birçok disiplinde geniş bir uygulama alanı bulmuştur. Ses, görüntü ve veri işleme gibi alanlarda sıklıkla kullanılan Fourier analizi, bir sinyalin frekans bileşenlerini ayrıştırarak, karmaşıklığı anlamamıza ve sistemleri daha iyi anlamamıza olanak tanır.\nFourier dönüşümü, bir sinyalin zaman alanındaki işaretini frekans alanına dönüştürmek için integral hesabını kullanır. Bu dönüşüm, sürekli zamanlı sinyaller için integral formunda ifade edilirken, aynı prensibi kullanarak, dijital sinyaller için de uygulanabilir.\nFourier analizi, ses işleme, görüntü işleme, telekomünikasyon, sinyal işleme ve birçok fiziksel ve mühendislik uygulamasında yaygın olarak kullanılır. Örneğin, bir ses dosyasının frekans içeriğini analiz ederek, hangi frekanslardaki seslerin baskın olduğunu belirleyebiliriz. Benzer şekilde, bir elektrik devresinin frekans tepkisi incelenebilir veya bir görüntünün frekans bileşenleri üzerinde işlem yapılabilir. Bu şekilde, Fourier analizi, karmaşık sistemlerin anlaşılmasına ve işlenmesine olanak sağlar.  [1]",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi"
    ]
  },
  {
    "objectID": "icerik/konular/fourier-analizi.html#fourier-analizi",
    "href": "icerik/konular/fourier-analizi.html#fourier-analizi",
    "title": "Fourier Analizi",
    "section": "",
    "text": "Fourier analizi, matematik ve mühendislikte temel bir rol oynayan güçlü bir araçtır. İsmini 18. yüzyıl Fransız matematikçisi Joseph Fourier’den alan bu analiz yöntemi, karmaşık dalgaları basit sinüzoidal bileşenlere ayırarak, doğrusal olmayan sistemlerin incelenmesinde ve sinyal işlemede kullanılır. Başlangıçta ısı iletimi problemlerini çözmek için geliştirilmiş olmasına rağmen, günümüzde birçok disiplinde geniş bir uygulama alanı bulmuştur. Ses, görüntü ve veri işleme gibi alanlarda sıklıkla kullanılan Fourier analizi, bir sinyalin frekans bileşenlerini ayrıştırarak, karmaşıklığı anlamamıza ve sistemleri daha iyi anlamamıza olanak tanır.\nFourier dönüşümü, bir sinyalin zaman alanındaki işaretini frekans alanına dönüştürmek için integral hesabını kullanır. Bu dönüşüm, sürekli zamanlı sinyaller için integral formunda ifade edilirken, aynı prensibi kullanarak, dijital sinyaller için de uygulanabilir.\nFourier analizi, ses işleme, görüntü işleme, telekomünikasyon, sinyal işleme ve birçok fiziksel ve mühendislik uygulamasında yaygın olarak kullanılır. Örneğin, bir ses dosyasının frekans içeriğini analiz ederek, hangi frekanslardaki seslerin baskın olduğunu belirleyebiliriz. Benzer şekilde, bir elektrik devresinin frekans tepkisi incelenebilir veya bir görüntünün frekans bileşenleri üzerinde işlem yapılabilir. Bu şekilde, Fourier analizi, karmaşık sistemlerin anlaşılmasına ve işlenmesine olanak sağlar.  [1]",
    "crumbs": [
      "**Konular**",
      "Fourier Analizi"
    ]
  }
]